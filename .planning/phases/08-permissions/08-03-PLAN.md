---
phase: 08-permissions
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - electron-app/src/renderer/hooks/use-document-permissions.ts
  - electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
  - electron-app/src/renderer/components/knowledge/folder-context-menu.tsx
  - electron-app/src/renderer/components/knowledge/folder-tree.tsx
  - electron-app/src/renderer/components/knowledge/document-editor.tsx
autonomous: true

must_haves:
  truths:
    - "Viewers cannot see create/edit/delete controls in the sidebar or context menu"
    - "Editors see create and edit controls but not delete for application-scoped items"
    - "Owners see all controls"
    - "Personal scope shows all controls only for the note creator"
    - "Editor is read-only for users without edit permission"
  artifacts:
    - path: "electron-app/src/renderer/hooks/use-document-permissions.ts"
      provides: "useDocumentPermissions hook returning canCreate, canEdit, canDelete, canForceUnlock, isReadOnly"
      exports: ["useDocumentPermissions", "DocumentPermissions"]
      min_lines: 25
    - path: "electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx"
      provides: "Permission-aware sidebar that hides create buttons for viewers"
      contains: "useDocumentPermissions"
    - path: "electron-app/src/renderer/components/knowledge/folder-context-menu.tsx"
      provides: "Permission-aware context menu that hides edit/delete options for viewers"
      contains: "canEdit|canDelete|canCreate|isReadOnly"
  key_links:
    - from: "electron-app/src/renderer/hooks/use-document-permissions.ts"
      to: "electron-app/src/renderer/contexts/knowledge-base-context.tsx"
      via: "Reads scope from KnowledgeBase context"
      pattern: "useKnowledgeBase|scope"
    - from: "electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx"
      to: "electron-app/src/renderer/hooks/use-document-permissions.ts"
      via: "Consumes permissions to show/hide controls"
      pattern: "useDocumentPermissions"
---

<objective>
Create the useDocumentPermissions hook and wire it into the knowledge base UI components so that create/edit/delete controls are hidden or disabled based on the user's role.

Purpose: Prevents confusing UI where users see buttons they cannot use. The backend (Plan 08-02) independently enforces permissions, but the frontend should provide a good UX by hiding controls proactively.
Output: One new hook file and modifications to 4 existing components.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-permissions/08-RESEARCH.md

@electron-app/src/renderer/contexts/knowledge-base-context.tsx
@electron-app/src/renderer/hooks/use-document-lock.ts
@electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
@electron-app/src/renderer/components/knowledge/folder-context-menu.tsx
@electron-app/src/renderer/components/knowledge/folder-tree.tsx
@electron-app/src/renderer/components/knowledge/document-editor.tsx
@electron-app/src/renderer/pages/applications/[id].tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useDocumentPermissions hook</name>
  <files>electron-app/src/renderer/hooks/use-document-permissions.ts</files>
  <action>
Create `electron-app/src/renderer/hooks/use-document-permissions.ts`.

Export a `DocumentPermissions` interface:
```typescript
export interface DocumentPermissions {
  canCreate: boolean
  canEdit: boolean
  canDelete: boolean
  canForceUnlock: boolean
  isReadOnly: boolean
}
```

Export a `useDocumentPermissions` hook:
```typescript
export function useDocumentPermissions(
  scope: 'all' | 'personal' | 'application' | 'project',
  applicationUserRole: string | null,
  isPersonalOwner: boolean
): DocumentPermissions
```

Logic:
- `scope === 'all'`: Return all-false permissions (read-only aggregate view). `isReadOnly: true`.
- `scope === 'personal'`: All permissions mirror `isPersonalOwner`. `canForceUnlock: false` (no app context for force-unlock on personal docs).
- `scope === 'application'` or `scope === 'project'`:
  - `isOwner = applicationUserRole === 'owner'`
  - `isEditor = applicationUserRole === 'editor'`
  - `canCreate: isOwner || isEditor`
  - `canEdit: isOwner || isEditor`
  - `canDelete: isOwner` (owner-only for app-scoped delete, matching backend)
  - `canForceUnlock: isOwner`
  - `isReadOnly: !isOwner && !isEditor`

Use `useMemo` to memoize the return object (depends on scope, applicationUserRole, isPersonalOwner).

The hook does NOT fetch any data -- it derives permissions from already-available data. The calling component is responsible for providing `applicationUserRole` (from the application query response) and `isPersonalOwner` (scope === 'personal' && scopeId === currentUser.id).
  </action>
  <verify>
Run: `cd D:/FTX_CODE/pm-project/electron-app && npx tsc --noEmit src/renderer/hooks/use-document-permissions.ts 2>&1 | head -5` (or use the project's typecheck command if available).

If typecheck is not available standalone, verify the file has the correct structure by reading it.
  </verify>
  <done>useDocumentPermissions hook exists, exports DocumentPermissions interface, and derives all permission flags from scope and role data without any API calls.</done>
</task>

<task type="auto">
  <name>Task 2: Wire permissions into sidebar and context menu</name>
  <files>
    electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
    electron-app/src/renderer/components/knowledge/folder-context-menu.tsx
    electron-app/src/renderer/components/knowledge/folder-tree.tsx
    electron-app/src/renderer/components/knowledge/document-editor.tsx
  </files>
  <action>
First, determine how to get `applicationUserRole` in the knowledge base components. Read the KnowledgeBaseContext and the Notes page to understand:
- How the current scope and scopeId are tracked
- How application data is fetched (likely via TanStack Query)
- Where `user_role` is available in the existing app

The pattern from `pages/applications/[id].tsx` is: `const userRole = application?.user_role || 'viewer'`. The knowledge base components need similar access.

**Approach:** The useDocumentPermissions hook should be called in a parent component (likely `knowledge-sidebar.tsx` or the Notes page) that has access to both scope state and application data. Then pass the permission flags down via props.

**knowledge-sidebar.tsx:**
1. Import `useDocumentPermissions` and call it with the current scope context
2. To get `applicationUserRole`: When scope is 'application' or 'project', the selected application/project data should already be available via TanStack Query. Check how the sidebar currently fetches data and find where `user_role` is available. If it's not readily available, the hook can accept it as a parameter from the parent Notes page.
3. Pass `permissions` (or individual flags like `canCreate`) down to `FolderTree` as a prop
4. Conditionally render the "New Document" and "New Folder" buttons only when `permissions.canCreate` is true. If the sidebar has create buttons, wrap them in `{permissions.canCreate && (<button>...)}`

**folder-tree.tsx:**
1. Accept a `canCreate` prop (or full `DocumentPermissions` object)
2. Pass it through to context menu trigger logic
3. If there are inline create buttons in the tree, conditionally render them

**folder-context-menu.tsx:**
1. Accept permission props: `canCreate: boolean`, `canEdit: boolean`, `canDelete: boolean`
2. Filter the menu items array based on permissions:
   - "New Folder" and "New Document": only show if `canCreate`
   - "Rename": only show if `canEdit`
   - "Delete": only show if `canDelete`
3. If ALL actions are hidden (viewer with no permissions), either don't show the context menu at all, or show it with only a "Copy link" or similar read-only action. Simplest: if no items to show, return null (don't render menu).

**document-editor.tsx:**
1. Accept an `isReadOnly` prop (or derive from permissions)
2. When `isReadOnly` is true:
   - Pass `editable: false` to the TipTap editor instance (check how the editor is initialized -- there may be an `editable` prop on the Editor component or in useEditor options)
   - Hide the toolbar (or disable toolbar buttons)
   - Show a subtle "Read-only" indicator
3. Note: The editor may already have read-only handling from the locking feature (LockBanner sets editor to read-only when locked by another user). Integrate with that pattern -- permissions-based read-only should work alongside lock-based read-only.

Important: Do NOT break existing functionality. The permission-based read-only is additive to the lock-based read-only. A user with edit permissions who opens a locked document should still see the lock banner. A viewer should see "Read-only" even if the document is not locked.
  </action>
  <verify>
Run the frontend typecheck: `cd D:/FTX_CODE/pm-project/electron-app && npm run typecheck`

Verify no new type errors introduced. Check that:
1. knowledge-sidebar.tsx imports useDocumentPermissions
2. folder-context-menu.tsx accepts and uses permission props
3. document-editor.tsx respects isReadOnly prop
  </verify>
  <done>
- Sidebar hides create buttons for viewers
- Context menu hides edit/delete options based on role
- Editor is read-only for viewers (toolbar hidden/disabled, editable: false)
- All changes pass typecheck
- Existing lock-based read-only still works alongside permission-based read-only
  </done>
</task>

</tasks>

<verification>
- `npm run typecheck` passes with zero new errors
- useDocumentPermissions hook exists and exports correctly
- Sidebar conditionally renders create controls
- Context menu filters items by permission
- Editor respects isReadOnly flag
- Lock-based read-only (LockBanner) still works for users with edit permission
</verification>

<success_criteria>
- Viewers see no create/edit/delete controls in sidebar or context menu
- Viewers see read-only editor with no toolbar
- Editors see create and edit controls but not delete for application scope
- Owners see all controls
- Personal scope: all controls for creator, nothing for others (though others shouldn't reach the UI)
- Frontend typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/08-permissions/08-03-SUMMARY.md`
</output>
