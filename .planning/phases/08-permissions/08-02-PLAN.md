---
phase: 08-permissions
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - fastapi-backend/app/routers/documents.py
  - fastapi-backend/app/routers/document_folders.py
  - fastapi-backend/app/routers/document_tags.py
autonomous: true

must_haves:
  truths:
    - "Application owners can create, edit, delete any document in their application"
    - "Editors can create and edit documents within their application/project scope"
    - "Viewers can read documents in their scope but cannot create, edit, or delete"
    - "Personal notes are accessible only by their creator"
    - "Document list API returns 403 for unauthorized scope access"
    - "Folder and tag CRUD endpoints enforce the same permission rules as documents"
  artifacts:
    - path: "fastapi-backend/app/routers/documents.py"
      provides: "Permission guards on all 10 document endpoints"
      contains: "DocumentPermissionService"
    - path: "fastapi-backend/app/routers/document_folders.py"
      provides: "Permission guards on all 4 folder endpoints"
      contains: "DocumentPermissionService"
    - path: "fastapi-backend/app/routers/document_tags.py"
      provides: "Permission guards on all 4 tag endpoints"
      contains: "DocumentPermissionService"
  key_links:
    - from: "fastapi-backend/app/routers/documents.py"
      to: "fastapi-backend/app/services/document_permission_service.py"
      via: "Import and instantiate DocumentPermissionService"
      pattern: "DocumentPermissionService\\(db\\)"
    - from: "fastapi-backend/app/routers/document_folders.py"
      to: "fastapi-backend/app/services/document_permission_service.py"
      via: "Import and instantiate DocumentPermissionService"
      pattern: "DocumentPermissionService\\(db\\)"
    - from: "fastapi-backend/app/routers/document_tags.py"
      to: "fastapi-backend/app/services/document_permission_service.py"
      via: "Import and instantiate DocumentPermissionService"
      pattern: "DocumentPermissionService\\(db\\)"
---

<objective>
Add permission guards to all document, folder, and tag API endpoints using the DocumentPermissionService from Plan 08-01.

Purpose: Enforces PERM-01 through PERM-06 at the API level. Without this, any authenticated user can CRUD any document.
Output: Three modified router files with permission checks on every endpoint.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-permissions/08-RESEARCH.md
@.planning/phases/08-permissions/08-01-SUMMARY.md

@fastapi-backend/app/services/document_permission_service.py
@fastapi-backend/app/routers/documents.py
@fastapi-backend/app/routers/document_folders.py
@fastapi-backend/app/routers/document_tags.py
@fastapi-backend/app/routers/tasks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add permission guards to documents.py</name>
  <files>fastapi-backend/app/routers/documents.py</files>
  <action>
Read the full `documents.py` router. Add `from ..services.document_permission_service import DocumentPermissionService` at the top.

Add permission checks to each endpoint. The pattern is: after fetching the document (or validating scope), create `perm_service = DocumentPermissionService(db)`, call the appropriate check, and raise `HTTPException(status_code=403, detail="...")` if denied.

**Endpoint-by-endpoint:**

1. `GET /documents` (list) — Add at top of handler:
   ```python
   perm_service = DocumentPermissionService(db)
   if not await perm_service.get_scope_filter_for_list(current_user, scope, scope_id):
       raise HTTPException(status_code=403, detail="Access denied to this scope")
   ```
   Also for personal scope, add: `if scope == "personal" and scope_id != current_user.id: raise HTTPException(403, "Cannot access another user's personal documents")`

2. `GET /documents/trash` — NO CHANGE. Already filters by `created_by == current_user.id`. Leave as-is.

3. `POST /documents` (create) — After validating the request body, before creating:
   ```python
   perm_service = DocumentPermissionService(db)
   if not await perm_service.can_create_in_scope(current_user, body.scope, body.scope_id):
       raise HTTPException(status_code=403, detail="You do not have permission to create documents in this scope")
   ```
   Note: The scope and scope_id come from the request body (DocumentCreate schema). Check how the existing endpoint resolves scope to determine the exact field names.

4. `GET /documents/{id}` (get single) — After fetching document:
   ```python
   perm_service = DocumentPermissionService(db)
   if not await perm_service.can_read_document(current_user, document):
       raise HTTPException(status_code=403, detail="You do not have permission to view this document")
   ```

5. `PUT /documents/{id}` (update metadata) — After fetching document:
   ```python
   perm_service = DocumentPermissionService(db)
   if not await perm_service.can_edit_document(current_user, document):
       raise HTTPException(status_code=403, detail="You do not have permission to edit this document")
   ```

6. `PUT /documents/{id}/content` (auto-save content) — CRITICAL: Same guard as update:
   ```python
   perm_service = DocumentPermissionService(db)
   if not await perm_service.can_edit_document(current_user, document):
       raise HTTPException(status_code=403, detail="You do not have permission to edit this document")
   ```

7. `DELETE /documents/{id}` (soft delete) — After fetching document:
   ```python
   perm_service = DocumentPermissionService(db)
   if not await perm_service.can_delete_document(current_user, document):
       raise HTTPException(status_code=403, detail="You do not have permission to delete this document")
   ```

8. `POST /documents/{id}/restore` — After fetching document:
   ```python
   perm_service = DocumentPermissionService(db)
   if not await perm_service.can_edit_document(current_user, document):
       raise HTTPException(status_code=403, detail="You do not have permission to restore this document")
   ```

9. `DELETE /documents/{id}/permanent` — After fetching document:
   ```python
   perm_service = DocumentPermissionService(db)
   if not await perm_service.can_delete_document(current_user, document):
       raise HTTPException(status_code=403, detail="You do not have permission to permanently delete this document")
   ```

10. `POST /documents/{id}/tags` (assign tag) — After fetching document:
    ```python
    perm_service = DocumentPermissionService(db)
    if not await perm_service.can_edit_document(current_user, document):
        raise HTTPException(status_code=403, detail="You do not have permission to edit this document")
    ```

11. `DELETE /documents/{id}/tags/{tag_id}` (unassign tag) — After fetching document:
    ```python
    perm_service = DocumentPermissionService(db)
    if not await perm_service.can_edit_document(current_user, document):
        raise HTTPException(status_code=403, detail="You do not have permission to edit this document")
    ```

Important: Read the actual endpoint implementations carefully before editing. The document fetch pattern may vary -- some use service functions, some use inline queries. Place the permission check AFTER the document is fetched (so 404 fires before 403 for non-existent docs).
  </action>
  <verify>
Run: `cd D:/FTX_CODE/pm-project/fastapi-backend && python -c "from app.routers.documents import router; print('Import OK')"`

Grep for DocumentPermissionService usage: count should be >= 9 (one per guarded endpoint, excluding trash which stays unguarded).
  </verify>
  <done>All 10 document endpoints (excluding trash) have permission guards. List checks scope access. CRUD checks read/edit/delete as appropriate. Content save endpoint is guarded.</done>
</task>

<task type="auto">
  <name>Task 2: Add permission guards to document_folders.py and document_tags.py</name>
  <files>fastapi-backend/app/routers/document_folders.py, fastapi-backend/app/routers/document_tags.py</files>
  <action>
**document_folders.py** — Read the full file. Add `from ..services.document_permission_service import DocumentPermissionService` import.

Guard each endpoint:

1. `GET /document-folders/tree` (list) — Add scope access check:
   ```python
   perm_service = DocumentPermissionService(db)
   if not await perm_service.get_scope_filter_for_list(current_user, scope, scope_id):
       raise HTTPException(status_code=403, detail="Access denied to this scope")
   ```
   For personal scope: `if scope == "personal" and scope_id != current_user.id: raise HTTPException(403, ...)`

2. `POST /document-folders` (create) — After reading scope from request body:
   ```python
   perm_service = DocumentPermissionService(db)
   if not await perm_service.can_create_in_scope(current_user, body.scope, body.scope_id):
       raise HTTPException(status_code=403, detail="You do not have permission to create folders in this scope")
   ```

3. `PUT /document-folders/{id}` (rename/move) — After fetching the folder, determine its scope from the folder's FK fields (application_id, project_id, user_id). Check edit permission:
   - Determine scope and scope_id from the folder object (same FK pattern as documents)
   - Call `can_create_in_scope(current_user, scope, scope_id)` -- "create" level is appropriate for folder management
   ```python
   perm_service = DocumentPermissionService(db)
   scope, scope_id = _get_folder_scope(folder)  # helper to extract scope from FKs
   if not await perm_service.can_create_in_scope(current_user, scope, scope_id):
       raise HTTPException(status_code=403, detail="You do not have permission to modify folders in this scope")
   ```
   Create a small helper `_get_folder_scope(folder)` that returns (scope_str, scope_id_uuid) from the folder's FK fields if it doesn't already exist. Pattern: if folder.application_id -> ("application", folder.application_id); if folder.project_id -> ("project", folder.project_id); if folder.user_id -> ("personal", folder.user_id).

4. `DELETE /document-folders/{id}` — After fetching folder:
   - Application scope: owner-only (get_user_application_role via perm_service)
   - Project/personal scope: same as create-level check
   Implementation: For application scope, call `perm_service.can_create_in_scope` first (ensures membership), then additionally check if role is owner for app-scoped delete. OR simpler: use a similar pattern to can_delete_document -- owner-only for application scope.
   ```python
   perm_service = DocumentPermissionService(db)
   scope, scope_id = _get_folder_scope(folder)
   if scope == "application":
       from ..services.permission_service import PermissionService
       ps = PermissionService(db)
       role = await ps.get_user_application_role(current_user.id, scope_id)
       if role != "owner":
           raise HTTPException(status_code=403, detail="Only application owners can delete folders")
   else:
       if not await perm_service.can_create_in_scope(current_user, scope, scope_id):
           raise HTTPException(status_code=403, detail="You do not have permission to delete folders in this scope")
   ```
   Note: Access PermissionService through the perm_service's internal instance (`perm_service.permission_service`) to avoid double-instantiation, or just use DocumentPermissionService for this. Check which approach is cleaner.

**document_tags.py** — Read the full file. Add `from ..services.document_permission_service import DocumentPermissionService` import.

Guard each endpoint:

1. `GET /document-tags` (list) — Scope access check (same pattern as folder tree):
   ```python
   perm_service = DocumentPermissionService(db)
   if not await perm_service.get_scope_filter_for_list(current_user, scope, scope_id):
       raise HTTPException(status_code=403, detail="Access denied to this scope")
   ```

2. `POST /document-tags` (create) — Scope create check:
   ```python
   perm_service = DocumentPermissionService(db)
   if not await perm_service.can_create_in_scope(current_user, body.scope, body.scope_id):
       raise HTTPException(status_code=403, detail="You do not have permission to create tags in this scope")
   ```
   Check the TagCreate schema to identify the scope/scope_id field names.

3. `PUT /document-tags/{id}` (update) — After fetching tag, determine scope from tag FKs:
   ```python
   perm_service = DocumentPermissionService(db)
   scope, scope_id = _get_tag_scope(tag)
   if not await perm_service.can_create_in_scope(current_user, scope, scope_id):
       raise HTTPException(status_code=403, detail="You do not have permission to edit tags in this scope")
   ```
   Create `_get_tag_scope(tag)` helper similar to `_get_folder_scope`.

4. `DELETE /document-tags/{id}` — Application scope: owner-only. Personal scope: creator only. Same pattern as folder delete.

Important: Tags have `application_id` and `user_id` FKs (no project_id -- tags are scoped to application or personal per decision [01-04]). Adjust the scope helpers accordingly. Read the DocumentTag model to confirm FK fields before writing helpers.
  </action>
  <verify>
Run: `cd D:/FTX_CODE/pm-project/fastapi-backend && python -c "from app.routers.document_folders import router; from app.routers.document_tags import router as tr; print('Both import OK')"`

Grep for DocumentPermissionService in document_folders.py (should appear >= 4 times) and document_tags.py (should appear >= 4 times).
  </verify>
  <done>All 4 folder endpoints and all 4 tag endpoints have permission guards. Application-scoped delete is owner-only. Folder and tag CRUD requires appropriate scope membership.</done>
</task>

</tasks>

<verification>
- `python -c "from app.routers.documents import router"` succeeds (no import errors)
- `python -c "from app.routers.document_folders import router"` succeeds
- `python -c "from app.routers.document_tags import router"` succeeds
- Every mutating endpoint (POST/PUT/DELETE) in all three routers has a permission check
- GET list endpoints check scope access
- GET single document checks can_read_document
- Content save endpoint (PUT /documents/{id}/content) is guarded
- Trash endpoint remains unguarded (self-scoped by created_by)
</verification>

<success_criteria>
- 18+ endpoints across 3 router files have permission guards
- Viewers get 403 on create/edit/delete operations
- Editors get 403 on application-scoped delete (owner-only)
- Personal scope hard-checks user_id == current_user.id
- No N+1 queries on list endpoints (scope check once, not per-document)
- All three routers import cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/08-permissions/08-02-SUMMARY.md`
</output>
