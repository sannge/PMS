---
phase: 08-permissions
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - fastapi-backend/app/routers/documents.py
  - fastapi-backend/app/routers/document_folders.py
  - fastapi-backend/app/routers/document_tags.py
autonomous: true

must_haves:
  truths:
    - "Every document mutation endpoint (create, update, delete, trash, restore) checks permissions and returns 403 for unauthorized users"
    - "Every folder mutation endpoint (create, update, delete) checks permissions and returns 403 for unauthorized users"
    - "Every tag mutation endpoint (create, update, delete) checks permissions and returns 403 for unauthorized users"
    - "Document list endpoint verifies scope access before returning results (PERM-06)"
    - "Personal document endpoints reject requests where scope_id != current_user.id"
    - "GET single document checks can_read_document before returning"
  artifacts:
    - path: "fastapi-backend/app/routers/documents.py"
      provides: "Permission-guarded document CRUD endpoints"
      contains: "DocumentPermissionService"
    - path: "fastapi-backend/app/routers/document_folders.py"
      provides: "Permission-guarded folder CRUD endpoints"
      contains: "DocumentPermissionService"
    - path: "fastapi-backend/app/routers/document_tags.py"
      provides: "Permission-guarded tag CRUD endpoints"
      contains: "DocumentPermissionService"
  key_links:
    - from: "fastapi-backend/app/routers/documents.py"
      to: "fastapi-backend/app/services/document_permission_service.py"
      via: "imports and calls permission check methods"
      pattern: "DocumentPermissionService|can_read|can_edit|can_delete|can_create_in_scope"
    - from: "fastapi-backend/app/routers/document_folders.py"
      to: "fastapi-backend/app/services/document_permission_service.py"
      via: "imports and calls scope permission methods"
      pattern: "can_create_in_scope|can_edit"
    - from: "fastapi-backend/app/routers/document_tags.py"
      to: "fastapi-backend/app/services/document_permission_service.py"
      via: "imports and calls scope permission methods"
      pattern: "can_create_in_scope"
---

<objective>
Add permission guards to every document, folder, and tag API endpoint using the DocumentPermissionService from Plan 01.

Purpose: Closes the authorization gap -- currently all endpoints authenticate but do not authorize. After this plan, no user can access documents/folders/tags outside their permitted scope and role.
Output: Three modified router files with permission checks on every mutating and read endpoint.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-permissions/08-RESEARCH.md
@.planning/phases/08-permissions/08-01-SUMMARY.md

Key source files:
@fastapi-backend/app/routers/documents.py
@fastapi-backend/app/routers/document_folders.py
@fastapi-backend/app/routers/document_tags.py
@fastapi-backend/app/services/document_permission_service.py
@fastapi-backend/app/routers/tasks.py (reference pattern for verify_project_access)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Guard document endpoints</name>
  <files>fastapi-backend/app/routers/documents.py</files>
  <action>
Add permission checks to every endpoint in `documents.py` by importing `DocumentPermissionService` (or `get_document_permission_service`) from the new service.

For each endpoint, create the service with `perm_service = DocumentPermissionService(db)` at the point of use.

**Endpoint-by-endpoint changes:**

1. `GET /documents/trash` (list_trash):
   - Currently filters by `created_by == current_user.id`. This is already personal-only. No change needed -- trash is a personal convenience (research decision).

2. `GET /documents` (list_documents):
   - After parsing scope/scope_id params, call `perm_service.get_scope_filter_for_list(current_user, scope, scope_id)`.
   - If False, raise `HTTPException(status_code=403, detail="Access denied to this scope")`.
   - For personal scope, also hard-check `scope_id == current_user.id` (belt-and-suspenders for PERM-05).

3. `POST /documents` (create_document):
   - After validating scope, call `perm_service.can_create_in_scope(current_user, body.scope, scope_id)` where scope_id is derived from body (application_id, project_id, or user_id).
   - If False, raise 403 with detail "You do not have permission to create documents in this scope".

4. `GET /documents/{document_id}` (get_document):
   - After fetching document, call `perm_service.can_read_document(current_user, document)`.
   - If False, raise 403. Keep existing 404 for not-found (return 404 before permission check if document is None).

5. `PUT /documents/{document_id}` (update_document):
   - After fetching document, call `perm_service.can_edit_document(current_user, document)`.
   - If False, raise 403 "You do not have permission to edit this document".

6. `DELETE /documents/{document_id}` (soft_delete_document):
   - After fetching document, call `perm_service.can_delete_document(current_user, document)`.
   - If False, raise 403.

7. `POST /documents/{document_id}/restore` (restore_document):
   - After fetching document, call `perm_service.can_edit_document(current_user, document)` (same as edit -- restoring is an edit action).
   - If False, raise 403.

8. `DELETE /documents/{document_id}/permanent` (permanent_delete_document):
   - After fetching document, call `perm_service.can_delete_document(current_user, document)`.
   - If False, raise 403.

9. `POST /documents/{document_id}/tags` (assign_tag):
   - After fetching document, call `perm_service.can_edit_document(current_user, document)` (tag assignment is an edit operation).
   - If False, raise 403.

10. `DELETE /documents/{document_id}/tags/{tag_id}` (unassign_tag):
    - After fetching document, call `perm_service.can_edit_document(current_user, document)`.
    - If False, raise 403.

**Important:** Always check 404 (document not found) BEFORE the permission check. This prevents leaking document existence through 403 vs 404 differences -- but since documents use UUIDs (not guessable), this is acceptable. The pattern should be: fetch -> 404 if null -> permission check -> 403 if denied -> proceed.

Add the import at the top of the file:
```python
from ..services.document_permission_service import DocumentPermissionService
```
  </action>
  <verify>
Run:
```bash
cd D:/FTX_CODE/pm-project/fastapi-backend
ruff check app/routers/documents.py
python -c "from app.routers.documents import router; print('Import OK')"
```

Grep to verify permission checks are present:
```bash
grep -c "DocumentPermissionService\|can_read_document\|can_edit_document\|can_delete_document\|can_create_in_scope\|get_scope_filter_for_list" app/routers/documents.py
```
Should return at least 10 matches (import + usage in each endpoint).
  </verify>
  <done>
Every document endpoint has a permission guard. List checks scope access. Create checks can_create_in_scope. Read checks can_read. Update/restore check can_edit. Delete checks can_delete. Tag assignment/removal checks can_edit. All raise 403 with descriptive messages on denial.
  </done>
</task>

<task type="auto">
  <name>Task 2: Guard folder and tag endpoints</name>
  <files>
    fastapi-backend/app/routers/document_folders.py
    fastapi-backend/app/routers/document_tags.py
  </files>
  <action>
**document_folders.py changes:**

Import `DocumentPermissionService` from the service module.

1. `GET /document-folders/tree` (get_folder_tree):
   - After parsing scope/scope_id, call `perm_service.get_scope_filter_for_list(current_user, scope, scope_id)`.
   - If False, raise 403. For personal scope, hard-check `scope_id == current_user.id`.

2. `POST /document-folders` (create_folder):
   - After validating scope, call `perm_service.can_create_in_scope(current_user, body.scope, scope_id)`.
   - If False, raise 403.

3. `PUT /document-folders/{folder_id}` (update_folder):
   - After fetching the folder, determine its scope from its FK fields (application_id, project_id, user_id -- same pattern as Document).
   - Call `perm_service.can_create_in_scope(current_user, scope, scope_id)` where scope/scope_id are derived from the folder's FK.
   - Note: Folders don't have a separate "can_edit_folder" -- use can_create_in_scope since folder management requires the same role as document creation in that scope (owner or editor).
   - If False, raise 403.

4. `DELETE /document-folders/{folder_id}` (delete_folder):
   - After fetching the folder, determine scope from FKs.
   - For application scope: only owner can delete folders (call `get_user_application_role`, check == "owner").
   - For project scope: only application owner can delete folders.
   - For personal scope: user_id == current_user.id.
   - Use a helper approach: create a temporary Document-like object or just inline the check since folders have the same FK pattern. Simplest: call `perm_service.can_create_in_scope()` for edit-level check, but for delete require owner. Since we don't have `can_delete_folder` on the service, add an inline check: for non-personal scopes, get the role and require "owner" for delete. For personal scope, check user_id == current_user.id.

**document_tags.py changes:**

Import `DocumentPermissionService`.

Tags have a scope: application_id (shared tags) or user_id (personal tags). See the DocumentTag model.

1. `GET /document-tags` (list_tags):
   - After parsing scope/scope_id, call `perm_service.get_scope_filter_for_list(current_user, scope, scope_id)`.
   - If False, raise 403.

2. `POST /document-tags` (create_tag):
   - Call `perm_service.can_create_in_scope(current_user, scope, scope_id)`.
   - If False, raise 403.

3. `PUT /document-tags/{tag_id}` (update_tag):
   - After fetching tag, determine scope from tag's application_id or user_id.
   - Call `perm_service.can_create_in_scope(current_user, scope, scope_id)`.
   - If False, raise 403.

4. `DELETE /document-tags/{tag_id}` (delete_tag):
   - After fetching tag, determine scope.
   - For application scope: only owner can delete tags. Inline check: get role, require "owner".
   - For personal scope: check user_id == current_user.id.

**Helper pattern for determining scope from model FKs** (use in both files):
```python
# Determine scope from model's FK fields
if folder.application_id:
    scope, scope_id = "application", folder.application_id
elif folder.project_id:
    scope, scope_id = "project", folder.project_id
elif folder.user_id:
    scope, scope_id = "personal", folder.user_id
```
  </action>
  <verify>
Run:
```bash
cd D:/FTX_CODE/pm-project/fastapi-backend
ruff check app/routers/document_folders.py app/routers/document_tags.py
python -c "from app.routers.document_folders import router; from app.routers.document_tags import router; print('Import OK')"
```

Grep for permission checks:
```bash
grep -c "DocumentPermissionService\|can_create_in_scope\|get_scope_filter_for_list\|403" app/routers/document_folders.py
grep -c "DocumentPermissionService\|can_create_in_scope\|get_scope_filter_for_list\|403" app/routers/document_tags.py
```
Both files should show multiple matches.
  </verify>
  <done>
All folder endpoints (tree, create, update, delete) have permission guards. All tag endpoints (list, create, update, delete) have permission guards. Folder and tag deletion restricted to owners for application scope. Personal scope enforces user_id == current_user.id throughout.
  </done>
</task>

</tasks>

<verification>
1. `ruff check app/routers/documents.py app/routers/document_folders.py app/routers/document_tags.py` passes
2. All three router files import DocumentPermissionService
3. `grep "403" app/routers/documents.py | wc -l` shows at least 8 permission-denied responses
4. `grep "403" app/routers/document_folders.py | wc -l` shows at least 3 permission-denied responses
5. `grep "403" app/routers/document_tags.py | wc -l` shows at least 3 permission-denied responses
6. Python import check succeeds for all three routers
</verification>

<success_criteria>
- Every document CRUD endpoint raises 403 for unauthorized access
- Every folder CRUD endpoint raises 403 for unauthorized access
- Every tag CRUD endpoint raises 403 for unauthorized access
- List endpoints check scope access before returning data
- Personal scope always hard-checks user_id == current_user.id
- All three files pass ruff lint
</success_criteria>

<output>
After completion, create `.planning/phases/08-permissions/08-02-SUMMARY.md`
</output>
