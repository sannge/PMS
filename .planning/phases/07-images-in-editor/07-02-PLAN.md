---
phase: 07-images-in-editor
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - electron-app/src/renderer/components/knowledge/document-editor.tsx
  - electron-app/src/renderer/components/knowledge/editor-toolbar.tsx
  - electron-app/src/renderer/components/knowledge/editor-types.ts
  - electron-app/src/renderer/components/knowledge/editor-styles.css
autonomous: true

must_haves:
  truths:
    - "User can paste an image from clipboard and it appears at the cursor position"
    - "User can drag-and-drop an image file into the editor and it inserts at the drop position"
    - "User can click an image upload button in the toolbar to insert an image"
    - "Images show a skeleton/placeholder animation while uploading"
    - "Images can be resized via the SE corner drag handle"
  artifacts:
    - path: "electron-app/src/renderer/components/knowledge/document-editor.tsx"
      provides: "editorProps with handlePaste and handleDrop for image upload"
      contains: "handlePaste"
    - path: "electron-app/src/renderer/components/knowledge/editor-toolbar.tsx"
      provides: "Image upload button in toolbar"
      contains: "ImageIcon"
    - path: "electron-app/src/renderer/components/knowledge/editor-types.ts"
      provides: "onImageUpload callback in EditorToolbarProps"
      contains: "onImageUpload"
    - path: "electron-app/src/renderer/components/knowledge/editor-styles.css"
      provides: "Skeleton pulse animation for uploading images"
      contains: "skeleton-pulse"
  key_links:
    - from: "document-editor.tsx"
      to: "use-image-upload.ts"
      via: "useImageUpload hook call"
      pattern: "useImageUpload"
    - from: "document-editor.tsx"
      to: "editor-toolbar.tsx"
      via: "onImageUpload prop"
      pattern: "onImageUpload"
    - from: "editor-toolbar.tsx"
      to: "hidden file input"
      via: "click handler triggers file input"
      pattern: "input.*type.*file"
---

<objective>
Wire image upload into the editor: paste/drop handlers via editorProps, toolbar image button, and skeleton loading animation.

Purpose: Completes the full image experience -- users can paste, drag-and-drop, or click to upload images with visual feedback during upload.
Output: Fully functional image insertion from all three input methods with loading placeholder.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-images-in-editor/07-RESEARCH.md
@.planning/phases/07-images-in-editor/07-01-SUMMARY.md

@electron-app/src/renderer/components/knowledge/document-editor.tsx
@electron-app/src/renderer/components/knowledge/editor-toolbar.tsx
@electron-app/src/renderer/components/knowledge/editor-types.ts
@electron-app/src/renderer/components/knowledge/editor-styles.css
@electron-app/src/renderer/components/knowledge/use-image-upload.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add editorProps paste/drop handlers and toolbar upload callback to DocumentEditor</name>
  <files>
    electron-app/src/renderer/components/knowledge/document-editor.tsx
    electron-app/src/renderer/components/knowledge/editor-types.ts
  </files>
  <action>
**1. Update `editor-types.ts`** -- add `onImageUpload` to `EditorToolbarProps`:
```typescript
export interface EditorToolbarProps {
  editor: Editor
  /** Callback to trigger image upload from toolbar button */
  onImageUpload?: () => void
}
```

Also add `documentId` awareness note to `DocumentEditorProps` (already has `documentId` -- no change needed).

**2. Update `document-editor.tsx`**:

**2a. Import useImageUpload:**
```typescript
import { useImageUpload } from './use-image-upload'
```

**2b. Call useImageUpload in DocumentEditor:**
```typescript
const { uploadImage } = useImageUpload(documentId ?? null)
```

**2c. Create image insertion helper** (shared by paste, drop, and toolbar). This helper:
- Inserts a placeholder image node with `data-uploading="true"` attribute and a small SVG skeleton as src
- Calls `uploadImage(file)`
- On success: finds the placeholder by traversing the doc and replaces its src with the real URL, removes `data-uploading`
- On failure: removes the placeholder node

Simpler approach (recommended): Insert the image immediately with an object URL (`URL.createObjectURL(file)`) as temporary src, and a custom `uploading` attribute set to `true`. After upload completes, update the src to the real URL and set `uploading` to `false`. This avoids complex placeholder node management.

Implementation:
```typescript
const insertImage = useCallback(async (file: File, editor: Editor, pos?: number) => {
  if (!file.type.startsWith('image/')) return

  // Create temporary object URL for immediate display
  const tempUrl = URL.createObjectURL(file)

  // Insert image node at position or selection
  const node = editor.state.schema.nodes.image?.create({
    src: tempUrl,
    alt: file.name,
    'data-uploading': 'true',
  })
  if (!node) return

  if (pos !== undefined) {
    const tr = editor.state.tr.insert(pos, node)
    editor.view.dispatch(tr)
  } else {
    const tr = editor.state.tr.replaceSelectionWith(node)
    editor.view.dispatch(tr)
  }

  // Upload to MinIO
  try {
    const url = await uploadImage(file)
    if (url) {
      // Find and update the image node with temp URL
      editor.state.doc.descendants((n, p) => {
        if (n.type.name === 'image' && n.attrs.src === tempUrl) {
          const tr = editor.view.state.tr.setNodeMarkup(p, undefined, {
            ...n.attrs,
            src: url,
            'data-uploading': null,
          })
          editor.view.dispatch(tr)
          return false // stop traversal
        }
      })
    }
  } catch {
    // Remove placeholder on failure -- find by tempUrl and delete
    editor.state.doc.descendants((n, p) => {
      if (n.type.name === 'image' && n.attrs.src === tempUrl) {
        const tr = editor.view.state.tr.delete(p, p + n.nodeSize)
        editor.view.dispatch(tr)
        return false
      }
    })
  } finally {
    URL.revokeObjectURL(tempUrl)
  }
}, [uploadImage])
```

**2d. Add editorProps to useEditor call** with `handlePaste` and `handleDrop`:

```typescript
editorProps: {
  handlePaste(view, event) {
    const items = Array.from(event.clipboardData?.items || [])
    for (const item of items) {
      if (item.type.startsWith('image/')) {
        event.preventDefault()
        const file = item.getAsFile()
        if (file && editor) {
          insertImage(file, editor)
        }
        return true
      }
    }
    return false
  },
  handleDrop(view, event) {
    const files = Array.from(event.dataTransfer?.files || [])
    const imageFile = files.find(f => f.type.startsWith('image/'))
    if (imageFile) {
      event.preventDefault()
      const pos = view.posAtCoords({ left: event.clientX, top: event.clientY })
      if (editor) {
        insertImage(imageFile, editor, pos?.pos)
      }
      return true
    }
    return false
  },
},
```

IMPORTANT: The `editorProps` must be passed into the `useEditor` config object alongside `extensions`, `content`, `editable`, and `onUpdate`. Since `editor` is not available yet when `useEditor` is being configured, the handlers need to use `view` parameter directly or use a ref pattern. Use `insertImageRef` pattern:
```typescript
const insertImageRef = useRef(insertImage)
useEffect(() => { insertImageRef.current = insertImage }, [insertImage])
```
Then in editorProps handlers call `insertImageRef.current(...)`.

**2e. Create toolbar upload callback:**
```typescript
const handleToolbarImageUpload = useCallback(() => {
  const input = document.createElement('input')
  input.type = 'file'
  input.accept = 'image/*'
  input.onchange = () => {
    const file = input.files?.[0]
    if (file && editor) {
      insertImage(file, editor)
    }
  }
  input.click()
}, [editor, insertImage])
```

**2f. Pass `onImageUpload` to EditorToolbar:**
```tsx
{effectiveEditable && <EditorToolbar editor={editor} onImageUpload={handleToolbarImageUpload} />}
```
  </action>
  <verify>
Run `cd D:/FTX_CODE/pm-project/electron-app && npx tsc --noEmit` -- typecheck passes.
  </verify>
  <done>
DocumentEditor wires useImageUpload hook, has paste/drop handlers in editorProps, and passes onImageUpload callback to toolbar. Typecheck passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add image upload toolbar button and skeleton loading CSS</name>
  <files>
    electron-app/src/renderer/components/knowledge/editor-toolbar.tsx
    electron-app/src/renderer/components/knowledge/editor-styles.css
  </files>
  <action>
**1. Add image upload button to `editor-toolbar.tsx`:**

Import `ImageIcon` from lucide-react:
```typescript
import { ..., ImageIcon } from 'lucide-react'
```
Note: Use `ImageIcon` (not `Image`) to avoid collision with the TipTap Image extension or HTML Image constructor.

Add the button after the link popover section (before the font family dropdown separator), with its own separator:

```tsx
<ToolbarSeparator />

{/* Image Upload */}
<ToolbarButton
  onClick={() => onImageUpload?.()}
  disabled={!onImageUpload}
  title="Insert image"
>
  <ImageIcon className="h-4 w-4" />
</ToolbarButton>
```

Update `EditorToolbar` function signature to accept `onImageUpload` from props:
```typescript
export function EditorToolbar({ editor, onImageUpload }: EditorToolbarProps) {
```

**2. Add skeleton/placeholder CSS to `editor-styles.css`:**

Add a new section at the bottom:

```css
/* ============================================================================
   Image Upload Placeholder (Skeleton Animation)
   ============================================================================ */

.ProseMirror img[data-uploading="true"] {
  min-height: 100px;
  min-width: 200px;
  background: linear-gradient(
    90deg,
    hsl(var(--muted)) 25%,
    hsl(var(--muted-foreground) / 0.1) 50%,
    hsl(var(--muted)) 75%
  );
  background-size: 200% 100%;
  animation: skeleton-pulse 1.5s ease-in-out infinite;
  border-radius: 0.375rem;
}

@keyframes skeleton-pulse {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}
```

Also add general image styles:

```css
/* ============================================================================
   Image Styles
   ============================================================================ */

.ProseMirror img {
  max-width: 100%;
  height: auto;
  border-radius: 0.375rem;
}
```
  </action>
  <verify>
Run `cd D:/FTX_CODE/pm-project/electron-app && npx tsc --noEmit` -- typecheck passes. Visually confirm toolbar has ImageIcon button after link section.
  </verify>
  <done>
Toolbar has image upload button with ImageIcon. Skeleton CSS animation shows pulsing placeholder while images upload. General image styles applied.
  </done>
</task>

</tasks>

<verification>
1. `cd D:/FTX_CODE/pm-project/electron-app && npx tsc --noEmit` -- no type errors
2. `cd D:/FTX_CODE/pm-project/fastapi-backend && python -m pytest tests/test_content_converter.py -v` -- all tests pass (from Plan 01)
3. Grep `handlePaste` in document-editor.tsx confirms paste handler wired
4. Grep `handleDrop` in document-editor.tsx confirms drop handler wired
5. Grep `ImageIcon` in editor-toolbar.tsx confirms toolbar button exists
6. Grep `skeleton-pulse` in editor-styles.css confirms animation defined
7. Grep `onImageUpload` in editor-types.ts confirms prop type exists
</verification>

<success_criteria>
- Paste handler intercepts clipboard image items and uploads to MinIO
- Drop handler intercepts dragged image files and inserts at drop position
- Toolbar image button opens file picker and inserts selected image
- Skeleton animation shows during upload (CSS keyframe + data-uploading attribute)
- All three methods show immediate visual feedback (object URL placeholder)
- Typecheck passes with no new errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-images-in-editor/07-02-SUMMARY.md`
</output>
