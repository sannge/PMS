---
phase: 07-images-in-editor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fastapi-backend/app/routers/document_images.py
  - fastapi-backend/app/main.py
  - electron-app/src/renderer/components/knowledge/editor/image-upload.ts
  - electron-app/src/renderer/components/knowledge/editor/extensions/resizable-image.ts
  - electron-app/src/renderer/components/knowledge/editor-extensions.ts
  - electron-app/src/renderer/components/knowledge/document-editor.tsx
  - electron-app/src/renderer/components/knowledge/editor-toolbar.tsx
  - electron-app/src/renderer/components/knowledge/editor-types.ts
  - electron-app/package.json
autonomous: true

must_haves:
  truths:
    - "User can paste an image from clipboard and it appears at the cursor position"
    - "User can drag-and-drop an image file into the editor and it appears in the document"
    - "User can click an upload button in the toolbar to insert an image via file picker"
    - "Images are uploaded to MinIO and referenced by URL in the document JSON"
  artifacts:
    - path: "fastapi-backend/app/routers/document_images.py"
      provides: "POST /api/documents/images/upload endpoint"
      contains: "upload_document_image"
    - path: "electron-app/src/renderer/components/knowledge/editor/image-upload.ts"
      provides: "Frontend upload helper function"
      contains: "uploadDocumentImage"
    - path: "electron-app/src/renderer/components/knowledge/editor/extensions/resizable-image.ts"
      provides: "Custom TipTap image extension with width/height attributes"
      contains: "ResizableImage"
  key_links:
    - from: "editor-toolbar.tsx"
      to: "image-upload.ts"
      via: "toolbar button triggers file picker and calls uploadDocumentImage"
      pattern: "uploadDocumentImage"
    - from: "editor/extensions/resizable-image.ts"
      to: "@tiptap/extension-image"
      via: "Image.extend with width/height attributes"
      pattern: "Image\\.extend"
    - from: "image-upload.ts"
      to: "/api/documents/images/upload"
      via: "fetch POST with FormData"
      pattern: "fetch.*documents/images/upload"
---

<objective>
Add document image upload endpoint and wire TipTap editor to support image paste, drag-and-drop, and toolbar upload button. Images are stored in MinIO and referenced by URL.

Purpose: Users need to add images to their documents. This plan delivers the complete upload pipeline (backend endpoint + frontend upload helper) and integrates paste/drop/button insertion into the editor.
Output: Working image insertion via paste, drop, and toolbar button. Backend endpoint storing images in MinIO.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-images-in-editor/07-RESEARCH.md

# Key existing files to reference
@fastapi-backend/app/services/minio_service.py
@fastapi-backend/app/routers/files.py
@fastapi-backend/app/main.py
@electron-app/src/renderer/components/knowledge/editor-extensions.ts
@electron-app/src/renderer/components/knowledge/document-editor.tsx
@electron-app/src/renderer/components/knowledge/editor-toolbar.tsx
@electron-app/src/renderer/components/knowledge/editor-types.ts
@electron-app/src/renderer/hooks/use-attachments.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend image upload endpoint and frontend upload helper</name>
  <files>
    fastapi-backend/app/routers/document_images.py
    fastapi-backend/app/main.py
    electron-app/src/renderer/components/knowledge/editor/image-upload.ts
  </files>
  <action>
**Backend: Create `fastapi-backend/app/routers/document_images.py`**

Create a new router file following the pattern in `routers/files.py`. The router has prefix `/documents/images` and tag `document-images`.

Single endpoint: `POST /upload` accepting:
- `file: UploadFile = File(...)` -- the image file
- `document_id: UUID = Query(...)` -- the document this image belongs to
- `current_user: User = Depends(get_current_user)` -- auth
- `minio: MinIOService = Depends(get_minio_service)` -- storage

Logic:
1. Validate `file.content_type` is in `{"image/jpeg", "image/png", "image/gif", "image/webp", "image/svg+xml"}`. Return 400 if not.
2. Read file content. Check size <= 10MB (10 * 1024 * 1024). Return 413 if over.
3. Generate object name via `minio.generate_object_name("document", str(document_id), file.filename or "image.png")`.
4. Upload via `minio.upload_bytes(MinIOService.IMAGES_BUCKET, object_name, content, file.content_type)`.
5. Generate presigned download URL via `minio.get_presigned_download_url(MinIOService.IMAGES_BUCKET, object_name)`.
6. Return JSON: `{"url": download_url, "object_name": object_name, "file_name": file.filename, "file_size": len(content), "content_type": file.content_type}`.

Wrap MinIO calls in try/except for `MinIOServiceError`, return 500 on failure.

**Register router in `main.py`:**
Import as `document_images_router` and add `app.include_router(document_images_router, prefix="/api", tags=["document-images"])` alongside the other document routers.

**Frontend: Create `electron-app/src/renderer/components/knowledge/editor/image-upload.ts`**

Create directory `electron-app/src/renderer/components/knowledge/editor/` if needed.

Export an async function `uploadDocumentImage(file: File, documentId: string, token: string): Promise<{ url: string; objectName: string }>` that:
1. Creates a FormData, appends `file`.
2. Calls `fetch` to `${import.meta.env.VITE_API_URL || 'http://localhost:8001'}/api/documents/images/upload?document_id=${documentId}` with method POST, Authorization header `Bearer ${token}`, body formData.
3. On non-ok response, parses error JSON and throws.
4. Returns `{ url: data.url, objectName: data.object_name }`.

This follows the exact same pattern as the file upload in `use-attachments.ts` (lines 350-377).
  </action>
  <verify>
Run `cd D:/FTX_CODE/pm-project/electron-app && npx tsc --noEmit` to verify TypeScript compiles.
Run `cd D:/FTX_CODE/pm-project/fastapi-backend && python -c "from app.routers.document_images import router; print('OK')"` to verify the router loads.
  </verify>
  <done>
Backend endpoint at POST /api/documents/images/upload accepts image file + document_id, stores in MinIO pm-images bucket, returns presigned URL. Frontend helper function calls this endpoint with FormData.
  </done>
</task>

<task type="auto">
  <name>Task 2: TipTap image extension with paste/drop/upload integration</name>
  <files>
    electron-app/src/renderer/components/knowledge/editor/extensions/resizable-image.ts
    electron-app/src/renderer/components/knowledge/editor-extensions.ts
    electron-app/src/renderer/components/knowledge/document-editor.tsx
    electron-app/src/renderer/components/knowledge/editor-toolbar.tsx
    electron-app/src/renderer/components/knowledge/editor-types.ts
    electron-app/package.json
  </files>
  <action>
**Install package:**
Run `cd electron-app && npm install @tiptap/extension-file-handler`.

**Create `editor/extensions/resizable-image.ts`:**

Create a custom TipTap extension extending `@tiptap/extension-image`:
```typescript
import Image from '@tiptap/extension-image'

export const ResizableImage = Image.extend({
  name: 'image',  // Keep the same name to replace the default
  addAttributes() {
    return {
      ...this.parent?.(),
      width: {
        default: null,
        renderHTML: (attrs) => attrs.width ? { width: attrs.width } : {},
        parseHTML: (el) => el.getAttribute('width'),
      },
      height: {
        default: null,
        renderHTML: (attrs) => attrs.height ? { height: attrs.height } : {},
        parseHTML: (el) => el.getAttribute('height'),
      },
      'data-loading': {
        default: null,
        renderHTML: (attrs) => attrs['data-loading'] ? { 'data-loading': attrs['data-loading'] } : {},
        parseHTML: (el) => el.getAttribute('data-loading'),
      },
      'data-minio-key': {
        default: null,
        renderHTML: (attrs) => attrs['data-minio-key'] ? { 'data-minio-key': attrs['data-minio-key'] } : {},
        parseHTML: (el) => el.getAttribute('data-minio-key'),
      },
    }
  },
})
```

This adds width/height (for resize in Plan 07-02), data-loading (for placeholder animation in Plan 07-02), and data-minio-key (for URL refresh). No NodeView yet -- that comes in Plan 07-02.

**Update `editor-extensions.ts`:**

Import `ResizableImage` from `./editor/extensions/resizable-image`. Import `FileHandler` from `@tiptap/extension-file-handler`.

The `createDocumentExtensions` function signature changes to accept an optional `onImageUpload` callback:
```typescript
export function createDocumentExtensions(options?: {
  placeholder?: string
  onImageUpload?: (file: File) => Promise<{ url: string; objectName: string }>
})
```

Add `ResizableImage` to the extensions array (do NOT add the base `Image` from starter-kit -- it's not included since StarterKit doesn't include Image).

Add `FileHandler.configure({...})` to the extensions array:
- `allowedMimeTypes`: `['image/jpeg', 'image/png', 'image/gif', 'image/webp']`
- `onPaste`: `(currentEditor, files, htmlContent) => { if (htmlContent) return; files.forEach(file => handleImageInsert(currentEditor, file, options?.onImageUpload)); }`
- `onDrop`: `(currentEditor, files, pos) => { files.forEach(file => handleImageInsert(currentEditor, file, options?.onImageUpload, pos)); }`

Add a helper function (inside the file, not exported) called `handleImageInsert`:
```typescript
function handleImageInsert(
  editor: Editor,
  file: File,
  onImageUpload?: (file: File) => Promise<{ url: string; objectName: string }>,
  pos?: number,
) {
  if (!onImageUpload) {
    // Fallback: insert as object URL (no server upload)
    const url = URL.createObjectURL(file)
    const insertPos = pos ?? editor.state.selection.anchor
    editor.chain().focus().insertContentAt(insertPos, {
      type: 'image',
      attrs: { src: url, alt: file.name },
    }).run()
    return
  }

  // Insert placeholder with temporary object URL
  const tempUrl = URL.createObjectURL(file)
  const insertPos = pos ?? editor.state.selection.anchor
  editor.chain().focus().insertContentAt(insertPos, {
    type: 'image',
    attrs: { src: tempUrl, alt: file.name, 'data-loading': 'true' },
  }).run()

  // Upload in background, then swap URL
  onImageUpload(file)
    .then(({ url, objectName }) => {
      // Find the placeholder image and update its src
      const { doc } = editor.state
      doc.descendants((node, nodePos) => {
        if (node.type.name === 'image' && node.attrs.src === tempUrl) {
          editor.chain()
            .focus()
            .command(({ tr }) => {
              tr.setNodeMarkup(nodePos, undefined, {
                ...node.attrs,
                src: url,
                'data-loading': null,
                'data-minio-key': objectName,
              })
              return true
            })
            .run()
        }
      })
    })
    .catch(err => {
      console.error('Image upload failed:', err)
      // Remove the placeholder on failure
      const { doc } = editor.state
      doc.descendants((node, nodePos) => {
        if (node.type.name === 'image' && node.attrs.src === tempUrl) {
          editor.chain()
            .focus()
            .command(({ tr }) => {
              tr.delete(nodePos, nodePos + node.nodeSize)
              return true
            })
            .run()
        }
      })
    })
    .finally(() => {
      URL.revokeObjectURL(tempUrl)
    })
}
```

Import `type { Editor }` from `@tiptap/core` at the top.

**Update `editor-types.ts`:**

Add `onImageUpload` to `DocumentEditorProps`:
```typescript
/** Callback for uploading an image file. Returns the URL and MinIO object name. */
onImageUpload?: (file: File) => Promise<{ url: string; objectName: string }>
```

**Update `document-editor.tsx`:**

1. Accept `onImageUpload` from props (destructure it).
2. Pass it to `createDocumentExtensions({ placeholder, onImageUpload })`.
3. Add an `insertImageFromToolbar` callback: opens a hidden `<input type="file" accept="image/*">`, on change calls `handleToolbarImageUpload` which gets the file, calls `handleImageInsert` via the editor. Actually, simpler approach: create a ref to a hidden file input, and expose an `onInsertImage` function to the toolbar.

Better approach for toolbar integration:
- Add a hidden `<input ref={fileInputRef} type="file" accept="image/*" style={{ display: 'none' }} onChange={handleFileSelect} />` in the component JSX.
- Create a `handleInsertImage` callback that triggers `fileInputRef.current?.click()`.
- In `handleFileSelect`, get the file, and if `onImageUpload` is provided, call `handleImageInsert` (import it or duplicate the logic). Actually, since `handleImageInsert` is not exported, the simpler approach is: get the file, call `onImageUpload(file)` to get the URL, then `editor.chain().focus().setImage({ src: url, 'data-minio-key': objectName }).run()`.
- Pass `handleInsertImage` to `EditorToolbar` as a new prop.

**Update `editor-toolbar.tsx`:**

Add `onInsertImage?: () => void` to `EditorToolbarProps`.

Add an image button in the toolbar (after the existing last button group, before the end). Use Lucide `ImagePlus` icon. The button calls `onInsertImage?.()` on click. Give it `title="Insert image"` and `aria-label="Insert image"`.

Import `ImagePlus` from `lucide-react`.
  </action>
  <verify>
Run `cd D:/FTX_CODE/pm-project/electron-app && npx tsc --noEmit` to confirm TypeScript compiles with zero errors.
Visually confirm the image button appears in the toolbar by running `npm run dev` and navigating to the Notes screen.
  </verify>
  <done>
Editor supports image paste, drag-and-drop, and toolbar upload button. Images upload to MinIO via the backend endpoint and appear in the document. Placeholder is shown during upload, replaced with permanent URL on success, removed on failure.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in electron-app
2. `python -c "from app.routers.document_images import router"` passes in fastapi-backend
3. Image toolbar button visible in editor
4. Paste/drop/upload triggers the upload flow (placeholder -> permanent URL)
</verification>

<success_criteria>
- Backend POST /api/documents/images/upload endpoint validates image type and size, stores in MinIO pm-images bucket, returns presigned URL
- Frontend editor accepts image paste from clipboard, drag-and-drop files, and toolbar button upload
- Images inserted via any method show a placeholder during upload and are replaced with the permanent URL
- Document JSON stores image src URL and data-minio-key attribute for future URL refresh
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-images-in-editor/07-01-SUMMARY.md`
</output>
