---
phase: 04-auto-save-content-pipeline
plan: 04
type: tdd
wave: 1
depends_on: []
files_modified:
  - fastapi-backend/app/services/content_converter.py
  - fastapi-backend/tests/test_content_converter.py
  - fastapi-backend/app/services/document_service.py
autonomous: true

must_haves:
  truths:
    - "Server generates correct Markdown from TipTap JSON for all node types present in editor-extensions.ts"
    - "Server generates plain text from TipTap JSON (all formatting stripped)"
    - "Content pipeline runs on every document save (PUT /documents/{id}/content stores all three formats)"
    - "Nested lists, tables, code blocks with language, and underline marks convert correctly"
    - "Code blocks with defaultLanguage 'plaintext' render as bare ``` fences (no language annotation)"
    - "Test suite covers all node/mark types with 30+ test cases"
  artifacts:
    - path: "fastapi-backend/app/services/content_converter.py"
      provides: "tiptap_json_to_markdown and tiptap_json_to_plain_text functions"
      exports: ["tiptap_json_to_markdown", "tiptap_json_to_plain_text"]
    - path: "fastapi-backend/tests/test_content_converter.py"
      provides: "Comprehensive test suite for content converter with 30+ test cases"
      contains: "test_"
    - path: "fastapi-backend/app/services/document_service.py"
      provides: "save_document_content calls converter pipeline"
      contains: "tiptap_json_to_markdown"
  key_links:
    - from: "fastapi-backend/app/services/document_service.py"
      to: "fastapi-backend/app/services/content_converter.py"
      via: "import and call on save"
      pattern: "from.*content_converter.*import"
    - from: "fastapi-backend/tests/test_content_converter.py"
      to: "fastapi-backend/app/services/content_converter.py"
      via: "test imports"
      pattern: "from.*content_converter.*import"
---

<objective>
Build a custom Python TipTap JSON-to-Markdown and JSON-to-plain-text converter using TDD (Red-Green-Refactor), then wire it into the document save pipeline so all three content formats are stored on every save.

Purpose: Markdown powers the future AI knowledge agent. Plain text powers full-text search (Phase 9). The converter must handle all node types from the existing editor-extensions.ts (the knowledge base editor extensions).
Output: content_converter.py with comprehensive test coverage (30+ test cases), wired into save_document_content.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-auto-save-content-pipeline/04-RESEARCH.md
@fastapi-backend/app/services/document_service.py
@fastapi-backend/app/models/document.py
@electron-app/src/renderer/components/knowledge/editor-extensions.ts
</context>

<feature>
  <name>TipTap JSON to Markdown and Plain Text Converter</name>
  <files>
    fastapi-backend/app/services/content_converter.py
    fastapi-backend/tests/test_content_converter.py
    fastapi-backend/app/services/document_service.py
  </files>
  <behavior>
    The converter is a recursive tree walker that processes ProseMirror JSON (TipTap's internal format).

    **Node types to handle (from editor-extensions.ts -- the knowledge base editor):**
    - Block: doc, paragraph, heading (levels 1-6), bulletList, orderedList, listItem, taskList, taskItem, codeBlock (with language attr, defaultLanguage: 'plaintext'), blockquote, table, tableRow, tableCell, tableHeader, horizontalRule
    - Inline: text, hardBreak
    - Marks: bold, italic, underline, strike, code, link (href attr), textStyle (fontSize/fontFamily/color), highlight (color)

    NOTE: There is NO image extension in the knowledge base editor. Do NOT implement image conversion.
    NOTE: Headings support levels 1-6, not just 1-3.
    NOTE: taskList and taskItem ARE present in editor-extensions.ts and MUST be handled.

    **Markdown conversion rules:**
    - paragraph -> text + "\n\n"
    - heading -> "#" * level + " " + text + "\n\n" (levels 1-6)
    - bulletList/listItem -> "- " prefix, nested lists increase indent by 2 spaces
    - orderedList/listItem -> "N. " prefix, same nesting
    - taskList/taskItem -> "- [x] " or "- [ ] " based on checked attr
    - codeBlock -> "```lang\ncode\n```\n\n" BUT if language is 'plaintext' or empty/null, render as bare "```\ncode\n```\n\n" (no language annotation). This is critical because CodeBlockLowlight is configured with `defaultLanguage: 'plaintext'` -- every code block without explicit language would otherwise render as "```plaintext" which is wrong.
    - blockquote -> "> " prefix on each line
    - table -> Markdown table with header row and separator
    - horizontalRule -> "---\n\n"
    - bold -> "**text**"
    - italic -> "_text_"
    - strike -> "~~text~~"
    - code (inline) -> "`text`"
    - link -> "[text](href)"
    - underline -> "<u>text</u>" (no Markdown equivalent)
    - textStyle, highlight -> skip (presentation-only, no Markdown equivalent)
    - hardBreak -> "  \n" (two spaces + newline)
    - Unknown nodes -> render children recursively (graceful degradation)

    **Plain text conversion rules:**
    - Extract all text content recursively
    - Add newlines after block-level nodes
    - Strip all marks/formatting
    - hardBreak -> "\n"

    **Test cases (input -> expected output) -- target 30+ test cases:**
    - Empty doc -> ""
    - Single paragraph with text -> "Hello world\n\n"
    - Heading level 1 -> "# My Heading\n\n"
    - Heading level 2 -> "## My Heading\n\n"
    - Heading level 3 -> "### My Heading\n\n"
    - Heading level 6 -> "###### My Heading\n\n"
    - Bold + italic text -> "**bold** _italic_\n\n"
    - Nested bullet list (2 levels) -> proper indentation
    - Ordered list -> "1. first\n2. second\n"
    - Task list with checked/unchecked -> "- [x] done\n- [ ] pending\n"
    - Code block with language -> "```python\nprint('hi')\n```\n\n"
    - Code block with 'plaintext' language -> "```\nsome code\n```\n\n" (NO language annotation)
    - Code block with no/null language -> "```\nsome code\n```\n\n" (NO language annotation)
    - Blockquote -> "> quoted text\n\n"
    - Table (2x2 with header) -> "| H1 | H2 |\n| --- | --- |\n| A | B |\n"
    - Link -> "[text](url)"
    - Underline -> "<u>underlined</u>"
    - Horizontal rule -> "---\n\n"
    - Hard break -> "  \n"
    - Combined marks (bold + italic + link) -> proper nesting
    - Strike text -> "~~struck~~"
    - Inline code -> "`code`"
    - Unknown node type -> children rendered (no crash)
    - Deeply nested list (3 levels) -> proper indentation
    - Multiple paragraphs -> proper spacing
    - Blockquote with multiple lines -> each line prefixed
    - Task item checked true -> "- [x] "
    - Task item checked false -> "- [ ] "
    - Plain text: paragraph -> "Hello world\n"
    - Plain text: heading -> "My Heading\n"
    - Plain text: all marks stripped
    - Plain text: code block content preserved without fences
    - Plain text: task list items as text only
  </behavior>
  <implementation>
    **RED phase:** Write test_content_converter.py with all test cases above (30+ tests). Tests import tiptap_json_to_markdown and tiptap_json_to_plain_text from content_converter. Each test constructs a TipTap JSON dict and asserts expected output. Tests MUST fail initially (content_converter.py doesn't exist yet).

    **GREEN phase:** Implement content_converter.py following the code example in 04-RESEARCH.md (Pattern 4). The research provides a complete ~400 LOC implementation. Key functions:
    - `tiptap_json_to_markdown(doc: dict[str, Any]) -> str`
    - `tiptap_json_to_plain_text(doc: dict[str, Any]) -> str`
    - Internal helpers: `_md_nodes`, `_md_inline`, `_md_list_item`, `_md_table`, `_extract_text_from_nodes`

    Use `_MARK_WRAPPERS` dict for simple mark wrapping. Handle link and underline as special cases. textStyle and highlight marks are presentation-only -- skip in Markdown output.

    IMPORTANT: In the codeBlock handler, check the language attribute. If language is 'plaintext', empty string, or None, render the fence as bare "```" with no language suffix. Only add the language suffix for non-plaintext explicit languages.

    **REFACTOR phase:** Clean up if needed. Ensure all tests pass.

    **Wire into save pipeline:** Update `save_document_content` in document_service.py (created in Plan 01) to:
    1. Import `tiptap_json_to_markdown` and `tiptap_json_to_plain_text` from content_converter
    2. Replace the placeholder empty strings with actual converter calls:
       - `doc.content_markdown = tiptap_json_to_markdown(content_dict)`
       - `doc.content_plain = tiptap_json_to_plain_text(content_dict)`
    3. Parse content_json to dict before passing to converters: `content_dict = json.loads(content_json)`
  </implementation>
</feature>

<verification>
1. `pytest tests/test_content_converter.py -v` passes all tests (30+ test cases)
2. Tests cover: empty doc, paragraph, heading (levels 1-6), bold/italic/strike/code marks, link, underline, bullet list, ordered list, task list, nested lists, code block with language, code block with plaintext/no language (bare fences), blockquote, table, horizontal rule, hard break, combined marks, unknown nodes
3. Plain text tests: formatting stripped, block newlines preserved
4. `save_document_content` in document_service.py calls both converters
5. No new pip dependencies (uses only stdlib + existing Pydantic)
</verification>

<success_criteria>
- All 30+ test cases pass in test_content_converter.py
- tiptap_json_to_markdown handles all node types from editor-extensions.ts (headings 1-6, taskList/taskItem, codeBlock with plaintext handling)
- tiptap_json_to_plain_text strips all formatting and returns clean text
- Code blocks with 'plaintext' or no language render as bare ``` fences (no "```plaintext")
- Unknown node types are handled gracefully (render children, no crash)
- save_document_content stores content_json, content_markdown, and content_plain on every save
- No external Python dependencies needed
</success_criteria>

<output>
After completion, create `.planning/phases/04-auto-save-content-pipeline/04-04-SUMMARY.md`
</output>
