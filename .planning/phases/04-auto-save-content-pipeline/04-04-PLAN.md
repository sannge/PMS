---
phase: 04-auto-save-content-pipeline
plan: 04
type: tdd
wave: 1
depends_on: []
files_modified:
  - fastapi-backend/app/services/content_converter.py
  - fastapi-backend/tests/test_content_converter.py
  - fastapi-backend/app/services/document_service.py
autonomous: true

must_haves:
  truths:
    - "Server generates correct Markdown from TipTap JSON for all 16 block types and 8 mark types"
    - "Server generates plain text from TipTap JSON (all formatting stripped)"
    - "Content pipeline runs on every document save (PUT /documents/{id}/content stores all three formats)"
    - "Nested lists, tables, code blocks with language, and underline marks convert correctly"
  artifacts:
    - path: "fastapi-backend/app/services/content_converter.py"
      provides: "tiptap_json_to_markdown and tiptap_json_to_plain_text functions"
      exports: ["tiptap_json_to_markdown", "tiptap_json_to_plain_text"]
    - path: "fastapi-backend/tests/test_content_converter.py"
      provides: "Comprehensive test suite for content converter"
      contains: "test_"
    - path: "fastapi-backend/app/services/document_service.py"
      provides: "save_document_content calls converter pipeline"
      contains: "tiptap_json_to_markdown"
  key_links:
    - from: "fastapi-backend/app/services/document_service.py"
      to: "fastapi-backend/app/services/content_converter.py"
      via: "import and call on save"
      pattern: "from.*content_converter.*import"
    - from: "fastapi-backend/tests/test_content_converter.py"
      to: "fastapi-backend/app/services/content_converter.py"
      via: "test imports"
      pattern: "from.*content_converter.*import"
---

<objective>
Build a custom Python TipTap JSON-to-Markdown and JSON-to-plain-text converter using TDD (Red-Green-Refactor), then wire it into the document save pipeline so all three content formats are stored on every save.

Purpose: Markdown powers the future AI knowledge agent. Plain text powers full-text search (Phase 9). The converter must handle all node types from the existing RichTextEditor.tsx extensions.
Output: content_converter.py with comprehensive test coverage, wired into save_document_content.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-auto-save-content-pipeline/04-RESEARCH.md
@fastapi-backend/app/services/document_service.py
@fastapi-backend/app/models/document.py
</context>

<feature>
  <name>TipTap JSON to Markdown and Plain Text Converter</name>
  <files>
    fastapi-backend/app/services/content_converter.py
    fastapi-backend/tests/test_content_converter.py
    fastapi-backend/app/services/document_service.py
  </files>
  <behavior>
    The converter is a recursive tree walker that processes ProseMirror JSON (TipTap's internal format).

    **Node types to handle (from RichTextEditor.tsx extensions):**
    - Block: doc, paragraph, heading (1-3), bulletList, orderedList, listItem, taskList, taskItem, codeBlock (with language attr), blockquote, table, tableRow, tableCell, tableHeader, horizontalRule, image
    - Inline: text, hardBreak
    - Marks: bold, italic, underline, strike, code, link (href attr), textStyle (fontSize/fontFamily/color), highlight (color)

    **Markdown conversion rules:**
    - paragraph -> text + "\n\n"
    - heading -> "#" * level + " " + text + "\n\n"
    - bulletList/listItem -> "- " prefix, nested lists increase indent by 2 spaces
    - orderedList/listItem -> "N. " prefix, same nesting
    - taskList/taskItem -> "- [x] " or "- [ ] " based on checked attr
    - codeBlock -> "```lang\ncode\n```\n\n"
    - blockquote -> "> " prefix on each line
    - table -> Markdown table with header row and separator
    - horizontalRule -> "---\n\n"
    - image -> "![alt](src)\n\n"
    - bold -> "**text**"
    - italic -> "_text_"
    - strike -> "~~text~~"
    - code (inline) -> "`text`"
    - link -> "[text](href)"
    - underline -> "<u>text</u>" (no Markdown equivalent)
    - textStyle, highlight -> skip (presentation-only, no Markdown equivalent)
    - hardBreak -> "  \n" (two spaces + newline)
    - Unknown nodes -> render children recursively (graceful degradation)

    **Plain text conversion rules:**
    - Extract all text content recursively
    - Add newlines after block-level nodes
    - Strip all marks/formatting
    - hardBreak -> "\n"

    **Test cases (input -> expected output):**
    - Empty doc -> ""
    - Single paragraph with text -> "Hello world\n\n"
    - Heading level 2 -> "## My Heading\n\n"
    - Bold + italic text -> "**bold** _italic_\n\n"
    - Nested bullet list (2 levels) -> proper indentation
    - Ordered list -> "1. first\n2. second\n"
    - Task list with checked/unchecked -> "- [x] done\n- [ ] pending\n"
    - Code block with language -> "```python\nprint('hi')\n```\n\n"
    - Blockquote -> "> quoted text\n\n"
    - Table (2x2 with header) -> "| H1 | H2 |\n| --- | --- |\n| A | B |\n"
    - Link -> "[text](url)"
    - Image -> "![alt](src)\n\n"
    - Underline -> "<u>underlined</u>"
    - Horizontal rule -> "---\n\n"
    - Hard break -> "  \n"
    - Combined marks (bold + italic + link) -> proper nesting
    - Unknown node type -> children rendered (no crash)
    - Plain text: paragraph -> "Hello world\n"
    - Plain text: heading -> "My Heading\n"
    - Plain text: all marks stripped
  </behavior>
  <implementation>
    **RED phase:** Write test_content_converter.py with all test cases above. Tests import tiptap_json_to_markdown and tiptap_json_to_plain_text from content_converter. Each test constructs a TipTap JSON dict and asserts expected output. Tests MUST fail initially (content_converter.py doesn't exist yet).

    **GREEN phase:** Implement content_converter.py following the code example in 04-RESEARCH.md (Pattern 4). The research provides a complete ~400 LOC implementation. Key functions:
    - `tiptap_json_to_markdown(doc: dict[str, Any]) -> str`
    - `tiptap_json_to_plain_text(doc: dict[str, Any]) -> str`
    - Internal helpers: `_md_nodes`, `_md_inline`, `_md_list_item`, `_md_table`, `_extract_text_from_nodes`

    Use `_MARK_WRAPPERS` dict for simple mark wrapping. Handle link and underline as special cases. textStyle and highlight marks are presentation-only -- skip in Markdown output.

    **REFACTOR phase:** Clean up if needed. Ensure all tests pass.

    **Wire into save pipeline:** Update `save_document_content` in document_service.py (created in Plan 01) to:
    1. Import `tiptap_json_to_markdown` and `tiptap_json_to_plain_text` from content_converter
    2. Replace the placeholder empty strings with actual converter calls:
       - `doc.content_markdown = tiptap_json_to_markdown(content_dict)`
       - `doc.content_plain = tiptap_json_to_plain_text(content_dict)`
    3. Parse content_json to dict before passing to converters: `content_dict = json.loads(content_json)`
  </implementation>
</feature>

<verification>
1. `pytest tests/test_content_converter.py -v` passes all tests
2. Tests cover: empty doc, paragraph, heading, bold/italic/strike/code marks, link, underline, bullet list, ordered list, task list, nested lists, code block with language, blockquote, table, image, horizontal rule, hard break, combined marks, unknown nodes
3. Plain text tests: formatting stripped, block newlines preserved
4. `save_document_content` in document_service.py calls both converters
5. No new pip dependencies (uses only stdlib + existing Pydantic)
</verification>

<success_criteria>
- All test cases pass in test_content_converter.py
- tiptap_json_to_markdown handles all 16 block types and 8 mark types from RichTextEditor.tsx
- tiptap_json_to_plain_text strips all formatting and returns clean text
- Unknown node types are handled gracefully (render children, no crash)
- save_document_content stores content_json, content_markdown, and content_plain on every save
- No external Python dependencies needed
</success_criteria>

<output>
After completion, create `.planning/phases/04-auto-save-content-pipeline/04-04-SUMMARY.md`
</output>
