---
phase: 04-auto-save-content-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - electron-app/src/renderer/lib/draft-db.ts
  - electron-app/src/renderer/hooks/use-draft.ts
autonomous: true

must_haves:
  truths:
    - "Editor content is written to IndexedDB every ~2 seconds of inactivity as a crash recovery draft"
    - "When a document is opened, if an IndexedDB draft exists that is newer than the server version AND content differs, the user sees a restore-or-discard prompt"
    - "The IndexedDB draft is deleted immediately after a successful server save"
    - "Drafts older than 7 days are cleaned up on app startup"
    - "The draft store uses a separate IndexedDB database (pm-drafts-db), not the query cache database"
  artifacts:
    - path: "electron-app/src/renderer/lib/draft-db.ts"
      provides: "IndexedDB draft store with saveDraft, getDraft, deleteDraft, cleanupOldDrafts"
      exports: ["saveDraft", "getDraft", "deleteDraft", "cleanupOldDrafts"]
    - path: "electron-app/src/renderer/hooks/use-draft.ts"
      provides: "useDraft hook with auto-buffer, restore detection, and cleanup on save"
      exports: ["useDraft"]
  key_links:
    - from: "electron-app/src/renderer/hooks/use-draft.ts"
      to: "electron-app/src/renderer/lib/draft-db.ts"
      via: "saveDraft/getDraft/deleteDraft calls"
      pattern: "import.*draft-db"
    - from: "electron-app/src/renderer/hooks/use-draft.ts"
      to: "electron-app/src/renderer/hooks/use-auto-save.ts"
      via: "Coordinates with useAutoSave -- deletes draft on successful save"
      pattern: "deleteDraft|onSaveSuccess"
---

<objective>
Create IndexedDB draft persistence for crash recovery. Editor content is auto-buffered to a local IndexedDB store every ~2 seconds, and when reopening a document, the user is prompted to restore or discard if an unsaved draft exists.

Purpose: Force-quit, crashes, and OS kills cannot be intercepted. Frequent IndexedDB writes are the only reliable mechanism for crash recovery. This limits data loss to at most 2 seconds of typing.

Output: draft-db.ts IndexedDB store module and useDraft hook that auto-buffers, detects stale drafts on load, and cleans up after successful saves.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-auto-save-content-pipeline/04-RESEARCH.md
@.planning/phases/04-auto-save-content-pipeline/04-01-SUMMARY.md

Key reference files for IndexedDB patterns:
@electron-app/src/renderer/lib/query-cache-db.ts
@electron-app/src/renderer/lib/per-query-persister.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IndexedDB draft store (draft-db.ts)</name>
  <files>
    electron-app/src/renderer/lib/draft-db.ts (CREATE)
  </files>
  <action>
    Create `electron-app/src/renderer/lib/draft-db.ts` using the `idb` library (already installed, same as query-cache-db.ts).

    **DraftEntry interface:**
    ```typescript
    interface DraftEntry {
      documentId: string       // Primary key
      contentJson: string      // TipTap JSON string (editor content)
      title: string            // Document title at time of draft
      serverUpdatedAt: number  // Server's updated_at timestamp when document was loaded (for comparison)
      draftedAt: number        // Date.now() when this draft was written
    }
    ```

    **DraftDBSchema (extends DBSchema from idb):**
    - Object store: `drafts` with keyPath `documentId`
    - Index: `by-drafted-at` on `draftedAt` field (for cleanup queries)

    **Database:**
    - Name: `pm-drafts-db` (separate from `query-cache-db`)
    - Version: 1
    - Use singleton pattern for db connection (same as query-cache-db.ts)

    **Exported functions:**
    1. `saveDraft(draft: DraftEntry): Promise<void>` -- put (upsert) draft into store
    2. `getDraft(documentId: string): Promise<DraftEntry | undefined>` -- get draft by document ID
    3. `deleteDraft(documentId: string): Promise<void>` -- delete draft by document ID
    4. `cleanupOldDrafts(maxAgeDays?: number): Promise<number>` -- delete drafts older than maxAgeDays (default 7). Use index `by-drafted-at` to cursor through old entries. Return count of deleted drafts.

    Follow the patterns in query-cache-db.ts for:
    - Singleton db promise
    - Error handling (wrap in try/catch, log errors, don't throw to callers for non-critical operations)
    - TypeScript types using DBSchema interface from idb
  </action>
  <verify>
    - `cd electron-app && npx tsc --noEmit` passes
    - `cd electron-app && npm run lint` passes
    - File exports: saveDraft, getDraft, deleteDraft, cleanupOldDrafts
    - DraftEntry type is exported
  </verify>
  <done>
    IndexedDB draft store module created with typed schema, singleton connection, and four CRUD operations. Uses separate `pm-drafts-db` database with `by-drafted-at` index for cleanup queries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useDraft hook with auto-buffer, restore detection, and cleanup</name>
  <files>
    electron-app/src/renderer/hooks/use-draft.ts (CREATE)
  </files>
  <action>
    Create `electron-app/src/renderer/hooks/use-draft.ts` that coordinates draft persistence with the auto-save system.

    **Hook signature:**
    ```typescript
    interface UseDraftOptions {
      documentId: string
      editor: Editor | null         // TipTap editor instance
      serverUpdatedAt: number       // Server's updated_at as epoch ms
      enabled?: boolean             // Default true
    }

    interface DraftRestoreInfo {
      contentJson: string
      title: string
      draftedAt: number    // When draft was saved
    }

    interface UseDraftReturn {
      pendingRestore: DraftRestoreInfo | null  // Non-null if a draft needs user decision
      restoreDraft: () => void                 // Apply draft content to editor
      discardDraft: () => void                 // Delete draft, keep server content
      deleteDraftForDocument: () => Promise<void>  // For external callers (e.g., after successful save)
    }
    ```

    **Implementation details:**

    1. **Auto-buffer to IndexedDB (2s debounce):**
       - useEffect that listens to `editor.on('update', handler)`
       - On each update, reset a 2-second debounce timer
       - When timer fires, call `saveDraft({ documentId, contentJson: JSON.stringify(editor.getJSON()), title: (get from editor or document title), serverUpdatedAt, draftedAt: Date.now() })`
       - Cleanup: remove listener, clear timer

    2. **Restore detection on mount:**
       - useEffect (runs once when documentId/editor are ready) that calls `getDraft(documentId)`
       - If draft exists AND `draft.draftedAt > serverUpdatedAt` AND `draft.contentJson !== JSON.stringify(editor.getJSON())`:
         - Set `pendingRestore` state with draft info
       - If draft exists but conditions not met (draft is older or content matches):
         - Silently delete the draft (it's stale)

    3. **restoreDraft():**
       - Parse `pendingRestore.contentJson` and call `editor.commands.setContent(parsed)`
       - Clear `pendingRestore` state
       - The editor update will trigger the auto-save debounce naturally

    4. **discardDraft():**
       - Call `deleteDraft(documentId)`
       - Clear `pendingRestore` state

    5. **deleteDraftForDocument():**
       - Call `deleteDraft(documentId)` -- exposed for use by useAutoSave or parent components to clean up after successful server save

    6. **Startup cleanup:**
       - On first mount of the hook (use a module-level flag or useEffect with empty deps in App-level), call `cleanupOldDrafts(7)` to remove stale drafts. This should only run once per app session, not per document open.
       - Alternative: Export a standalone `initDraftCleanup()` function that can be called from App.tsx or the knowledge base page on mount.

    **Important coordination with useAutoSave (plan 04-01):**
    The parent component should call `deleteDraftForDocument()` in the `onSaveSuccess` callback of useAutoSave. This ensures drafts are cleaned up after every successful server save. The useDraft hook does NOT directly import or depend on useAutoSave -- they coordinate via the parent component's wiring.
  </action>
  <verify>
    - `cd electron-app && npx tsc --noEmit` passes
    - `cd electron-app && npm run lint` passes
    - File exports: useDraft, DraftRestoreInfo type, initDraftCleanup (if standalone)
    - Hook provides pendingRestore, restoreDraft, discardDraft, deleteDraftForDocument
  </verify>
  <done>
    useDraft hook created with 2-second debounced auto-buffer to IndexedDB, restore detection on document open (compares draft timestamp vs server timestamp and content), restore/discard actions, and draft cleanup after successful save. App-level startup cleanup removes drafts older than 7 days.
  </done>
</task>

</tasks>

<verification>
1. `cd electron-app && npx tsc --noEmit` passes
2. `cd electron-app && npm run lint` passes
3. draft-db.ts creates separate `pm-drafts-db` database (not reusing query-cache-db)
4. useDraft auto-buffers every ~2 seconds (not on every keystroke)
5. Restore prompt only shown when draft is newer than server AND content differs
6. Draft is deleted after successful server save
7. Old drafts (>7 days) cleaned up on startup
</verification>

<success_criteria>
- IndexedDB draft store is separate from query cache with proper typed schema
- Editor content auto-buffers to IndexedDB every ~2 seconds for crash recovery
- Restore prompt appears only when genuinely needed (newer draft, different content)
- Drafts cleaned up after save and on startup (7-day expiry)
- No TypeScript errors, no ESLint warnings
</success_criteria>

<output>
After completion, create `.planning/phases/04-auto-save-content-pipeline/04-02-SUMMARY.md`
</output>
