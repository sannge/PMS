---
phase: 04-auto-save-content-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fastapi-backend/app/routers/documents.py
  - fastapi-backend/app/schemas/document.py
  - fastapi-backend/app/services/document_service.py
  - electron-app/src/renderer/hooks/use-auto-save.ts
  - electron-app/src/renderer/hooks/use-queries.ts
autonomous: true

must_haves:
  truths:
    - "Document auto-saves after 10 seconds of typing inactivity"
    - "Redundant saves are skipped when content has not changed"
    - "Server returns 409 when client sends stale row_version"
  artifacts:
    - path: "fastapi-backend/app/routers/documents.py"
      provides: "PUT /api/documents/{id}/content endpoint with optimistic concurrency"
      contains: "save_document_content"
    - path: "fastapi-backend/app/schemas/document.py"
      provides: "DocumentContentUpdate request schema"
      contains: "DocumentContentUpdate"
    - path: "electron-app/src/renderer/hooks/use-auto-save.ts"
      provides: "useAutoSave hook with 10s debounce, dirty check, saveNow"
      exports: ["useAutoSave"]
    - path: "electron-app/src/renderer/hooks/use-queries.ts"
      provides: "useSaveDocumentContent mutation"
      contains: "useSaveDocumentContent"
  key_links:
    - from: "electron-app/src/renderer/hooks/use-auto-save.ts"
      to: "electron-app/src/renderer/hooks/use-queries.ts"
      via: "useSaveDocumentContent mutation"
      pattern: "useSaveDocumentContent"
    - from: "electron-app/src/renderer/hooks/use-queries.ts"
      to: "PUT /api/documents/{id}/content"
      via: "fetch call in mutation"
      pattern: "documents.*content"
    - from: "fastapi-backend/app/routers/documents.py"
      to: "fastapi-backend/app/services/document_service.py"
      via: "service call for content save"
      pattern: "save_document_content"
---

<objective>
Create the auto-save endpoint (backend) and debounced auto-save hook (frontend) that together deliver the core save loop: editor changes trigger a 10-second inactivity debounce, dirty check compares against last-saved JSON, and if changed, sends a PUT to the server with optimistic concurrency (row_version).

Purpose: This is the foundation that all other Phase 4 plans depend on -- the save endpoint powers the content pipeline (Plan 04), and the saveNow() function is reused by save-on-navigate/close (Plan 03).
Output: Working PUT endpoint with 409 conflict handling, and a useAutoSave hook that auto-saves after 10s of inactivity with dirty tracking.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-auto-save-content-pipeline/04-RESEARCH.md
@.planning/phases/01-migration-and-data-foundation/01-03-SUMMARY.md
@fastapi-backend/app/routers/documents.py
@fastapi-backend/app/schemas/document.py
@fastapi-backend/app/services/document_service.py
@fastapi-backend/app/models/document.py
@electron-app/src/renderer/hooks/use-queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend auto-save endpoint with optimistic concurrency</name>
  <files>
    fastapi-backend/app/schemas/document.py
    fastapi-backend/app/services/document_service.py
    fastapi-backend/app/routers/documents.py
  </files>
  <action>
    1. In `document.py` schemas, add a `DocumentContentUpdate` Pydantic model:
       - `content_json: str` (required -- the TipTap JSON string)
       - `row_version: int` (required -- for optimistic concurrency)

    2. In `document_service.py`, add a `save_document_content` function:
       - Takes `document_id: UUID`, `content_json: str`, `row_version: int`, `user_id: UUID`, `db: AsyncSession`
       - Loads the document, checks `doc.row_version == row_version` (raise 409 if mismatch)
       - Updates `doc.content_json = content_json` (the JSON editor format)
       - For now, set `doc.content_markdown = ""` and `doc.content_plain = ""` (Plan 04-04 adds the real converter)
       - Increments `doc.row_version += 1`
       - Sets `doc.updated_at = datetime.utcnow()` and `doc.updated_by = user_id`
       - Commits and returns the refreshed document
       - Check the existing Document model for actual column names -- the model was created in Phase 1 Plan 03. The content columns may be named `content_json`, `content_markdown`, `content_plain` or similar.

    3. In `documents.py` router, add a PUT endpoint:
       - Route: `PUT /documents/{document_id}/content`
       - Request body: `DocumentContentUpdate`
       - Auth: `current_user` dependency (same pattern as existing endpoints)
       - Calls `save_document_content` service function
       - Returns the updated document using existing `DocumentResponse` schema
       - On row_version mismatch, return HTTP 409 with message "Document was modified. Refresh to get latest version."
  </action>
  <verify>
    Run `cd D:/FTX_CODE/pm-project/fastapi-backend && python -c "from app.routers.documents import router; from app.schemas.document import DocumentContentUpdate; print('OK')"` to verify imports work.
    Grep for `save_document_content` in the router to confirm wiring.
  </verify>
  <done>
    PUT /documents/{id}/content endpoint exists, accepts content_json + row_version, returns 409 on version mismatch, updates document content and increments row_version on success.
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend useAutoSave hook with 10s debounce and dirty tracking</name>
  <files>
    electron-app/src/renderer/hooks/use-auto-save.ts
    electron-app/src/renderer/hooks/use-queries.ts
  </files>
  <action>
    1. In `use-queries.ts`, add a `useSaveDocumentContent` mutation hook:
       - Uses TanStack Query `useMutation` (follow existing mutation patterns in the file)
       - Sends PUT to `/api/documents/{documentId}/content` with body `{ content_json, row_version }`
       - Returns standard mutation result
       - Type the input as `{ documentId: string; content_json: string; row_version: number }`

    2. Create `use-auto-save.ts` with a `useAutoSave` hook:
       - Parameters: `documentId: string`, `editor: Editor | null` (TipTap editor instance), `rowVersion: number`
       - Internal state:
         - `lastSavedRef = useRef<string>('')` -- JSON string of last saved content (ref, not state, to avoid re-renders)
         - `timerRef = useRef<ReturnType<typeof setTimeout>>()` -- debounce timer
         - `savingRef = useRef(false)` -- mutex to prevent concurrent saves
         - `rowVersionRef = useRef(rowVersion)` -- tracks current server row_version (update on successful save response)
         - `[saveStatus, setSaveStatus] = useState<SaveStatus>({ state: 'idle' })` -- save status for UI
       - `SaveStatus` type: `{ state: 'idle' } | { state: 'saving' } | { state: 'saved'; at: number } | { state: 'error'; message: string }`
       - `isDirty()` callback: compares `JSON.stringify(editor.getJSON())` against `lastSavedRef.current`
       - `saveNow()` async callback:
         - Guard: return early if `!editor`, `!isDirty()`, or `savingRef.current` is true
         - Set `savingRef.current = true`
         - Cancel pending debounce timer (`clearTimeout(timerRef.current)`)
         - Get JSON from editor, stringify it
         - Set saveStatus to `{ state: 'saving' }`
         - Call `saveMutation.mutateAsync({ documentId, content_json: jsonStr, row_version: rowVersionRef.current })`
         - On success: update `lastSavedRef.current`, update `rowVersionRef.current` from response, set saveStatus `{ state: 'saved', at: Date.now() }`
         - On error: set saveStatus `{ state: 'error', message: 'Save failed' }`
         - Finally: set `savingRef.current = false`
       - Editor update listener (useEffect):
         - On `editor.on('update', handler)`, reset debounce: `clearTimeout(timerRef.current)`, set new 10_000ms timeout calling `saveNow()`
         - Cleanup: `editor.off('update', handler)`, clear timeout
       - Initialize `lastSavedRef.current` when editor first loads content (use a useEffect that runs when documentId changes to set the initial baseline)
       - Sync `rowVersionRef.current` when the `rowVersion` prop changes
       - Return: `{ isDirty, saveNow, saveStatus, setSaveStatus }`

    Export the `SaveStatus` type so Plan 03 can use it for the SaveStatus component.
  </action>
  <verify>
    Run `cd D:/FTX_CODE/pm-project/electron-app && npx tsc --noEmit --pretty 2>&1 | head -50` to check for type errors.
    Grep for `useAutoSave` export in `use-auto-save.ts`.
    Grep for `useSaveDocumentContent` export in `use-queries.ts`.
  </verify>
  <done>
    useAutoSave hook exists and exports saveNow() (for reuse by save-on-navigate/close), isDirty(), and saveStatus. useSaveDocumentContent mutation is available. Editor changes trigger a 10-second debounce that saves if content is dirty. Concurrent saves are prevented by savingRef mutex.
  </done>
</task>

</tasks>

<verification>
1. Backend: `DocumentContentUpdate` schema exists with `content_json` and `row_version` fields
2. Backend: PUT endpoint at `/documents/{document_id}/content` is registered in the router
3. Backend: Service function checks row_version and raises 409 on mismatch
4. Frontend: `useSaveDocumentContent` mutation exists in use-queries.ts
5. Frontend: `useAutoSave` hook exports `saveNow`, `isDirty`, `saveStatus`
6. Frontend: TypeScript compiles without errors
</verification>

<success_criteria>
- PUT /documents/{id}/content endpoint accepts content_json + row_version and returns updated document
- Server returns HTTP 409 when row_version doesn't match (optimistic concurrency)
- useAutoSave hook debounces saves at 10 seconds of editor inactivity
- isDirty() returns false when content matches last save (skipping redundant saves)
- saveNow() can be called imperatively (for use by save-on-navigate/close in Plan 03)
- No concurrent saves possible (savingRef mutex)
</success_criteria>

<output>
After completion, create `.planning/phases/04-auto-save-content-pipeline/04-01-SUMMARY.md`
</output>
