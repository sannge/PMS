---
phase: 04-auto-save-content-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  # Backend CREATE
  - fastapi-backend/app/schemas/document.py
  - fastapi-backend/app/routers/documents.py
  # Frontend CREATE
  - electron-app/src/renderer/hooks/use-auto-save.ts
  # Frontend MODIFY
  - electron-app/src/renderer/hooks/use-queries.ts
autonomous: true

must_haves:
  truths:
    - "PUT /api/documents/{id}/content accepts content_json and row_version, increments row_version on success"
    - "PUT /api/documents/{id}/content returns 409 when row_version does not match (stale client)"
    - "Editor content auto-saves after 10 seconds of typing inactivity without user action"
    - "Redundant saves are skipped when content has not changed since last save (dirty check via JSON string comparison)"
    - "The useAutoSave hook exposes isDirty, saveNow (immediate save), and save status (idle, saving, saved, error)"
  artifacts:
    - path: "fastapi-backend/app/routers/documents.py"
      provides: "PUT /api/documents/{id}/content endpoint with row_version concurrency"
      contains: "save_document_content"
    - path: "fastapi-backend/app/schemas/document.py"
      provides: "DocumentContentUpdate schema for auto-save request body"
      contains: "DocumentContentUpdate"
    - path: "electron-app/src/renderer/hooks/use-auto-save.ts"
      provides: "useAutoSave hook with 10s debounce, dirty tracking, save mutex"
      contains: "useAutoSave"
    - path: "electron-app/src/renderer/hooks/use-queries.ts"
      provides: "useSaveDocumentContent mutation calling PUT content endpoint"
      contains: "useSaveDocumentContent"
  key_links:
    - from: "electron-app/src/renderer/hooks/use-auto-save.ts"
      to: "electron-app/src/renderer/hooks/use-queries.ts"
      via: "useSaveDocumentContent mutation"
      pattern: "useSaveDocumentContent"
    - from: "electron-app/src/renderer/hooks/use-queries.ts"
      to: "fastapi-backend/app/routers/documents.py"
      via: "PUT /api/documents/{id}/content fetch call"
      pattern: "documents.*content"
    - from: "fastapi-backend/app/routers/documents.py"
      to: "fastapi-backend/app/models/document.py"
      via: "row_version check and increment on save"
      pattern: "row_version"
---

<objective>
Create the auto-save endpoint (PUT /api/documents/{id}/content) with optimistic concurrency, and the frontend useAutoSave hook with 10-second debounced save and client-side dirty tracking.

Purpose: This is the foundational save infrastructure that all other Phase 4 plans depend on. The endpoint accepts TipTap JSON and row_version, and the hook manages debounced auto-save with a mutex to prevent race conditions between auto-save and manual save triggers.

Output: Working auto-save that fires after 10 seconds of typing inactivity, skips saves when content hasn't changed, and handles version conflicts gracefully.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-auto-save-content-pipeline/04-RESEARCH.md

Key reference files for patterns:
@fastapi-backend/app/routers/documents.py
@fastapi-backend/app/schemas/document.py
@fastapi-backend/app/models/document.py
@fastapi-backend/app/services/document_service.py
@electron-app/src/renderer/hooks/use-queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DocumentContentUpdate schema and PUT /api/documents/{id}/content endpoint</name>
  <files>
    fastapi-backend/app/schemas/document.py (MODIFY)
    fastapi-backend/app/routers/documents.py (MODIFY)
  </files>
  <action>
    **1. Add `DocumentContentUpdate` schema to `fastapi-backend/app/schemas/document.py`:**

    Add a new Pydantic model for the auto-save request body:
    - `content_json`: str (required) -- the TipTap JSON string from editor.getJSON()
    - `row_version`: int (required) -- the client's known row_version for optimistic concurrency
    - `title`: str | None = None -- optional title update (auto-save may include title changes)

    **2. Add `DocumentContentSaveResponse` schema to `fastapi-backend/app/schemas/document.py`:**

    Lightweight response for the save endpoint (no need to return full content back):
    - `id`: UUID
    - `row_version`: int -- the new row_version after save
    - `updated_at`: datetime
    - `content_markdown`: str | None -- for verification that pipeline ran (can be omitted in production)
    - `content_plain`: str | None -- for verification
    - `model_config = ConfigDict(from_attributes=True)`

    **3. Add PUT endpoint to `fastapi-backend/app/routers/documents.py`:**

    Create `PUT /api/documents/{document_id}/content` endpoint:

    ```python
    @router.put("/documents/{document_id}/content", response_model=DocumentContentSaveResponse)
    async def save_document_content(
        document_id: UUID,
        body: DocumentContentUpdate,
        current_user: User = Depends(get_current_user),
        db: AsyncSession = Depends(get_db),
    ):
    ```

    Implementation:
    1. Query document by ID, raise 404 if not found or soft-deleted (deleted_at is not None)
    2. Check `body.row_version == doc.row_version` -- if mismatch, raise HTTPException 409 with detail "Document was modified by another user. Please reload."
    3. Parse `body.content_json` as JSON (validate it's valid JSON) -- raise 422 if malformed
    4. Call `content_converter.tiptap_json_to_markdown(parsed_json)` to generate Markdown (imported from `app.services.content_converter` -- this module is created by plan 04-04; for now import from `app.services.document_service` which has the stubs from Phase 1)
    5. Call `content_converter.tiptap_json_to_plain_text(parsed_json)` to generate plain text
    6. Update document fields: `content_json`, `content_markdown`, `content_plain`, `updated_at = datetime.utcnow()`
    7. If `body.title` is provided, update `doc.title`
    8. Increment `doc.row_version += 1`
    9. `await db.commit()`, `await db.refresh(doc)`
    10. Return `DocumentContentSaveResponse` with new row_version, updated_at, and content fields

    **Important:** The endpoint uses the conversion stubs from Phase 1 document_service.py initially. Plan 04-04 will create the real content_converter.py and the endpoint import will be updated to use it. For now, wire to the existing stubs (`convert_tiptap_to_markdown`, `convert_tiptap_to_plain_text` from document_service).

    Follow existing router patterns in documents.py for auth dependency, error handling, and response formatting.
  </action>
  <verify>
    - `cd fastapi-backend && python -c "from app.schemas.document import DocumentContentUpdate, DocumentContentSaveResponse; print('Schemas OK')"` succeeds
    - `cd fastapi-backend && uvicorn app.main:app --port 8001` starts without errors
    - Manual test with curl:
      - Create a document: `POST /api/documents` with scope and title
      - Save content: `PUT /api/documents/{id}/content` with `{"content_json": "{\"type\":\"doc\",\"content\":[]}", "row_version": 1}` returns 200 with row_version 2
      - Save with wrong row_version: `PUT /api/documents/{id}/content` with `{"content_json": "...", "row_version": 1}` returns 409
    - `cd fastapi-backend && ruff check app/routers/documents.py app/schemas/document.py` passes
  </verify>
  <done>
    PUT /api/documents/{id}/content endpoint accepts content_json + row_version, validates concurrency, calls conversion stubs, increments row_version, and returns lightweight response. Stale row_version returns 409.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useAutoSave hook with 10s debounce, dirty tracking, and save mutex</name>
  <files>
    electron-app/src/renderer/hooks/use-auto-save.ts (CREATE)
    electron-app/src/renderer/hooks/use-queries.ts (MODIFY)
  </files>
  <action>
    **1. Add `useSaveDocumentContent` mutation to `electron-app/src/renderer/hooks/use-queries.ts`:**

    Follow existing mutation patterns in use-queries.ts. Add:

    ```typescript
    interface SaveDocumentContentParams {
      documentId: string
      contentJson: string
      rowVersion: number
      title?: string
    }

    interface SaveDocumentContentResponse {
      id: string
      row_version: number
      updated_at: string
      content_markdown: string | null
      content_plain: string | null
    }
    ```

    Create `useSaveDocumentContent()` mutation:
    - Method: PUT to `/api/documents/${documentId}/content`
    - Body: `{ content_json, row_version, title }`
    - On success: invalidate document detail query for this document ID so next fetch gets fresh data
    - Do NOT use optimistic update (auto-save should not optimistically update cache -- the editor already has the content)

    **2. Create `electron-app/src/renderer/hooks/use-auto-save.ts`:**

    Export a `useAutoSave` hook with this signature:

    ```typescript
    interface UseAutoSaveOptions {
      documentId: string
      editor: Editor | null  // TipTap editor instance
      rowVersion: number     // Current row_version from server
      enabled?: boolean      // Default true; set false to disable (e.g., read-only mode)
    }

    interface UseAutoSaveReturn {
      isDirty: boolean           // Content has changed since last save
      isSaving: boolean          // Save is in progress
      lastSavedAt: number | null // Timestamp of last successful save (Date.now())
      saveError: string | null   // Error message if last save failed
      saveNow: () => Promise<void> // Trigger immediate save (for manual save, navigate-away)
      currentRowVersion: number  // Latest row_version (updated after each save)
    }
    ```

    Implementation details:

    - **lastSavedJsonRef** (useRef<string>): Stores `JSON.stringify(editor.getJSON())` of the last successfully saved content. Initialized from editor content on mount (assumes loaded content = saved content).

    - **isDirty** check: Compare `JSON.stringify(editor.getJSON())` against `lastSavedJsonRef.current`. Use this before triggering any save.

    - **Debounce timer** (useRef<ReturnType<typeof setTimeout>>): Reset on every editor `update` event. After 10,000ms of inactivity, check isDirty and trigger save if dirty.

    - **Save mutex** (useRef<boolean> `isSavingRef`): Prevents concurrent saves. If a save is already in progress, skip. This prevents race conditions between auto-save timer firing and manual saveNow() calls.

    - **saveNow()** function:
      1. Clear pending debounce timer
      2. If `isSavingRef.current` is true, return (already saving)
      3. If not dirty, return (nothing to save)
      4. Set `isSavingRef.current = true`
      5. Get current JSON from editor
      6. Call `saveMutation.mutateAsync({ documentId, contentJson, rowVersion: currentRowVersionRef.current })`
      7. On success: update `lastSavedJsonRef.current`, update `currentRowVersionRef` with response row_version, set `lastSavedAt`, clear error
      8. On error: set `saveError` with message. If 409 (conflict), include "Document was modified by another user" in error.
      9. Finally: set `isSavingRef.current = false`

    - **Editor update listener** (useEffect):
      1. Listen to `editor.on('update', handler)`
      2. In handler: clear existing timer, set new 10s timer that calls saveNow()
      3. Cleanup: remove listener, clear timer

    - **Row version tracking**: Use a ref (`currentRowVersionRef`) initialized from the `rowVersion` prop. Updated after each successful save from the response. This ensures subsequent saves use the latest row_version.

    - **Cleanup on unmount**: Clear debounce timer. Do NOT auto-save on unmount here (that's plan 04-03's responsibility with save-on-navigate).

    - **enabled flag**: When `enabled` is false, don't attach editor listener and don't trigger saves. Useful for read-only mode or when lock is not held.

    Import `Editor` type from `@tiptap/react`. Import `useSaveDocumentContent` from `use-queries`.
  </action>
  <verify>
    - `cd electron-app && npx tsc --noEmit` passes (no type errors)
    - `cd electron-app && npm run lint` passes with zero warnings
    - File `electron-app/src/renderer/hooks/use-auto-save.ts` exists and exports `useAutoSave`
    - File `electron-app/src/renderer/hooks/use-queries.ts` has `useSaveDocumentContent` export
  </verify>
  <done>
    useAutoSave hook created with 10-second debounced auto-save, client-side dirty tracking via JSON string comparison, save mutex to prevent concurrent saves, and row_version tracking for optimistic concurrency. useSaveDocumentContent mutation added to use-queries.ts calling PUT /api/documents/{id}/content.
  </done>
</task>

</tasks>

<verification>
1. Backend: `cd fastapi-backend && ruff check .` passes
2. Backend: Server starts and PUT /api/documents/{id}/content returns 200 with updated row_version
3. Backend: PUT with stale row_version returns 409
4. Frontend: `cd electron-app && npx tsc --noEmit` passes
5. Frontend: `cd electron-app && npm run lint` passes
6. useAutoSave hook exports: isDirty, isSaving, lastSavedAt, saveError, saveNow, currentRowVersion
7. Save is debounced at 10 seconds (not fired on every keystroke)
8. Save is skipped when content matches lastSavedJsonRef (dirty check)
</verification>

<success_criteria>
- Auto-save endpoint works with optimistic concurrency (row_version check, 409 on mismatch)
- useAutoSave hook debounces at 10 seconds, checks dirty state, uses mutex for concurrent save prevention
- Mutation wired from hook to endpoint via useSaveDocumentContent
- No TypeScript errors, no ESLint warnings, no Ruff violations
</success_criteria>

<output>
After completion, create `.planning/phases/04-auto-save-content-pipeline/04-01-SUMMARY.md`
</output>
