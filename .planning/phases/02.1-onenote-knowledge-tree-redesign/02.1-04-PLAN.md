---
phase: 02.1-onenote-knowledge-tree-redesign
plan: 04
type: execute
wave: 3
depends_on: ["02.1-02", "02.1-03"]
files_modified:
  - electron-app/src/renderer/components/knowledge/application-tree.tsx
  - electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
  - electron-app/src/renderer/components/knowledge/search-bar.tsx
autonomous: true

must_haves:
  truths:
    - "Application tab shows app-level folders/docs AND auto-generated project folder sections"
    - "Project folders in the app tab are visually distinguished from user-created folders"
    - "Project folder contents are lazy-loaded on expand"
    - "Search bar has a toggle to search globally (across all tabs)"
  artifacts:
    - path: "electron-app/src/renderer/components/knowledge/application-tree.tsx"
      provides: "ApplicationTree component with mixed app-scoped + project-scoped tree"
      exports: ["ApplicationTree"]
    - path: "electron-app/src/renderer/components/knowledge/search-bar.tsx"
      provides: "Search bar with global toggle"
      contains: "global"
  key_links:
    - from: "application-tree.tsx"
      to: "use-document-folders.ts"
      via: "useFolderTree for app scope + project scope (lazy)"
      pattern: "useFolderTree"
    - from: "knowledge-sidebar.tsx"
      to: "application-tree.tsx"
      via: "renders ApplicationTree for app tabs"
      pattern: "ApplicationTree"
---

<objective>
Build the ApplicationTree component that shows the mixed-scope tree for application tabs (app-level folders/docs + auto-generated project folder sections with lazy-loaded contents). Also add the global search toggle to the search bar.

Purpose: The application tab is the most complex tree view — it composes app-scoped items with project-scoped items using frontend query composition (no new backend endpoint). This plan completes the tree rendering for all tab types.
Output: ApplicationTree component, updated search bar, wired sidebar.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-CONTEXT.md
@.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-RESEARCH.md
@.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-01-SUMMARY.md
@.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-02-SUMMARY.md
@.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-03-SUMMARY.md
@electron-app/src/renderer/components/knowledge/folder-tree.tsx
@electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
@electron-app/src/renderer/components/knowledge/search-bar.tsx
@electron-app/src/renderer/hooks/use-document-folders.ts
@electron-app/src/renderer/hooks/use-documents.ts
@electron-app/src/renderer/hooks/use-queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: ApplicationTree component for mixed-scope tree</name>
  <files>
    electron-app/src/renderer/components/knowledge/application-tree.tsx
  </files>
  <action>
    Create `application-tree.tsx` — a tree component for application tabs that shows:
    1. **App-level section:** Folders and unfiled docs scoped to `scope=application, scope_id=applicationId`
    2. **Project sections:** One auto-generated folder per project under this application that has docs, each containing project-scoped folders/docs

    Implementation:

    ```typescript
    interface ApplicationTreeProps {
      applicationId: string
    }
    ```

    **App-level items:** Use existing `useFolderTree('application', applicationId)` and `useDocuments('application', applicationId, { includeUnfiled: true })`. Render using the same `FolderTreeItem` components and logic as the existing `FolderTree` (extract shared rendering helpers if needed, or duplicate the folder/doc rendering logic inline since it's small).

    **Project sections:** Use `useProjects(applicationId)` from `use-queries.ts` to get projects list. For each project, render a `ProjectSection` sub-component:

    ```typescript
    function ProjectSection({ project }: { project: Project }) {
      const { expandedFolderIds, toggleFolder, ... } = useKnowledgeBase()
      const isExpanded = expandedFolderIds.has(`project:${project.id}`)

      // Lazy-fetch project tree only when expanded
      const { data: projectFolders } = useFolderTree('project', project.id, {
        enabled: isExpanded,
      })
      const { data: projectDocs } = useDocuments('project', project.id, {
        includeUnfiled: true,
        enabled: isExpanded,
      })

      return (
        <div>
          {/* Project folder header — distinguished with FolderKanban icon */}
          <div
            className={cn(
              'flex items-center gap-1.5 py-1 px-3 cursor-pointer rounded-sm',
              'hover:bg-accent/50 transition-colors',
              'text-muted-foreground'
            )}
            onClick={() => toggleFolder(`project:${project.id}`)}
            role="treeitem"
            aria-expanded={isExpanded}
          >
            <FolderKanban className="h-4 w-4 shrink-0 text-primary/70" />
            <span className="text-sm font-medium truncate">{project.name}</span>
          </div>
          {isExpanded && (
            <div className="ml-2">
              {/* project folders and docs, rendered at depth=1 */}
              {projectFolders?.map(folder => renderFolderNode(folder, 1))}
              {projectDocs?.items?.map(doc => renderDocumentItem(doc, 1))}
            </div>
          )}
        </div>
      )
    }
    ```

    Visual distinction for project sections (Claude's discretion from CONTEXT.md):
    - Use `FolderKanban` icon (already used for projects throughout the app) instead of `Folder` icon
    - Use a slightly lighter/tinted text color (e.g., `text-primary/70`)
    - Optionally add a thin left border accent: `border-l-2 border-primary/20`

    **CRUD in project sections:** Creating a document or folder inside a project section should use `scope='project'` and `scope_id=project.id`. The context menu already gets scope from the tree item's context. Wire the FolderContextMenu callbacks with project-scoped mutations.

    **Shared rendering logic:** The folder/document rendering (renderFolderNode, renderDocumentItem) patterns from the existing FolderTree can be extracted or duplicated. The key difference: CRUD callbacks need scope awareness. For simplicity, the ApplicationTree can accept scope-aware mutation callbacks or create its own.

    Since the ApplicationTree is a large component, keep it focused. The CRUD callbacks (new folder, new doc, rename, delete, context menu) follow the same patterns as FolderTree but with scope-awareness. Use `useCreateFolder`, `useCreateDocument`, `useRenameFolder`, etc., passing the correct scope for each section.
  </action>
  <verify>
    1. `cd electron-app && npx tsc --noEmit --pretty 2>&1 | head -30` — zero errors
    2. `grep -n "ApplicationTree" electron-app/src/renderer/components/knowledge/application-tree.tsx` — exported
  </verify>
  <done>
    ApplicationTree renders app-level folders/docs plus auto-generated project folder sections with lazy loading. Project folders use FolderKanban icon for visual distinction. CRUD works within correct scope.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ApplicationTree into sidebar + add global search toggle</name>
  <files>
    electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
    electron-app/src/renderer/components/knowledge/search-bar.tsx
  </files>
  <action>
    **Wire ApplicationTree into sidebar:**

    Update `knowledge-sidebar.tsx` to conditionally render:
    - When activeTab is 'personal': render the existing `FolderTree` (which uses scope from context = 'personal')
    - When activeTab starts with 'app:': render `ApplicationTree` with the extracted applicationId

    ```typescript
    const { activeTab, ... } = useKnowledgeBase()
    const isPersonalTab = activeTab === 'personal'
    const appIdFromTab = activeTab.startsWith('app:') ? activeTab.slice(4) : null

    // In the tree section:
    <ScrollArea className="flex-1">
      {isPersonalTab ? (
        <FolderTree />
      ) : appIdFromTab ? (
        <ApplicationTree applicationId={appIdFromTab} />
      ) : null}
    </ScrollArea>
    ```

    **Global search toggle:**

    Update `search-bar.tsx` to add a small toggle button next to the search input:
    - Add a `isGlobal` boolean state (local, not in context — kept simple)
    - Toggle button: small icon button with `Globe` icon (when global) or current-tab-scope icon (when scoped)
    - When global is OFF (default): search filters within current tab's scope (existing behavior)
    - When global is ON: search query is passed with a `global` flag to the context or search hook
    - For now, just pass the `isGlobal` state alongside the search query. Full backend search integration is in Phase 9. The toggle UI should exist and persist state, even if global search behavior is deferred.

    Add the toggle as a small button at the right side of the search input:
    ```tsx
    <button
      onClick={() => setIsGlobal(!isGlobal)}
      className={cn(
        'absolute right-7 top-1/2 -translate-y-1/2 p-0.5 rounded',
        'transition-colors',
        isGlobal
          ? 'text-primary hover:text-primary/80'
          : 'text-muted-foreground hover:text-foreground'
      )}
      title={isGlobal ? 'Searching all tabs' : 'Searching current tab'}
      aria-label={isGlobal ? 'Search all tabs' : 'Search current tab only'}
    >
      <Globe className="h-3 w-3" />
    </button>
    ```

    Adjust the clear button position if the toggle is present (shift clear button further right or swap positions).
  </action>
  <verify>
    1. `cd electron-app && npx tsc --noEmit --pretty 2>&1 | head -30` — zero errors
    2. `grep -n "ApplicationTree" electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx` — imported and used
    3. `grep -n "isGlobal\|Globe" electron-app/src/renderer/components/knowledge/search-bar.tsx` — toggle exists
  </verify>
  <done>
    Sidebar conditionally renders FolderTree (personal tab) or ApplicationTree (app tabs). Search bar has a global toggle. All TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `cd electron-app && npx tsc --noEmit --pretty` — zero errors
2. ApplicationTree exists and is used in sidebar
3. Personal tab shows FolderTree, app tabs show ApplicationTree
4. Search bar has global toggle button
5. Project sections in ApplicationTree use FolderKanban icon
</verification>

<success_criteria>
- Application tab renders app-level folders/docs + project folder sections
- Project folders visually distinguished (FolderKanban icon, different styling)
- Project folder contents lazy-loaded on expand
- Sidebar switches between FolderTree and ApplicationTree based on active tab
- Search bar has global/scoped toggle
- Zero TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-04-SUMMARY.md`
</output>
