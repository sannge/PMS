---
phase: 02.1-onenote-knowledge-tree-redesign
plan: 04
type: execute
wave: 3
depends_on: ["02.1-02", "02.1-03"]
files_modified:
  - electron-app/src/renderer/components/knowledge/application-tree.tsx
  - electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
  - electron-app/src/renderer/components/knowledge/search-bar.tsx
autonomous: true

must_haves:
  truths:
    - "Application tab shows app-level folders/docs AND auto-generated project folder sections"
    - "Project folders in the app tab are visually distinguished from user-created folders"
    - "Project folder contents are lazy-loaded on expand"
    - "Search bar has a toggle to search globally (across all tabs)"
  artifacts:
    - path: "electron-app/src/renderer/components/knowledge/application-tree.tsx"
      provides: "ApplicationTree component with mixed app-scoped + project-scoped tree"
      exports: ["ApplicationTree"]
    - path: "electron-app/src/renderer/components/knowledge/search-bar.tsx"
      provides: "Search bar with global toggle"
      contains: "global"
  key_links:
    - from: "application-tree.tsx"
      to: "use-document-folders.ts"
      via: "useFolderTree for app scope + project scope (lazy)"
      pattern: "useFolderTree"
    - from: "knowledge-sidebar.tsx"
      to: "application-tree.tsx"
      via: "renders ApplicationTree for app tabs"
      pattern: "ApplicationTree"
---

<objective>
Build the ApplicationTree component that shows the mixed-scope tree for application tabs (app-level folders/docs + auto-generated project folder sections with lazy-loaded contents). Also add the global search toggle to the search bar.

Purpose: The application tab is the most complex tree view — it composes app-scoped items with project-scoped items using frontend query composition (no new backend endpoint). This plan completes the tree rendering for all tab types.
Output: ApplicationTree component, updated search bar, wired sidebar.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-CONTEXT.md
@.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-RESEARCH.md
@.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-01-SUMMARY.md
@.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-02-SUMMARY.md
@.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-03-SUMMARY.md
@electron-app/src/renderer/components/knowledge/folder-tree.tsx
@electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
@electron-app/src/renderer/components/knowledge/search-bar.tsx
@electron-app/src/renderer/hooks/use-document-folders.ts
@electron-app/src/renderer/hooks/use-documents.ts
@electron-app/src/renderer/hooks/use-queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1a: ApplicationTree shell with app-level rendering</name>
  <files>
    electron-app/src/renderer/components/knowledge/application-tree.tsx
  </files>
  <action>
    Create `application-tree.tsx` — the shell component for application tabs that renders app-level items:

    ```typescript
    interface ApplicationTreeProps {
      applicationId: string
    }
    ```

    **App-level items only (this task):** Use existing `useFolderTree('application', applicationId)` and `useDocuments('application', applicationId, { includeUnfiled: true })`. Render using the same `FolderTreeItem` components and logic as the existing `FolderTree` (extract shared rendering helpers if needed, or duplicate the folder/doc rendering logic inline since it's small).

    **App-level CRUD with context menus:** Wire `FolderContextMenu` with scope-aware callbacks:

    ```typescript
    import { useCreateDocument, useCreateFolder, useDeleteDocument, useDeleteFolder, useRenameFolder } from '@/hooks/use-documents'

    // Inside ApplicationTree:
    const createDocument = useCreateDocument()
    const createFolder = useCreateFolder()
    const deleteDocument = useDeleteDocument()
    const deleteFolder = useDeleteFolder()
    const renameFolder = useRenameFolder()

    // App-level scope handler:
    const appScope = { scope: 'application' as const, scopeId: applicationId }

    const handleCreateDoc = (folderId: string | null) => {
      createDocument.mutate({
        title: 'Untitled',
        scope: appScope.scope,
        scope_id: appScope.scopeId,
        folder_id: folderId,
      })
    }

    const handleCreateFolder = (parentFolderId: string | null) => {
      createFolder.mutate({
        name: 'New Folder',
        scope: appScope.scope,
        scope_id: appScope.scopeId,
        parent_folder_id: parentFolderId,
      })
    }

    // Pass these handlers to FolderContextMenu:
    // <FolderContextMenu
    //   onNewDocument={() => handleCreateDoc(folder.id)}
    //   onNewFolder={() => handleCreateFolder(folder.id)}
    //   onRename={(name) => renameFolder.mutate({ folderId: folder.id, name })}
    //   onDelete={() => deleteFolder.mutate({ folderId: folder.id })}
    // />
    ```

    Render app-level folders/docs with `FolderTreeItem`. Leave a placeholder `{/* Project sections rendered by Task 1b */}` below the app-level items.

    Export `ApplicationTree` as default.
  </action>
  <verify>
    1. `cd electron-app && npx tsc --noEmit --pretty 2>&1 | head -30` — zero errors
    2. `grep -n "ApplicationTree" electron-app/src/renderer/components/knowledge/application-tree.tsx` — exported
  </verify>
  <done>
    ApplicationTree shell renders app-level folders/docs with scope-aware CRUD context menus. Component exported and compiles.
  </done>
</task>

<task type="auto">
  <name>Task 1b: Add project sections with lazy loading and scope-aware CRUD</name>
  <files>
    electron-app/src/renderer/components/knowledge/application-tree.tsx
  </files>
  <action>
    Add project folder sections to the existing ApplicationTree component created in Task 1a.

    **Project sections:** Use `useProjects(applicationId)` from `use-queries.ts` to get projects list. For each project, render a `ProjectSection` sub-component:

    ```typescript
    function ProjectSection({ project, renderFolderNode, renderDocumentItem }: {
      project: Project
      renderFolderNode: (folder: FolderNode, depth: number) => React.ReactNode
      renderDocumentItem: (doc: Document, depth: number) => React.ReactNode
    }) {
      const { expandedFolderIds, toggleFolder } = useKnowledgeBase()
      const isExpanded = expandedFolderIds.has(`project:${project.id}`)

      // Lazy-fetch project tree only when expanded
      const { data: projectFolders } = useFolderTree('project', project.id, {
        enabled: isExpanded,
      })
      const { data: projectDocs } = useDocuments('project', project.id, {
        includeUnfiled: true,
        enabled: isExpanded,
      })

      return (
        <div>
          {/* Project folder header — distinguished with FolderKanban icon */}
          <div
            className={cn(
              'flex items-center gap-1.5 py-1 px-3 cursor-pointer rounded-sm',
              'hover:bg-accent/50 transition-colors',
              'text-muted-foreground'
            )}
            onClick={() => toggleFolder(`project:${project.id}`)}
            role="treeitem"
            aria-expanded={isExpanded}
          >
            <FolderKanban className="h-4 w-4 shrink-0 text-primary/70" />
            <span className="text-sm font-medium truncate">{project.name}</span>
          </div>
          {isExpanded && (
            <div className="ml-2">
              {projectFolders?.map(folder => renderFolderNode(folder, 1))}
              {projectDocs?.items?.map(doc => renderDocumentItem(doc, 1))}
            </div>
          )}
        </div>
      )
    }
    ```

    Visual distinction for project sections (Claude's discretion from CONTEXT.md):
    - Use `FolderKanban` icon (already used for projects throughout the app) instead of `Folder` icon
    - Use a slightly lighter/tinted text color (e.g., `text-primary/70`)
    - Optionally add a thin left border accent: `border-l-2 border-primary/20`

    **Project-scoped CRUD via context menus:** Wire `FolderContextMenu` inside project sections with project-scoped handlers:

    ```typescript
    // Inside ProjectSection or passed as props from ApplicationTree:
    const projectScope = { scope: 'project' as const, scopeId: project.id }

    const handleCreateDoc = (folderId: string | null) => {
      createDocument.mutate({
        title: 'Untitled',
        scope: projectScope.scope,
        scope_id: projectScope.scopeId,
        folder_id: folderId,
      })
    }

    const handleCreateFolder = (parentFolderId: string | null) => {
      createFolder.mutate({
        name: 'New Folder',
        scope: projectScope.scope,
        scope_id: projectScope.scopeId,
        parent_folder_id: parentFolderId,
      })
    }

    // Each FolderContextMenu inside a project section uses project-scoped handlers:
    // <FolderContextMenu
    //   onNewDocument={() => handleCreateDoc(folder.id)}
    //   onNewFolder={() => handleCreateFolder(folder.id)}
    //   onRename={(name) => renameFolder.mutate({ folderId: folder.id, name })}
    //   onDelete={() => deleteFolder.mutate({ folderId: folder.id })}
    // />
    ```

    Replace the placeholder from Task 1a with the actual ProjectSection rendering:
    ```tsx
    {/* After app-level items */}
    {projects?.map(project => (
      <ProjectSection
        key={project.id}
        project={project}
        renderFolderNode={renderFolderNode}
        renderDocumentItem={renderDocumentItem}
      />
    ))}
    ```
  </action>
  <verify>
    1. `cd electron-app && npx tsc --noEmit --pretty 2>&1 | head -30` — zero errors
    2. `grep -n "ProjectSection\|FolderKanban" electron-app/src/renderer/components/knowledge/application-tree.tsx` — both present
  </verify>
  <done>
    ApplicationTree renders app-level items plus auto-generated project folder sections with lazy loading. Project folders use FolderKanban icon. CRUD in project sections uses project-scoped mutations. All TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ApplicationTree into sidebar + add global search toggle</name>
  <files>
    electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
    electron-app/src/renderer/components/knowledge/search-bar.tsx
  </files>
  <action>
    **Wire ApplicationTree into sidebar:**

    Update `knowledge-sidebar.tsx` to conditionally render:
    - When activeTab is 'personal': render the existing `FolderTree` (which uses scope from context = 'personal')
    - When activeTab starts with 'app:': render `ApplicationTree` with the extracted applicationId

    ```typescript
    const { activeTab, ... } = useKnowledgeBase()
    const isPersonalTab = activeTab === 'personal'
    const appIdFromTab = activeTab.startsWith('app:') ? activeTab.slice(4) : null

    // In the tree section:
    <ScrollArea className="flex-1">
      {isPersonalTab ? (
        <FolderTree />
      ) : appIdFromTab ? (
        <ApplicationTree applicationId={appIdFromTab} />
      ) : null}
    </ScrollArea>
    ```

    **Global search toggle:**

    Update `search-bar.tsx` to add a small toggle button next to the search input:
    - Add a `isGlobal` boolean state (local, not in context — kept simple)
    - Toggle button: small icon button with `Globe` icon (when global) or current-tab-scope icon (when scoped)
    - When global is OFF (default): search filters within current tab's scope (existing behavior)
    - When global is ON: search query is passed with a `global` flag to the context or search hook
    - For now, just pass the `isGlobal` state alongside the search query. Full backend search integration is in Phase 9. The toggle UI should exist and persist state, even if global search behavior is deferred.

    Add the toggle as a small button at the right side of the search input:
    ```tsx
    <button
      onClick={() => setIsGlobal(!isGlobal)}
      className={cn(
        'absolute right-7 top-1/2 -translate-y-1/2 p-0.5 rounded',
        'transition-colors',
        isGlobal
          ? 'text-primary hover:text-primary/80'
          : 'text-muted-foreground hover:text-foreground'
      )}
      title={isGlobal ? 'Searching all tabs' : 'Searching current tab'}
      aria-label={isGlobal ? 'Search all tabs' : 'Search current tab only'}
    >
      <Globe className="h-3 w-3" />
    </button>
    ```

    Adjust the clear button position if the toggle is present (shift clear button further right or swap positions).
  </action>
  <verify>
    1. `cd electron-app && npx tsc --noEmit --pretty 2>&1 | head -30` — zero errors
    2. `grep -n "ApplicationTree" electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx` — imported and used
    3. `grep -n "isGlobal\|Globe" electron-app/src/renderer/components/knowledge/search-bar.tsx` — toggle exists
  </verify>
  <done>
    Sidebar conditionally renders FolderTree (personal tab) or ApplicationTree (app tabs). Search bar has a global toggle. All TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `cd electron-app && npx tsc --noEmit --pretty` — zero errors
2. ApplicationTree exists and is used in sidebar
3. Personal tab shows FolderTree, app tabs show ApplicationTree
4. Search bar has global toggle button
5. Project sections in ApplicationTree use FolderKanban icon
</verification>

<success_criteria>
- Application tab renders app-level folders/docs + project folder sections
- Project folders visually distinguished (FolderKanban icon, different styling)
- Project folder contents lazy-loaded on expand
- Sidebar switches between FolderTree and ApplicationTree based on active tab
- Search bar has global/scoped toggle
- Zero TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-04-SUMMARY.md`
</output>
