---
phase: 02.1-onenote-knowledge-tree-redesign
plan: 15
type: execute
wave: 2
depends_on: ["02.1-06"]
files_modified:
  - electron-app/src/renderer/components/knowledge/folder-tree.tsx
  - electron-app/src/renderer/components/knowledge/application-tree.tsx
  - electron-app/src/renderer/components/knowledge/folder-tree-item.tsx
  - electron-app/src/renderer/hooks/use-document-folders.ts
  - electron-app/src/renderer/hooks/use-documents.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Documents and folders can be dragged to reorder within the tree"
    - "Drag-and-drop only works within same scope (no cross-scope moves)"
    - "Visual feedback shows drop target during drag"
    - "Reorder persists after page refresh"
  artifacts:
    - path: "electron-app/src/renderer/components/knowledge/folder-tree.tsx"
      provides: "Sortable tree with @dnd-kit integration"
    - path: "electron-app/src/renderer/hooks/use-document-folders.ts"
      provides: "Reorder mutation for folders"
    - path: "electron-app/src/renderer/hooks/use-documents.ts"
      provides: "Reorder mutation for documents"
  key_links:
    - from: "folder-tree.tsx"
      to: "@dnd-kit/core"
      via: "DndContext provider"
      pattern: "DndContext|useSortable"
    - from: "folder-tree.tsx"
      to: "reorderFolder"
      via: "Mutation on drag end"
      pattern: "handleDragEnd.*reorder"
---

<objective>
Implement drag-and-drop reordering for documents and folders within the knowledge tree.

Purpose: Users need to organize their documents and folders by dragging them into the desired order. Per CONTEXT.md, drag-and-drop only works within the same scope (no cross-scope moves).

Output: Sortable tree items using @dnd-kit that persist order to the backend.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-CONTEXT.md
@electron-app/src/renderer/hooks/use-drag-and-drop.ts
@electron-app/src/renderer/components/knowledge/folder-tree.tsx
@electron-app/src/renderer/components/knowledge/folder-tree-item.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reorder mutations to hooks</name>
  <files>electron-app/src/renderer/hooks/use-document-folders.ts, electron-app/src/renderer/hooks/use-documents.ts</files>
  <action>
The backend needs endpoints for reordering, and the frontend needs mutations to call them. Check if these exist; if not, create them.

**For use-document-folders.ts - add reorderFolder mutation:**

```tsx
interface ReorderFolderData {
  folderId: string
  beforeFolderId: string | null  // Folder to place after (null = first)
  afterFolderId: string | null   // Folder to place before (null = last)
  parentId: string | null        // New parent folder (for nesting via drag)
}

export function useReorderFolder() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (data: ReorderFolderData) => {
      const response = await api.patch(`/document-folders/${data.folderId}/reorder`, {
        before_folder_id: data.beforeFolderId,
        after_folder_id: data.afterFolderId,
        parent_id: data.parentId,
      })
      return response.data
    },
    onSuccess: () => {
      // Invalidate folder tree queries
      queryClient.invalidateQueries({ queryKey: ['document-folders'] })
    },
  })
}
```

**For use-documents.ts - add reorderDocument mutation:**

```tsx
interface ReorderDocumentData {
  documentId: string
  beforeDocumentId: string | null
  afterDocumentId: string | null
  folderId: string | null  // New folder (for nesting via drag)
}

export function useReorderDocument() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (data: ReorderDocumentData) => {
      const response = await api.patch(`/documents/${data.documentId}/reorder`, {
        before_document_id: data.beforeDocumentId,
        after_document_id: data.afterDocumentId,
        folder_id: data.folderId,
      })
      return response.data
    },
    onSuccess: () => {
      // Invalidate document queries
      queryClient.invalidateQueries({ queryKey: ['documents'] })
      queryClient.invalidateQueries({ queryKey: ['document-folders'] })
    },
  })
}
```

**Note:** If the backend doesn't have reorder endpoints yet, the mutation will fail at runtime. The backend would need:
- PATCH /document-folders/{id}/reorder
- PATCH /documents/{id}/reorder

These should calculate a new `sort_order` or `rank` field based on the before/after items.
  </action>
  <verify>
Grep for "useReorderFolder" in use-document-folders.ts - should find the hook.
Grep for "useReorderDocument" in use-documents.ts - should find the hook.
Run `npm run typecheck` - zero errors.
  </verify>
  <done>
Reorder mutations exist for both folders and documents.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add @dnd-kit sortable to FolderTree</name>
  <files>electron-app/src/renderer/components/knowledge/folder-tree.tsx, electron-app/src/renderer/components/knowledge/folder-tree-item.tsx</files>
  <action>
Integrate @dnd-kit for sortable tree items. Use the existing patterns from `use-drag-and-drop.ts` as reference.

**1. Add imports to folder-tree.tsx:**
```tsx
import {
  DndContext,
  DragEndEvent,
  DragOverlay,
  DragStartEvent,
  PointerSensor,
  useSensor,
  useSensors,
  closestCenter,
} from '@dnd-kit/core'
import {
  SortableContext,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable'
```

**2. Set up sensors and state:**
```tsx
const sensors = useSensors(
  useSensor(PointerSensor, {
    activationConstraint: { distance: 5 },
  })
)

const [activeItem, setActiveItem] = useState<{
  id: string
  type: 'folder' | 'document'
  name: string
} | null>(null)

const reorderFolder = useReorderFolder()
const reorderDocument = useReorderDocument()
```

**3. Create flat list of sortable IDs:**
```tsx
// Create a flat list of all items for sortable context
const getSortableItems = useCallback(() => {
  const items: string[] = []

  // Add folders (recursive)
  const addFolders = (nodes: FolderTreeNode[]) => {
    nodes.forEach(node => {
      items.push(`folder-${node.id}`)
      addFolders(node.children)
    })
  }
  addFolders(folders)

  // Add unfiled documents
  unfiledDocs.forEach(doc => {
    items.push(`doc-${doc.id}`)
  })

  return items
}, [folders, unfiledDocs])
```

**4. Handle drag events:**
```tsx
const handleDragStart = useCallback((event: DragStartEvent) => {
  const { active } = event
  const [type, id] = String(active.id).split('-')
  const name = type === 'folder'
    ? folders.find(f => f.id === id)?.name || 'Folder'
    : unfiledDocs.find(d => d.id === id)?.title || 'Document'

  setActiveItem({ id, type: type as 'folder' | 'document', name })
}, [folders, unfiledDocs])

const handleDragEnd = useCallback(async (event: DragEndEvent) => {
  const { active, over } = event
  setActiveItem(null)

  if (!over || active.id === over.id) return

  const [activeType, activeId] = String(active.id).split('-')
  const [overType, overId] = String(over.id).split('-')

  // Only allow reordering within same type (folder with folders, doc with docs)
  // This enforces same-scope constraint from CONTEXT.md
  if (activeType !== overType) {
    console.log('Cannot reorder across types (folder/doc)')
    return
  }

  // Find positions for reorder
  const items = getSortableItems()
  const overIndex = items.indexOf(String(over.id))

  // Determine before/after IDs
  const beforeId = overIndex > 0 ? items[overIndex - 1]?.split('-')[1] : null
  const afterId = items[overIndex + 1]?.split('-')[1] || null

  if (activeType === 'folder') {
    await reorderFolder.mutateAsync({
      folderId: activeId,
      beforeFolderId: beforeId,
      afterFolderId: afterId,
      parentId: null, // Keep same parent for now
    })
  } else {
    await reorderDocument.mutateAsync({
      documentId: activeId,
      beforeDocumentId: beforeId,
      afterDocumentId: afterId,
      folderId: null, // Keep same folder for now
    })
  }
}, [getSortableItems, reorderFolder, reorderDocument])
```

**5. Wrap tree in DndContext:**
```tsx
return (
  <DndContext
    sensors={sensors}
    collisionDetection={closestCenter}
    onDragStart={handleDragStart}
    onDragEnd={handleDragEnd}
  >
    <SortableContext items={getSortableItems()} strategy={verticalListSortingStrategy}>
      <div className="...">
        {/* Render folders and docs */}
        {folders.map(folder => renderFolderNode(folder, 0))}
        {unfiledDocs.map(doc => renderDocumentItem(doc, 0))}
      </div>
    </SortableContext>

    <DragOverlay>
      {activeItem && (
        <div className="bg-background border rounded p-2 shadow-lg opacity-80">
          {activeItem.type === 'folder' ? <Folder className="inline mr-2" /> : <FileText className="inline mr-2" />}
          {activeItem.name}
        </div>
      )}
    </DragOverlay>
  </DndContext>
)
```

**6. Update FolderTreeItem to be sortable:**
```tsx
import { useSortable } from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'

export function FolderTreeItem({ node, type, ... }: FolderTreeItemProps) {
  const sortableId = type === 'document' ? `doc-${node.id}` : `folder-${node.id}`

  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: sortableId })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  }

  return (
    <div
      ref={setNodeRef}
      style={style}
      {...attributes}
      {...listeners}
      className={cn(
        "flex items-center gap-2 px-2 py-1 cursor-grab active:cursor-grabbing",
        isDragging && "bg-accent/50"
      )}
    >
      {/* ... existing content ... */}
    </div>
  )
}
```
  </action>
  <verify>
Run `npm run typecheck` - zero errors.
Grep for "DndContext" in folder-tree.tsx - should find the provider.
Grep for "useSortable" in folder-tree-item.tsx - should find the hook.
  </verify>
  <done>
FolderTree has @dnd-kit integration for sortable items with drag overlay.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add @dnd-kit sortable to ApplicationTree</name>
  <files>electron-app/src/renderer/components/knowledge/application-tree.tsx</files>
  <action>
Apply the same @dnd-kit pattern to ApplicationTree for app-level and project-level items.

**Key differences from FolderTree:**
1. ApplicationTree has multiple scopes (app-level folders/docs + project sections)
2. Drag-and-drop must be restricted to same scope per CONTEXT.md
3. Cannot drag between app-level and project-level

**Implementation:**

1. Add the same imports as FolderTree.

2. Set up sensors, state, and mutations.

3. Create scope-aware sortable items:
```tsx
// For app-level content
const appLevelItems = useMemo(() => {
  const items: string[] = []
  folders.forEach(f => items.push(`app-folder-${f.id}`))
  unfiledDocs.forEach(d => items.push(`app-doc-${d.id}`))
  return items
}, [folders, unfiledDocs])
```

4. Validate same-scope in handleDragEnd:
```tsx
const handleDragEnd = useCallback(async (event: DragEndEvent) => {
  const { active, over } = event
  setActiveItem(null)

  if (!over || active.id === over.id) return

  // Parse scope and type from ID: "app-folder-{id}" or "project-{projId}-doc-{id}"
  const activeIdParts = String(active.id).split('-')
  const overIdParts = String(over.id).split('-')

  // Check scope match (first part)
  const activeScope = activeIdParts[0]
  const overScope = overIdParts[0]

  if (activeScope !== overScope) {
    console.log('Cannot drag between scopes')
    return
  }

  // For project scopes, also check project ID matches
  if (activeScope === 'project') {
    const activeProjectId = activeIdParts[1]
    const overProjectId = overIdParts[1]
    if (activeProjectId !== overProjectId) {
      console.log('Cannot drag between different projects')
      return
    }
  }

  // Perform reorder within scope...
}, [])
```

5. Each ProjectSection should have its own SortableContext:
```tsx
<ProjectSection project={project}>
  <SortableContext items={projectItems} strategy={verticalListSortingStrategy}>
    {/* Project folders and docs */}
  </SortableContext>
</ProjectSection>
```

This keeps project-level drag-and-drop isolated from app-level.

6. Show visual feedback during drag:
- Highlight valid drop targets
- Show "cannot drop" cursor when hovering invalid target (different scope)
  </action>
  <verify>
Run `npm run typecheck` - zero errors.
Grep for "DndContext" in application-tree.tsx - should find the provider.
Grep for "SortableContext" - should find multiple (app-level + per-project).
  </verify>
  <done>
ApplicationTree has scope-aware @dnd-kit integration preventing cross-scope moves.
  </done>
</task>

</tasks>

<verification>
1. `cd electron-app && npm run typecheck` passes
2. DndContext wraps tree components
3. useSortable is used in tree items
4. Reorder mutations exist in hooks
5. Cross-scope drag is prevented
</verification>

<success_criteria>
- Documents can be dragged to reorder within the same folder
- Folders can be dragged to reorder within the same parent
- Visual drag overlay shows item being dragged
- Drop target is highlighted during drag
- Attempting to drag between scopes does nothing (respects CONTEXT.md constraint)
- Order persists after page refresh (backend saves order)
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-15-SUMMARY.md`
</output>
