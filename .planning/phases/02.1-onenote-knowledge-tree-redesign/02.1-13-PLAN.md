---
phase: 02.1-onenote-knowledge-tree-redesign
plan: 13
type: execute
wave: 2
depends_on: ["02.1-06"]
files_modified:
  - electron-app/src/renderer/components/knowledge/folder-tree-item.tsx
  - electron-app/src/renderer/contexts/knowledge-base-context.tsx
  - electron-app/src/renderer/hooks/use-document-lock.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Lock icon appears in tree when another user is editing a document"
    - "Hovering over lock icon shows who is editing"
    - "Lock state updates in real-time via WebSocket"
  artifacts:
    - path: "electron-app/src/renderer/components/knowledge/folder-tree-item.tsx"
      provides: "Tree item with live lock indicator"
  key_links:
    - from: "folder-tree-item.tsx"
      to: "lockInfo"
      via: "Lock state prop"
      pattern: "isLocked|lockHolder"
---

<objective>
Fix lock indicator: when one user edits a document, other users don't see the lock icon in their tree.

Purpose: Users need visual feedback in the tree showing which documents are being edited by others.

Output: Real-time lock indicators on tree items showing editing status.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/05-document-locking/05-02-SUMMARY.md
@electron-app/src/renderer/components/knowledge/folder-tree-item.tsx
@electron-app/src/renderer/hooks/use-document-lock.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add useDocumentLockStatus hook to existing use-document-lock.ts</name>
  <files>electron-app/src/renderer/hooks/use-document-lock.ts</files>
  <action>
The existing useDocumentLock hook in use-document-lock.ts is for acquiring/managing locks. We need to ADD a new export to the SAME FILE for querying lock status for display in the tree.

**This task EXTENDS the existing use-document-lock.ts file - do not create a new file.**

Add a useDocumentLockStatus hook as a new export:

```tsx
/**
 * Query lock status for a document (read-only, for display)
 * This is a SEPARATE hook from useDocumentLock which is for acquiring locks.
 */
export function useDocumentLockStatus(documentId: string | null): {
  isLocked: boolean
  lockHolder: { userId: string; userName: string } | null
  isLoading: boolean
} {
  const queryClient = useQueryClient()

  // Query lock status from cache or API
  const { data, isLoading } = useQuery({
    queryKey: queryKeys.documentLock(documentId ?? ''),
    queryFn: async () => {
      if (!documentId) return null
      const response = await api.get(`/documents/${documentId}/lock`)
      return response.data // { locked_by_user_id, locked_by_user_name, ... } or null
    },
    enabled: !!documentId,
    staleTime: 10_000, // 10 seconds
    refetchInterval: 30_000, // Poll every 30s as fallback
  })

  return {
    isLocked: !!data?.locked_by_user_id,
    lockHolder: data?.locked_by_user_id
      ? { userId: data.locked_by_user_id, userName: data.locked_by_user_name || 'Unknown' }
      : null,
    isLoading,
  }
}
```

Alternatively, use a batch approach that fetches lock status for multiple documents at once (more efficient for trees).

For this plan, add a simple per-document query. Optimization can come later.

Also add WebSocket subscription to update lock status in real-time:
- Listen for DOCUMENT_LOCKED and DOCUMENT_UNLOCKED messages
- Update the query cache when received

```tsx
// In useDocumentLockStatus or a separate effect
useEffect(() => {
  if (!documentId) return

  const unsubscribe = subscribe((message) => {
    if (message.type === MessageType.DOCUMENT_LOCKED && message.data.document_id === documentId) {
      queryClient.setQueryData(queryKeys.documentLock(documentId), {
        locked_by_user_id: message.data.user_id,
        locked_by_user_name: message.data.user_name,
      })
    }
    if (message.type === MessageType.DOCUMENT_UNLOCKED && message.data.document_id === documentId) {
      queryClient.setQueryData(queryKeys.documentLock(documentId), null)
    }
  })

  return unsubscribe
}, [documentId, subscribe, queryClient])
```
  </action>
  <verify>
Run `npm run typecheck` - zero errors.
Grep for "useDocumentLockStatus" in use-document-lock.ts - should find the new hook export.
  </verify>
  <done>
useDocumentLockStatus hook exists as a new export in use-document-lock.ts for querying lock status with WebSocket updates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire lock status to FolderTreeItem</name>
  <files>electron-app/src/renderer/components/knowledge/folder-tree-item.tsx</files>
  <action>
The FolderTreeItem component already has props for isLocked and lockHolderName (from 02.1-02 SUMMARY).

Current props (verify):
```tsx
interface FolderTreeItemProps {
  ...
  isLocked?: boolean
  lockHolderName?: string
}
```

The issue is these props aren't being populated with real data.

Two approaches:
A) Pass lock data from parent (FolderTree queries all locks, passes down)
B) Each tree item queries its own lock (simpler, less efficient)

For simplicity, implement option B for now:

```tsx
export function FolderTreeItem({
  node,
  type,
  ...
}: FolderTreeItemProps): JSX.Element {
  // Query lock status for documents
  const { isLocked, lockHolder } = useDocumentLockStatus(
    type === 'document' ? node.id : null
  )

  // In render, show lock icon when locked
  return (
    <div ...>
      {/* Document icon or folder icon */}
      {type === 'document' ? (
        <FileText className="..." />
      ) : (
        <Folder className="..." />
      )}

      {/* Name */}
      <span className="truncate">
        {type === 'document' ? (node as DocumentListItem).title : (node as FolderTreeNode).name}
      </span>

      {/* Lock indicator */}
      {type === 'document' && isLocked && (
        <span title={`Editing: ${lockHolder?.userName || 'Someone'}`}>
          <Lock className="h-3 w-3 text-amber-500 ml-auto shrink-0" />
        </span>
      )}
    </div>
  )
}
```

Note: The props-based approach (isLocked/lockHolderName passed from parent) may already exist. If so, the issue is that the parent isn't providing real data. In that case:

Option: In FolderTree/ApplicationTree, query lock status for all visible documents and pass to items:
```tsx
// Get all document IDs in the tree
const documentIds = [...unfiledDocs.map(d => d.id), ...getAllDocsFromFolders(folders)]

// Batch query lock status (needs new hook)
const lockStatuses = useDocumentLockStatuses(documentIds)

// Pass to each item
<FolderTreeItem
  ...
  isLocked={type === 'document' && lockStatuses[node.id]?.isLocked}
  lockHolderName={lockStatuses[node.id]?.lockHolder?.userName}
/>
```

For this plan, use the per-item query approach (simpler) since tree items are already rendered.
  </action>
  <verify>
Run `npm run typecheck` - zero errors.
Grep for "useDocumentLockStatus" in folder-tree-item.tsx - should find usage.
Grep for "Lock" icon import - should find it.
  </verify>
  <done>
FolderTreeItem shows lock icon when document is being edited by another user.
  </done>
</task>

<task type="auto">
  <name>Task 3: Ensure WebSocket broadcasts lock events to tree viewers</name>
  <files>electron-app/src/renderer/hooks/use-websocket.ts (or relevant WebSocket hook)</files>
  <action>
Verify the WebSocket system broadcasts DOCUMENT_LOCKED and DOCUMENT_UNLOCKED events to users viewing the same scope.

From Phase 5 (document-locking), the backend should already broadcast these events. Verify:

1. Check MessageType enum includes DOCUMENT_LOCKED and DOCUMENT_UNLOCKED
2. Check the useWebSocketCacheInvalidation hook (or similar) handles these message types

If not already handled:
```tsx
// In the WebSocket cache invalidation hook
case MessageType.DOCUMENT_LOCKED:
case MessageType.DOCUMENT_UNLOCKED:
  // Invalidate the specific document's lock query
  queryClient.invalidateQueries({
    queryKey: queryKeys.documentLock(message.data.document_id)
  })
  break
```

Also verify users are joined to the appropriate room to receive these events:
- Application room: WebSocketClient.getApplicationRoom(appId)
- Project room: WebSocketClient.getProjectRoom(projectId)
- Document room: WebSocketClient.getDocumentRoom(docId) (if exists)

The lock events should be broadcast to the document's scope room (application or project room) so all viewers see updates.

If needed, add subscription in the Notes page / Knowledge panels to join relevant rooms.
  </action>
  <verify>
Grep for "DOCUMENT_LOCKED" in the WebSocket/hooks files - should find handling.
Grep for "DOCUMENT_UNLOCKED" - should find handling.
  </verify>
  <done>
WebSocket broadcasts lock status changes and tree items update in real-time.
  </done>
</task>

</tasks>

<verification>
1. `cd electron-app && npm run typecheck` passes
2. useDocumentLockStatus hook exists in use-document-lock.ts
3. FolderTreeItem uses lock status to show indicator
4. WebSocket handles lock/unlock events
</verification>

<success_criteria>
- When User A opens a document, User B sees a lock icon appear on that document in their tree
- Hovering over the lock icon shows who is editing
- When User A stops editing, the lock icon disappears for User B
- Lock state updates happen in real-time via WebSocket
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-13-SUMMARY.md`
</output>
