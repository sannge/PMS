---
phase: 02.1-onenote-knowledge-tree-redesign
plan: 11
type: execute
wave: 2
depends_on: ["02.1-06"]
files_modified:
  - electron-app/src/renderer/components/knowledge/search-bar.tsx
  - electron-app/src/renderer/components/knowledge/folder-tree.tsx
  - electron-app/src/renderer/components/knowledge/application-tree.tsx
  - electron-app/src/renderer/contexts/knowledge-base-context.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Search bar filters documents in the tree as user types"
    - "Search results appear in tree in real-time"
    - "Global toggle changes placeholder text (backend search is Phase 9 scope)"
  artifacts:
    - path: "electron-app/src/renderer/components/knowledge/folder-tree.tsx"
      provides: "Tree filtered by search query"
  key_links:
    - from: "folder-tree.tsx"
      to: "searchQuery"
      via: "Context filter"
      pattern: "searchQuery.*filter"
---

<objective>
Fix search functionality: search bar toggle works but doesn't actually filter/search documents.

Purpose: Users need to search and find documents by name within the current scope. Local (client-side) search is the PRIMARY fix for this gap. Global search toggle is UI-only for now; backend full-text search is Phase 9 scope.

Output: Working LOCAL search that filters the document tree as user types.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@electron-app/src/renderer/components/knowledge/search-bar.tsx
@electron-app/src/renderer/components/knowledge/folder-tree.tsx
@electron-app/src/renderer/contexts/knowledge-base-context.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire search query to filter folder tree items</name>
  <files>electron-app/src/renderer/components/knowledge/folder-tree.tsx</files>
  <action>
The SearchBar updates searchQuery in context, but the tree components don't use it to filter.

Add filtering logic to FolderTree:

1. Get searchQuery from context:
   ```tsx
   const { ..., searchQuery } = useKnowledgeBase()
   ```

2. Create a filter function for matching:
   ```tsx
   const matchesSearch = useCallback((text: string): boolean => {
     if (!searchQuery) return true
     return text.toLowerCase().includes(searchQuery.toLowerCase())
   }, [searchQuery])
   ```

3. Filter folders recursively (keep folder if it or any descendant matches):
   ```tsx
   const filterFolderTree = useCallback((nodes: FolderTreeNode[]): FolderTreeNode[] => {
     if (!searchQuery) return nodes

     return nodes.reduce<FolderTreeNode[]>((acc, node) => {
       const filteredChildren = filterFolderTree(node.children)
       const hasMatchingChildren = filteredChildren.length > 0
       const nodeMatches = matchesSearch(node.name)

       if (nodeMatches || hasMatchingChildren) {
         acc.push({
           ...node,
           children: filteredChildren,
         })
       }
       return acc
     }, [])
   }, [searchQuery, matchesSearch])
   ```

4. Filter documents:
   ```tsx
   const filteredDocs = useMemo(() => {
     if (!searchQuery) return unfiledDocs
     return unfiledDocs.filter(doc => matchesSearch(doc.title))
   }, [unfiledDocs, searchQuery, matchesSearch])
   ```

5. Use filtered data in render:
   ```tsx
   const filteredFolders = filterFolderTree(folders)
   // Use filteredFolders instead of folders
   // Use filteredDocs instead of unfiledDocs

   const isEmpty = filteredFolders.length === 0 && filteredDocs.length === 0
   ```

6. Update empty state to show "No results" when searching:
   ```tsx
   if (isEmpty) {
     return (
       <div className="flex flex-col items-center justify-center p-6 text-center">
         <p className="text-sm text-muted-foreground mb-3">
           {searchQuery ? 'No results found' : 'No documents yet'}
         </p>
         {!searchQuery && (
           <button onClick={handleCreateFirstDocument} ...>
             Create your first document
           </button>
         )}
       </div>
     )
   }
   ```

7. Auto-expand folders that have matching children when searching:
   ```tsx
   // When search query changes, expand folders with matches
   useEffect(() => {
     if (!searchQuery) return

     const expandMatchingFolders = (nodes: FolderTreeNode[]) => {
       nodes.forEach(node => {
         if (node.children.length > 0) {
           // If any child or descendant matches, expand this folder
           const hasMatchInSubtree = node.children.some(child =>
             matchesSearch(child.name) || child.children.length > 0
           )
           if (hasMatchInSubtree) {
             expandFolder(node.id)
           }
           expandMatchingFolders(node.children)
         }
       })
     }

     expandMatchingFolders(folders)
   }, [searchQuery, folders, matchesSearch, expandFolder])
   ```
  </action>
  <verify>
Run `npm run typecheck` - zero errors.
Grep for "searchQuery" in folder-tree.tsx - should find filtering logic.
Grep for "matchesSearch" - should find the filter function.
  </verify>
  <done>
FolderTree filters items based on search query, showing only matching folders/documents.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire search query to filter ApplicationTree</name>
  <files>electron-app/src/renderer/components/knowledge/application-tree.tsx</files>
  <action>
Apply the same filtering pattern to ApplicationTree:

1. Get searchQuery from context:
   ```tsx
   const { ..., searchQuery } = useKnowledgeBase()
   ```

2. Add the same matchesSearch and filterFolderTree functions.

3. Filter app-level folders and documents:
   ```tsx
   const filteredFolders = filterFolderTree(folders)
   const filteredDocs = useMemo(() => {
     if (!searchQuery) return unfiledDocs
     return unfiledDocs.filter(doc => matchesSearch(doc.title))
   }, [unfiledDocs, searchQuery, matchesSearch])
   ```

4. For project sections, pass searchQuery down to ProjectSection:
   ```tsx
   <ProjectSection
     ...
     searchQuery={searchQuery}
   />
   ```

5. In ProjectSection, filter the project's folders and docs similarly.

6. Hide project sections that have no matches when searching:
   ```tsx
   // In ProjectSection render
   if (searchQuery && filteredFolders.length === 0 && filteredDocs.length === 0) {
     return null // Hide section when searching and no matches
   }
   ```

7. Update empty state:
   ```tsx
   if (isEmpty) {
     return (
       <div className="flex flex-col items-center justify-center p-6 text-center">
         <p className="text-sm text-muted-foreground mb-3">
           {searchQuery ? 'No results found' : 'No documents yet'}
         </p>
         ...
       </div>
     )
   }
   ```
  </action>
  <verify>
Run `npm run typecheck` - zero errors.
Grep for "searchQuery" in application-tree.tsx - should find filtering logic.
  </verify>
  <done>
ApplicationTree filters items based on search query, including project sections.
  </done>
</task>

<task type="auto">
  <name>Task 3: Clarify global search toggle is UI-only for now</name>
  <files>electron-app/src/renderer/contexts/knowledge-base-context.tsx, electron-app/src/renderer/components/knowledge/search-bar.tsx</files>
  <action>
The global toggle exists in SearchBar but full backend search is Phase 9 scope. For this gap closure, the global toggle should:
- Change the placeholder text (already implemented)
- Track state in context (for future backend integration)
- Continue using LOCAL client-side filtering within current tab

Implementation:

1. Add isGlobalSearch state to context if not present:
   ```tsx
   // In knowledge-base-context.tsx
   const [isGlobalSearch, setGlobalSearch] = useState(false)
   ```

2. Export it from context:
   ```tsx
   return (
     <KnowledgeBaseContext.Provider value={{
       ...,
       isGlobalSearch,
       setGlobalSearch,
     }}>
       ...
     </KnowledgeBaseContext.Provider>
   )
   ```

3. Update SearchBar to use context state:
   ```tsx
   const { ..., isGlobalSearch, setGlobalSearch } = useKnowledgeBase()

   const handleToggleGlobal = () => {
     setGlobalSearch(!isGlobalSearch)
   }
   ```

4. When global toggle is ON, show different placeholder text:
   ```tsx
   placeholder={isGlobalSearch ? 'Search all documents...' : 'Search in this tab...'}
   ```

5. For now, BOTH modes use the same local filtering. Add a TODO comment for Phase 9:
   ```tsx
   // TODO (Phase 9): When isGlobalSearch is true, call backend search API
   // instead of client-side filtering. For now, local filtering works for both modes.
   ```

The key point is that LOCAL search is the fix for the "search doesn't actually search anything" gap. Global toggle changes the UI but uses the same filtering logic until Phase 9.
  </action>
  <verify>
Run `npm run typecheck` - zero errors.
Grep for "isGlobalSearch" in context and search-bar - should find state management.
Grep for "TODO.*Phase 9" in search-bar.tsx - should find the placeholder comment.
  </verify>
  <done>
Global search toggle state is managed in context. Local search works for both modes. Backend integration deferred to Phase 9.
  </done>
</task>

</tasks>

<verification>
1. `cd electron-app && npm run typecheck` passes
2. Search query filters folder tree items in real-time
3. Empty state shows "No results" when searching
4. Global toggle state is tracked in context
</verification>

<success_criteria>
- Typing in search bar filters documents/folders in the tree (LOCAL filtering)
- Matching items remain visible, non-matching items are hidden
- Folders with matching descendants stay visible and auto-expand
- Empty state shows "No results found" when search has no matches
- Global toggle changes placeholder text (full backend search is Phase 9 scope)
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-onenote-knowledge-tree-redesign/02.1-11-SUMMARY.md`
</output>
