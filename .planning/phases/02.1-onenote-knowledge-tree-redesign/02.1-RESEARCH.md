# Phase 2.1: OneNote-Style Knowledge Tree Redesign - Research

**Researched:** 2026-02-01
**Domain:** React UI architecture, tabbed navigation, tree components, scope-based data fetching
**Confidence:** HIGH

## Summary

This phase redesigns the existing knowledge base sidebar from a dropdown-based scope filter to a OneNote-style tabbed notebook interface, and adds embedded Knowledge tabs to Application and Project detail pages. The research focuses on the existing codebase infrastructure (which is extensive), the Radix UI Tabs component (already installed), scope-constrained drag-and-drop patterns, and the architectural decisions needed to make the tree component reusable across three contexts (Notes page, Application detail, Project detail).

The existing codebase provides strong foundations: `KnowledgeBaseContext` (useReducer for UI state), TanStack Query hooks for all document/folder CRUD, a fully functional `FolderTree` component with context menus and inline rename, and a `DocumentEditor` with locking integration. The primary work is structural -- replacing the `ScopeFilter` dropdown with horizontal tabs, making the tree/editor composable for embedding, and adding a backend endpoint to determine which applications have documents (for auto-managed tabs).

**Primary recommendation:** Refactor the existing `KnowledgeSidebar` into a composable architecture where a new `KnowledgeTabBar` replaces `ScopeFilter`, and extract the tree+editor into a reusable `KnowledgePanel` component that can be embedded in both the Notes page and detail pages with different scope configurations.

## Standard Stack

### Core (Already Installed)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @radix-ui/react-tabs | ^1.1.0 | Horizontal tab navigation | Already in package.json, consistent with project's Radix UI design system |
| @tanstack/react-query | (existing) | Data fetching for tab visibility, folder trees, documents | Already powers all knowledge base data |
| @dnd-kit/core + @dnd-kit/sortable | (existing) | Drag-and-drop within scope boundaries | Already used for kanban boards in the project |
| @radix-ui/react-scroll-area | ^1.1.0 | Scrollable tree areas within tabs | Already installed and used in knowledge sidebar |

### Supporting (Already Installed)
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| lucide-react | (existing) | Icons for tabs, tree items, lock/editing indicators | All UI icons |
| sonner | (existing) | Toast notifications for CRUD errors | Error feedback |
| class-variance-authority | (existing) | Component variant styling | Tab styling variants |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Radix Tabs | Custom div-based tabs | Radix provides accessible keyboard nav, ARIA roles for free. No reason to hand-roll |
| @dnd-kit for tree DnD | react-dnd | @dnd-kit already in the project, well-understood. Would be inconsistent to introduce react-dnd |

**Installation:** No new packages needed. All dependencies are already installed.

## Architecture Patterns

### Recommended Component Structure
```
electron-app/src/renderer/
├── components/knowledge/
│   ├── knowledge-tab-bar.tsx          # NEW: Horizontal tab bar (My Notes + app tabs)
│   ├── knowledge-panel.tsx            # NEW: Reusable tree + editor panel (embeddable)
│   ├── knowledge-tree.tsx             # NEW: OneNote-style tree (replaces folder-tree.tsx visual style)
│   ├── knowledge-tree-item.tsx        # MODIFIED: from folder-tree-item.tsx, remove chevrons, add lock/presence
│   ├── knowledge-sidebar.tsx          # MODIFIED: composes tab-bar + panel instead of scope-filter + tree
│   ├── knowledge-search-bar.tsx       # MODIFIED: from search-bar.tsx, add global toggle
│   ├── folder-tree.tsx                # KEEP (internal, used by knowledge-tree)
│   ├── folder-tree-item.tsx           # KEEP (may be restyled)
│   ├── folder-context-menu.tsx        # KEEP (reused as-is)
│   ├── scope-filter.tsx               # REMOVE (replaced by tab bar)
│   ├── scope-picker-dialog.tsx        # REMOVE (scope inferred from tab position)
│   ├── document-editor.tsx            # KEEP (reused in embedded panels)
│   └── ...other existing files
├── contexts/
│   └── knowledge-base-context.tsx     # MODIFIED: add activeTab state, remove 'all' scope
├── pages/
│   └── notes/
│       └── index.tsx                  # MODIFIED: new layout with tab bar
└── hooks/
    └── use-document-folders.ts        # MODIFIED: add useApplicationsWithDocs hook
```

### Pattern 1: Composable Knowledge Panel
**What:** A single `KnowledgePanel` component that renders tree + editor side by side, parameterized by scope.
**When to use:** Everywhere the knowledge base appears (Notes page tabs, Application Knowledge tab, Project Knowledge tab).
**Example:**
```typescript
// KnowledgePanel - reusable across all three contexts
interface KnowledgePanelProps {
  scope: 'personal' | 'application' | 'project'
  scopeId: string
  // For application scope, shows app-level docs + project folders
  // For project scope, shows only project docs
  // For personal scope, shows user's notes
  showProjectFolders?: boolean  // true for application scope
}

// Usage in Notes page (inside a tab):
<KnowledgePanel scope="application" scopeId={appId} showProjectFolders />

// Usage in Application detail Knowledge tab:
<KnowledgePanel scope="application" scopeId={appId} showProjectFolders />

// Usage in Project detail Knowledge tab:
<KnowledgePanel scope="project" scopeId={projectId} />
```

### Pattern 2: Auto-Managed Tab Visibility
**What:** Tabs appear/disappear based on document existence. Requires a lightweight backend query.
**When to use:** The Notes page tab bar needs to know which applications have documents.
**Example:**
```typescript
// New backend endpoint: GET /api/documents/scopes-with-docs
// Returns: { personal: boolean, applications: [{id, name}] }
// Only returns applications where user has at least one document (any scope under that app)

// Frontend hook:
function useApplicationsWithDocs(): UseQueryResult<AppWithDocs[]> {
  return useQuery({
    queryKey: ['applicationsWithDocs'],
    queryFn: () => fetchApplicationsWithDocs(),
    staleTime: 30_000,
  })
}

// Tab bar renders:
// [My Notes] [App A] [App B]  ← only apps with docs
```

### Pattern 3: Scope Inference from Tree Position
**What:** When creating a document/folder, scope is automatically determined by which tab is active and where in the tree the item is being created.
**When to use:** Replaces the ScopePickerDialog which was needed for the "All Documents" view.
**Example:**
```typescript
// In My Notes tab → always personal scope
// In App tab, root level → application scope
// In App tab, inside project folder → project scope

function inferScope(activeTab: TabInfo, parentFolder?: FolderInfo): ScopeInfo {
  if (activeTab.type === 'personal') {
    return { scope: 'personal', scopeId: userId }
  }
  if (parentFolder?.projectId) {
    return { scope: 'project', scopeId: parentFolder.projectId }
  }
  return { scope: 'application', scopeId: activeTab.applicationId }
}
```

### Pattern 4: OneNote-Style Tree (No Chevrons)
**What:** Tree items expand/collapse on click without visible chevron arrows. Visual hierarchy via indentation only.
**When to use:** The tree view within each tab.
**Example:**
```typescript
// Instead of the current FolderTreeItem with ChevronRight icon:
// - Click folder to expand/collapse (behavior preserved)
// - Remove ChevronRight icon entirely
// - Use indentation (padding-left) for hierarchy
// - Folder icon changes from Folder to FolderOpen when expanded
// - Lock icon and editing user avatar shown inline
```

### Pattern 5: Context Provider Per Embedding
**What:** Each KnowledgePanel instance gets its own KnowledgeBaseProvider with fixed scope.
**When to use:** When embedding in Application/Project detail pages.
**Example:**
```typescript
// Application detail page Knowledge tab:
<KnowledgeBaseProvider initialScope="application" initialScopeId={applicationId}>
  <KnowledgePanel scope="application" scopeId={applicationId} showProjectFolders />
</KnowledgeBaseProvider>

// Project detail page Knowledge tab:
<KnowledgeBaseProvider initialScope="project" initialScopeId={projectId}>
  <KnowledgePanel scope="project" scopeId={projectId} />
</KnowledgeBaseProvider>
```

### Anti-Patterns to Avoid
- **Global state for tab selection:** Tabs on Notes page, Application detail, and Project detail are independent. Don't use a global store; use context providers scoped to each embedding.
- **Fetching all documents to determine tab visibility:** Use a dedicated lightweight endpoint that counts docs per application, not full document lists.
- **Allowing drag between scopes:** The decision explicitly says no cross-scope moves. Enforce this in the DnD accept logic, not just by visual separation.
- **Replacing the existing folder-tree CRUD logic:** The existing `useFolderTree`, `useCreateFolder`, `useRenameFolder`, `useDeleteFolder`, `useDocuments`, `useCreateDocument` hooks are well-tested. Reuse them entirely; only change the UI layer.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Accessible tab navigation | Custom div-based tabs with manual ARIA | Radix Tabs `<Tabs.Root>` + `<Tabs.List>` + `<Tabs.Trigger>` + `<Tabs.Content>` | Radix handles keyboard nav (arrow keys, Home/End), focus management, ARIA roles automatically |
| Scrollable tab overflow | Custom horizontal scroll logic | CSS `overflow-x: auto` on Tabs.List with `scroll-behavior: smooth` | Many apps get horizontal tab scrolling wrong; CSS handles it cleanly |
| Tree keyboard navigation | Custom keyDown handlers for tree | Extend existing tree with `role="tree"` / `role="treeitem"` ARIA pattern (already partially implemented) | The existing tree already has `role="tree"` and `role="treeitem"` |
| Scope-restricted DnD | Custom collision detection per scope | @dnd-kit `accept` function that checks item.data.scope matches droppable.data.scope | @dnd-kit has built-in data payload comparison |
| Auto-tab lifecycle | Polling or WebSocket for tab adds/removes | TanStack Query with `refetchOnWindowFocus` for the `applicationsWithDocs` query + invalidation on document create/delete mutations | Query invalidation on mutation already works throughout the app |

**Key insight:** The existing infrastructure handles 90% of the data layer. The work is almost entirely in UI composition and layout restructuring.

## Common Pitfalls

### Pitfall 1: Multiple KnowledgeBaseProviders Fighting Over localStorage
**What goes wrong:** Each KnowledgePanel instance reads/writes the same localStorage keys for sidebar collapsed state, expanded folders, and scope. When embedded in detail pages, they overwrite each other.
**Why it happens:** The current KnowledgeBaseProvider uses hardcoded localStorage keys (`kb-sidebar-collapsed`, `kb-expanded-folders`, `kb-scope`, `kb-scope-id`).
**How to avoid:** Namespace localStorage keys by context. Pass a `storagePrefix` prop to KnowledgeBaseProvider (e.g., `kb-notes-`, `kb-app-{id}-`, `kb-project-{id}-`). Or better: for embedded panels, skip localStorage persistence entirely since they always have a fixed scope.
**Warning signs:** Expanding a folder in the Notes page causes the same folder to appear expanded in the Application Knowledge tab.

### Pitfall 2: Application Tab Showing Stale After Document Delete
**What goes wrong:** User deletes the last document in an application. The tab should disappear but remains visible.
**Why it happens:** The `applicationsWithDocs` query is not invalidated when documents are deleted.
**How to avoid:** In the `useDeleteDocument` mutation's `onSuccess`, also invalidate the `applicationsWithDocs` query key. Same for `useCreateDocument` (tab should appear).
**Warning signs:** Empty tabs that persist after deleting all documents.

### Pitfall 3: Project Folders Mixed With User Folders in Application Tab
**What goes wrong:** In the Application tab, auto-generated project folders and user-created app-level folders appear jumbled together with no visual distinction.
**Why it happens:** Both are returned by the same folder tree endpoint and have the same visual treatment.
**How to avoid:** The backend folder tree for application scope should return a structured response that separates app-level folders/docs from project-scoped items. Auto-generated project folders should have a visual indicator (different icon, label, or section separator). The decision says "Claude's discretion" on how to visually distinguish them.
**Warning signs:** Users create a folder named "Project Alpha" next to an auto-generated "Project Alpha" folder, causing confusion.

### Pitfall 4: Document Editor Re-mounting on Tab Switch
**What goes wrong:** Switching tabs causes the TipTap editor to unmount and remount, losing unsaved changes and cursor position.
**Why it happens:** React unmounts the previous tab's content when switching to a new tab. Radix Tabs has `forceMount` but it's not the default.
**How to avoid:** Use Radix Tabs with `forceMount` on `Tabs.Content` to keep inactive tabs in the DOM but hidden. Alternatively, lift the editor state above the tabs and only switch the tree. A simpler approach: the Notes page shows tree in left panel, editor in right panel. Tab switches change the tree only, not the editor. Editor shows the selected document regardless of which tab it came from.
**Warning signs:** Auto-save fires on tab switch, user loses cursor position.

### Pitfall 5: "My Notes" Tab Always Present Even When Empty
**What goes wrong:** Not a bug per the decision (My Notes is always the first tab), but the empty state needs handling.
**Why it happens:** My Notes tab is always visible unlike application tabs.
**How to avoid:** Design an inviting empty state for My Notes that encourages document creation. Application tabs auto-manage visibility so they never show empty.
**Warning signs:** Cluttered UI with empty My Notes tab competing for attention.

### Pitfall 6: Application Tab Tree Needs Mixed-Scope Fetching
**What goes wrong:** The Application tab needs to show app-scoped folders/docs AND project-scoped folders/docs for all projects under that app, but the current folder tree endpoint only fetches one scope at a time.
**Why it happens:** `GET /api/document-folders/tree?scope=application&scope_id={id}` only returns application-scoped folders.
**How to avoid:** Either (a) create a new backend endpoint `GET /api/document-folders/tree/application-full?application_id={id}` that returns app-scoped items + project folders with their contents, or (b) on the frontend, fetch app-scoped tree + fetch projects list + lazy-fetch each project's tree when expanded. Option (b) is more aligned with existing patterns and avoids a new backend endpoint.
**Warning signs:** Application tab only shows app-level docs, missing all project docs.

## Code Examples

### Example 1: Radix Tabs Component (shadcn/ui pattern)
```typescript
// components/ui/tabs.tsx (new file, shadcn/ui pattern)
import * as TabsPrimitive from '@radix-ui/react-tabs'
import { cn } from '@/lib/utils'
import { forwardRef } from 'react'

const Tabs = TabsPrimitive.Root

const TabsList = forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      'inline-flex h-9 items-center gap-1 border-b border-border px-2',
      'overflow-x-auto scrollbar-none',
      className
    )}
    {...props}
  />
))

const TabsTrigger = forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      'inline-flex items-center gap-1.5 whitespace-nowrap px-3 py-1.5',
      'text-sm font-medium text-muted-foreground',
      'border-b-2 border-transparent',
      'transition-colors hover:text-foreground',
      'data-[state=active]:text-foreground data-[state=active]:border-primary',
      'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring',
      className
    )}
    {...props}
  />
))

const TabsContent = TabsPrimitive.Content

export { Tabs, TabsList, TabsTrigger, TabsContent }
```

### Example 2: Knowledge Tab Bar (Auto-Managed Tabs)
```typescript
// components/knowledge/knowledge-tab-bar.tsx
interface KnowledgeTabBarProps {
  activeTab: string  // 'personal' | `app:${id}`
  onTabChange: (tab: string) => void
  applicationsWithDocs: Array<{ id: string; name: string }>
}

function KnowledgeTabBar({ activeTab, onTabChange, applicationsWithDocs }: KnowledgeTabBarProps) {
  return (
    <Tabs value={activeTab} onValueChange={onTabChange}>
      <TabsList>
        <TabsTrigger value="personal">
          <User className="h-3.5 w-3.5" />
          My Notes
        </TabsTrigger>
        {applicationsWithDocs.map(app => (
          <TabsTrigger key={app.id} value={`app:${app.id}`}>
            <Building2 className="h-3.5 w-3.5" />
            {app.name}
          </TabsTrigger>
        ))}
      </TabsList>
    </Tabs>
  )
}
```

### Example 3: Scope-Restricted DnD Accept Function
```typescript
// Drag-and-drop within same scope only
function canDrop(active: Active, over: Over): boolean {
  const activeScope = active.data.current?.scope
  const activeScopeId = active.data.current?.scopeId
  const overScope = over.data.current?.scope
  const overScopeId = over.data.current?.scopeId

  // Must be same scope type AND same scope ID
  return activeScope === overScope && activeScopeId === overScopeId
}
```

### Example 4: Application Tab Mixed Tree (Frontend Composition)
```typescript
// Application tab tree shows:
// 1. App-level folders/docs (fetched with scope=application)
// 2. Auto-generated project folder entries (fetched from useProjects)
// 3. Inside each project folder: project-scoped folders/docs (lazy-fetched)

function ApplicationTree({ applicationId }: { applicationId: string }) {
  // App-level tree
  const { data: appFolders } = useFolderTree('application', applicationId)
  const { data: appDocs } = useDocuments('application', applicationId, { includeUnfiled: true })

  // Projects that belong to this application
  const { data: projects } = useProjects(applicationId)

  return (
    <div role="tree">
      {/* App-level folders and docs */}
      {appFolders?.map(folder => <FolderNode key={folder.id} ... />)}
      {appDocs?.items.map(doc => <DocNode key={doc.id} ... />)}

      {/* Auto-generated project sections */}
      {projects?.map(project => (
        <ProjectSection key={project.id} project={project} />
      ))}
    </div>
  )
}

// ProjectSection lazy-loads its folder tree on expand
function ProjectSection({ project }: { project: Project }) {
  const [isExpanded, setIsExpanded] = useState(false)
  // Only fetch when expanded
  const { data: projectFolders } = useFolderTree('project', project.id, { enabled: isExpanded })

  return (
    <div>
      <div onClick={() => setIsExpanded(!isExpanded)}>
        <FolderKanban className="h-4 w-4" /> {/* Distinguished icon */}
        {project.name}
      </div>
      {isExpanded && projectFolders?.map(folder => <FolderNode ... />)}
    </div>
  )
}
```

### Example 5: Backend Endpoint for Applications With Documents
```python
# New endpoint in documents.py or a new router
@router.get("/scopes-summary")
async def get_scopes_summary(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
) -> dict:
    """Return which scopes have documents for the current user's accessible apps."""
    # Personal docs exist?
    personal_count = await db.scalar(
        select(func.count(Document.id))
        .where(Document.user_id == current_user.id)
        .where(Document.deleted_at.is_(None))
    )

    # Applications with docs (app-scoped or project-scoped under app)
    # Join through Application membership
    apps_with_docs = await db.execute(
        select(Application.id, Application.name)
        .join(ApplicationMember, ApplicationMember.application_id == Application.id)
        .where(ApplicationMember.user_id == current_user.id)
        .where(
            exists(
                select(Document.id)
                .where(
                    or_(
                        Document.application_id == Application.id,
                        Document.project_id.in_(
                            select(Project.id).where(Project.application_id == Application.id)
                        ),
                    )
                )
                .where(Document.deleted_at.is_(None))
            )
        )
        .order_by(Application.created_at.asc())
    )

    return {
        "has_personal_docs": personal_count > 0,
        "applications": [{"id": str(r.id), "name": r.name} for r in apps_with_docs.all()],
    }
```

### Example 6: Embedding Knowledge Tab in Application Detail Page
```typescript
// In pages/applications/[id].tsx, add a new tab alongside Projects and Archive:
// [Projects] [Archive] [Knowledge]

// The Knowledge tab content:
function ApplicationKnowledgeTab({ applicationId }: { applicationId: string }) {
  return (
    <KnowledgeBaseProvider
      initialScope="application"
      initialScopeId={applicationId}
      storagePrefix={`kb-app-${applicationId}-`}
    >
      <div className="flex h-full">
        {/* Left: Tree */}
        <div className="w-64 border-r border-border">
          <SearchBar />
          <ScrollArea className="flex-1">
            <ApplicationTree applicationId={applicationId} />
          </ScrollArea>
        </div>
        {/* Right: Inline editor */}
        <div className="flex-1">
          <SelectedDocumentEditor />
        </div>
      </div>
    </KnowledgeBaseProvider>
  )
}
```

## State of the Art

| Old Approach (Phase 2) | New Approach (Phase 2.1) | Impact |
|------------------------|--------------------------|--------|
| Dropdown scope filter (All/My Notes/App/Project) | Horizontal tabs (My Notes + per-app) | Scope is spatial, not dropdown-selected |
| "All Documents" view across scopes | No "All" view; each tab is one scope | Simpler mental model, no ScopePickerDialog needed |
| Single sidebar on Notes page only | Reusable panel: Notes page + App detail + Project detail | Same component in three places |
| Chevron arrows on folder items | Click-to-expand without chevrons (OneNote style) | Cleaner visual, more list-like than tree-like |
| No lock/presence indicators in tree | Lock icon + editing user avatar in tree items | Users see who's editing without opening the doc |

**Deprecated/removed:**
- `ScopeFilter` component: Replaced by tab bar
- `ScopePickerDialog` component: No longer needed (scope inferred from tab/tree position)
- `'all'` scope type: Removed from KnowledgeBaseContext (no "All Documents" view)

## Open Questions

1. **Backend endpoint for mixed application tree**
   - What we know: The Application tab needs to show app-scoped folders + project folders with project-scoped docs. Current `/tree` endpoint only supports one scope at a time.
   - What's unclear: Whether to create a new combined endpoint or compose on the frontend with multiple queries.
   - Recommendation: Use frontend composition (multiple queries) to avoid new backend endpoints. Fetch app-level tree + projects list, then lazy-fetch each project's tree on expand. This matches existing patterns and keeps the backend simple. If performance is an issue (many projects), add a combined endpoint later.

2. **How project folders are visually distinguished**
   - What we know: Decision says "Claude's discretion" on visual distinction.
   - What's unclear: Exact styling choice.
   - Recommendation: Use `FolderKanban` icon (already used for projects throughout the app) instead of `Folder` icon for auto-generated project folders. Add a subtle label like "Project" in smaller text. Use a slightly different background color or left border accent on project folder rows.

3. **Search "global toggle" behavior**
   - What we know: Decision says search defaults to current tab with a toggle to search across all tabs.
   - What's unclear: Whether global search hits a different backend endpoint or searches client-side across cached data.
   - Recommendation: For current-tab search, use the existing Meilisearch integration scoped to the active tab's scope. For global search, call the same Meilisearch endpoint without scope filters. Display results grouped by tab/scope.

4. **Tag filter placement in new design**
   - What we know: The existing sidebar has a tag filter list at the bottom. The decision doesn't explicitly address tags.
   - What's unclear: Whether tags remain in each tab's tree panel or are removed.
   - Recommendation: Keep the tag filter at the bottom of each tab's tree panel. Tags are scope-specific (application-scoped tags), so they naturally filter within the current tab's scope.

5. **Editor panel across tab switches**
   - What we know: Switching tabs changes the tree view. The editor shows the selected document.
   - What's unclear: Should the editor clear when switching tabs (losing context) or persist the last-selected document?
   - Recommendation: Clear the editor selection when switching tabs. The user is mentally switching context, so showing a document from a different tab would be confusing. Show the "Select a document to start editing" placeholder when switching tabs.

## Existing Infrastructure Inventory

### Components to REUSE (no changes needed)
- `FolderContextMenu` - right-click menu for tree items
- `DocumentEditor` - TipTap editor with locking
- `EditorToolbar` - toolbar for editor
- `SaveStatus` - auto-save indicator
- `LockBanner` - document lock indicator
- `editor-extensions.ts` - TipTap extension factory
- `editor-styles.css` - editor CSS

### Components to MODIFY
- `knowledge-sidebar.tsx` - replace ScopeFilter with tab bar, restructure layout
- `knowledge-base-context.tsx` - add activeTab state, remove 'all' scope, add storagePrefix
- `folder-tree.tsx` - extract into reusable form, support mixed app+project tree
- `folder-tree-item.tsx` - remove chevrons, add lock/presence indicators
- `search-bar.tsx` - add global search toggle
- `pages/notes/index.tsx` - new layout with tabs
- `pages/applications/[id].tsx` - add Knowledge tab
- `pages/projects/[id].tsx` - add Knowledge tab

### Components to REMOVE
- `scope-filter.tsx` - replaced by tab bar
- `scope-picker-dialog.tsx` - no longer needed

### Hooks to REUSE (no changes needed)
- `use-document-folders.ts` - all folder CRUD hooks
- `use-documents.ts` - all document CRUD hooks
- `use-document-tags.ts` - tag fetching
- `use-document-lock.ts` - document locking

### Hooks to ADD
- `useApplicationsWithDocs` - new hook for tab auto-management

### Backend to ADD
- `GET /api/documents/scopes-summary` - lightweight endpoint returning which scopes have documents

### Backend to REUSE (no changes)
- `GET /api/document-folders/tree` - folder tree per scope
- `GET /api/documents` - document list per scope
- All existing CRUD endpoints

## Sources

### Primary (HIGH confidence)
- Codebase analysis: Direct reading of all existing knowledge base components, hooks, context, backend routers
- `@radix-ui/react-tabs` ^1.1.0 - confirmed installed in package.json
- `@dnd-kit` - confirmed installed and used in kanban components

### Secondary (MEDIUM confidence)
- Radix UI Tabs API - based on training data knowledge of Radix Tabs component (API is stable and well-known)
- shadcn/ui Tabs pattern - standard wrapper pattern consistent with other shadcn/ui components already in the project

### Tertiary (LOW confidence)
- None. All findings are based on direct codebase inspection.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - all libraries already installed, no new dependencies
- Architecture: HIGH - patterns derived directly from existing codebase conventions
- Pitfalls: HIGH - identified from actual code inspection (localStorage conflicts, mixed scope fetching, query invalidation)

**Research date:** 2026-02-01
**Valid until:** 2026-03-01 (stable - no external dependency changes expected)
