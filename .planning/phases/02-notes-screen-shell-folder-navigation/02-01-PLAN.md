---
phase: 02-notes-screen-shell-folder-navigation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - electron-app/src/renderer/lib/query-client.ts
  - electron-app/src/renderer/lib/cache-config.ts
  - electron-app/src/renderer/hooks/use-documents.ts
  - electron-app/src/renderer/hooks/use-document-folders.ts
  - electron-app/src/renderer/hooks/use-document-tags.ts
  - electron-app/src/renderer/contexts/knowledge-base-context.tsx
  - electron-app/src/renderer/pages/notes/index.tsx
  - electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
  - electron-app/src/renderer/components/knowledge/search-bar.tsx
  - electron-app/src/renderer/pages/dashboard.tsx
autonomous: true

must_haves:
  truths:
    - "Notes screen renders with a left sidebar and main content area"
    - "Search bar appears at the top of the sidebar"
    - "KnowledgeBaseContext provides scope, expanded folders, selected document, and sidebar state to all child components"
    - "TanStack Query hooks for documents, folders, and tags fetch data from Phase 1 APIs"
    - "Folder tree query data is persisted to IndexedDB via existing per-query-persister (deferred hydration)"
    - "Document query data is persisted to IndexedDB via existing per-query-persister (on-demand hydration)"
  artifacts:
    - path: "electron-app/src/renderer/contexts/knowledge-base-context.tsx"
      provides: "UI-only state for Notes screen (scope, expanded folders, sidebar, selection)"
      exports: ["KnowledgeBaseProvider", "useKnowledgeBase"]
    - path: "electron-app/src/renderer/hooks/use-document-folders.ts"
      provides: "TanStack Query hooks for folder tree (useFolderTree, useCreateFolder, useRenameFolder, useMoveFolder, useDeleteFolder)"
      exports: ["useFolderTree", "useCreateFolder", "useRenameFolder", "useMoveFolder", "useDeleteFolder"]
    - path: "electron-app/src/renderer/hooks/use-documents.ts"
      provides: "TanStack Query hooks for documents (useDocuments, useDocument, useCreateDocument, useRenameDocument, useMoveDocument, useDeleteDocument)"
      exports: ["useDocuments", "useDocument", "useCreateDocument", "useRenameDocument", "useMoveDocument", "useDeleteDocument"]
    - path: "electron-app/src/renderer/hooks/use-document-tags.ts"
      provides: "TanStack Query hooks for tags (useDocumentTags)"
      exports: ["useDocumentTags"]
    - path: "electron-app/src/renderer/pages/notes/index.tsx"
      provides: "Notes screen shell with sidebar + content layout"
      contains: "KnowledgeBaseProvider"
    - path: "electron-app/src/renderer/lib/query-client.ts"
      provides: "Query key definitions for documents, folders, tags"
      contains: "documentFolders"
    - path: "electron-app/src/renderer/lib/cache-config.ts"
      provides: "Hydration priority config for document/folder caching"
      contains: "documentFolders"
  key_links:
    - from: "electron-app/src/renderer/hooks/use-document-folders.ts"
      to: "electron-app/src/renderer/lib/query-client.ts"
      via: "queryKeys.documentFolders"
      pattern: "queryKeys\\.documentFolders"
    - from: "electron-app/src/renderer/pages/notes/index.tsx"
      to: "electron-app/src/renderer/contexts/knowledge-base-context.tsx"
      via: "KnowledgeBaseProvider wrapping page content"
      pattern: "KnowledgeBaseProvider"
    - from: "electron-app/src/renderer/lib/cache-config.ts"
      to: "electron-app/src/renderer/lib/per-query-persister.ts"
      via: "HYDRATION_PRIORITY.deferred includes documentFolders"
      pattern: "documentFolders"
---

<objective>
Create the Notes screen foundation: KnowledgeBaseContext for UI state, TanStack Query hooks for documents/folders/tags with IndexedDB cache integration, the Notes page shell with sidebar layout, and a debounced search bar.

Purpose: This plan establishes the data layer and layout shell that Plans 02 and 03 build on. Without the context, hooks, and page structure, no sidebar components can function.

Output: A navigable Notes screen with sidebar skeleton, working query hooks that automatically persist to IndexedDB, and a React Context providing shared UI state to all knowledge base components.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@D:\FTX_CODE\pm-project\.planning\PROJECT.md
@D:\FTX_CODE\pm-project\.planning\ROADMAP.md
@D:\FTX_CODE\pm-project\.planning\STATE.md
@D:\FTX_CODE\pm-project\.planning\phases\02-notes-screen-shell-folder-navigation\02-RESEARCH.md
@D:\FTX_CODE\pm-project\.planning\codebase\CONVENTIONS.md
@D:\FTX_CODE\pm-project\electron-app\src\renderer\lib\query-client.ts
@D:\FTX_CODE\pm-project\electron-app\src\renderer\lib\cache-config.ts
@D:\FTX_CODE\pm-project\electron-app\src\renderer\contexts\auth-context.tsx
@D:\FTX_CODE\pm-project\electron-app\src\renderer\hooks\use-queries.ts
@D:\FTX_CODE\pm-project\electron-app\src\renderer\pages\dashboard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Query keys, cache config, and TanStack Query hooks for documents, folders, and tags</name>
  <files>
    electron-app/src/renderer/lib/query-client.ts
    electron-app/src/renderer/lib/cache-config.ts
    electron-app/src/renderer/hooks/use-documents.ts
    electron-app/src/renderer/hooks/use-document-folders.ts
    electron-app/src/renderer/hooks/use-document-tags.ts
  </files>
  <action>
    **1. Add query keys to `query-client.ts`** (add to the `queryKeys` object):

    ```typescript
    // Documents
    documents: (scope: string, scopeId: string) => ['documents', scope, scopeId] as const,
    document: (id: string) => ['document', id] as const,

    // Document Folders
    documentFolders: (scope: string, scopeId: string) => ['documentFolders', scope, scopeId] as const,

    // Document Tags
    documentTags: (scope: string, scopeId: string) => ['documentTags', scope, scopeId] as const,
    ```

    **2. Update HYDRATION_PRIORITY in `cache-config.ts`**:
    - Add `'documentFolders'` to the `deferred` array (folder trees hydrate 2s after app start)
    - Add `'documents'` and `'documentTags'` to the `onDemand` array (loaded when Notes screen opens)

    **3. Create `use-document-folders.ts`** with these exports:
    - TypeScript interfaces: `DocumentFolder` (id, name, parent_id, materialized_path, depth, sort_order, scope fields, timestamps, document_count) and `FolderTreeNode extends DocumentFolder` (children: FolderTreeNode[])
    - `buildFolderTree(folders: DocumentFolder[]): FolderTreeNode[]` -- builds tree from flat folder list using parent_id relationships
    - `useFolderTree(scope, scopeId)` -- useQuery hook that fetches `GET /api/document-folders/tree?scope={scope}&scope_id={scopeId}`, returns FolderTreeNode[]. Use `enabled: !!token && !!scope && (scope === 'all' || scope === 'personal' || !!scopeId)`. staleTime 30s, gcTime 24h.
    - `useCreateFolder()` -- useMutation for `POST /api/document-folders` with body `{name, parent_id?, scope, scope_id?}`. Invalidates documentFolders query on success.
    - `useRenameFolder()` -- useMutation for `PATCH /api/document-folders/{id}` with body `{name}`. Invalidates documentFolders.
    - `useMoveFolder()` -- useMutation for `PATCH /api/document-folders/{id}/move` with body `{parent_id}`. Invalidates documentFolders.
    - `useDeleteFolder()` -- useMutation for `DELETE /api/document-folders/{id}`. Invalidates documentFolders.

    Follow the existing `use-queries.ts` pattern: import `useAuthStore` from `@/stores/auth-store` (or `@/contexts/auth-context` if Phase 1 has migrated it -- check what exists), use `window.electronAPI.get/post/patch/delete` for API calls, and get `token` from auth state.

    **Important:** For `scope === 'personal'`, map to API param `scope=user&scope_id={currentUserId}`. For `scope === 'all'`, either call the endpoint without scope params or handle the "no scope_id" case. The `enabled` check must handle these cases.

    **4. Create `use-documents.ts`** with these exports:
    - TypeScript interfaces: `Document` (id, title, scope, application_id, project_id, user_id, folder_id, content_tiptap, created_at, updated_at, created_by, updated_by, is_deleted, deleted_at) and `DocumentListItem` (subset: id, title, folder_id, updated_at, updated_by_name, tag_ids)
    - `useDocuments(scope, scopeId, options?: { folderId?, tagIds?, search? })` -- useQuery for `GET /api/documents?scope={scope}&scope_id={scopeId}&folder_id={folderId}&tag_ids={tagIds}`. staleTime 30s, gcTime 24h.
    - `useDocument(id)` -- useQuery for `GET /api/documents/{id}`. Returns full document with content. staleTime 30s.
    - `useCreateDocument()` -- useMutation for `POST /api/documents` with body `{title, scope, scope_id?, folder_id?}`. Invalidates documents query on success. Returns the created document.
    - `useRenameDocument()` -- useMutation for `PATCH /api/documents/{id}` with body `{title}`. Invalidates documents.
    - `useMoveDocument()` -- useMutation for `PATCH /api/documents/{id}/move` with body `{folder_id}`. Invalidates documents.
    - `useDeleteDocument()` -- useMutation for `DELETE /api/documents/{id}` (soft delete to trash). Invalidates documents.

    **5. Create `use-document-tags.ts`** with:
    - TypeScript interface: `DocumentTag` (id, name, color?, scope, application_id?, project_id?, created_at)
    - `useDocumentTags(scope, scopeId)` -- useQuery for `GET /api/document-tags?scope={scope}&scope_id={scopeId}`. staleTime 60s, gcTime 24h.

    **Anti-patterns to avoid:**
    - Do NOT add any IndexedDB read/write logic in hook files. The per-query-persister handles all persistence automatically.
    - Do NOT create a "store" pattern with CRUD methods inside the hooks. Each hook is a standalone TanStack Query hook.
    - Do NOT use Zustand anywhere.
  </action>
  <verify>
    - `npm run typecheck` in electron-app passes with no errors
    - `npm run lint` passes with no warnings
    - Grep for `queryKeys.documentFolders` in query-client.ts confirms keys exist
    - Grep for `'documentFolders'` in cache-config.ts confirms HYDRATION_PRIORITY updated
    - All three hook files export the expected functions (grep for export function names)
  </verify>
  <done>
    - query-client.ts has documentFolders, documents, document, documentTags query keys
    - cache-config.ts HYDRATION_PRIORITY.deferred includes 'documentFolders', onDemand includes 'documents' and 'documentTags'
    - use-document-folders.ts exports useFolderTree, useCreateFolder, useRenameFolder, useMoveFolder, useDeleteFolder
    - use-documents.ts exports useDocuments, useDocument, useCreateDocument, useRenameDocument, useMoveDocument, useDeleteDocument
    - use-document-tags.ts exports useDocumentTags
    - All hooks use window.electronAPI for API calls and follow existing patterns
    - TypeScript compiles, lint passes
  </done>
</task>

<task type="auto">
  <name>Task 2: KnowledgeBaseContext, Notes page shell with sidebar layout, and search bar</name>
  <files>
    electron-app/src/renderer/contexts/knowledge-base-context.tsx
    electron-app/src/renderer/pages/notes/index.tsx
    electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
    electron-app/src/renderer/components/knowledge/search-bar.tsx
    electron-app/src/renderer/pages/dashboard.tsx
  </files>
  <action>
    **1. Create `knowledge-base-context.tsx`** following the auth-context.tsx pattern (createContext + useReducer + useCallback):

    State shape:
    ```typescript
    type ScopeType = 'all' | 'personal' | 'application' | 'project'

    interface KnowledgeBaseUIState {
      scope: ScopeType
      scopeId: string | null
      isSidebarCollapsed: boolean
      expandedFolderIds: Set<string>
      selectedDocumentId: string | null
      selectedFolderId: string | null
      searchQuery: string
      activeTagIds: string[]
    }
    ```

    Actions:
    - `SET_SCOPE` -- sets scope and scopeId, clears selectedDocumentId, selectedFolderId, and activeTagIds (prevents stale references across scope switch)
    - `TOGGLE_SIDEBAR` -- toggles isSidebarCollapsed, persists to localStorage
    - `SET_SIDEBAR_COLLAPSED` -- sets isSidebarCollapsed directly
    - `TOGGLE_FOLDER` -- adds/removes folderId from expandedFolderIds Set, persists to localStorage
    - `EXPAND_FOLDER` / `COLLAPSE_FOLDER` -- explicit expand/collapse
    - `SELECT_DOCUMENT` -- sets selectedDocumentId
    - `SELECT_FOLDER` -- sets selectedFolderId
    - `SET_SEARCH` -- sets searchQuery
    - `TOGGLE_TAG` -- adds/removes tagId from activeTagIds
    - `CLEAR_TAGS` -- empties activeTagIds
    - `RESET_SELECTION` -- clears selectedDocumentId, selectedFolderId

    Context value interface:
    ```typescript
    interface KnowledgeBaseContextValue extends KnowledgeBaseUIState {
      setScope: (scope: ScopeType, scopeId: string | null) => void
      toggleSidebar: () => void
      toggleFolder: (folderId: string) => void
      expandFolder: (folderId: string) => void
      collapseFolder: (folderId: string) => void
      selectDocument: (documentId: string | null) => void
      selectFolder: (folderId: string | null) => void
      setSearch: (query: string) => void
      toggleTag: (tagId: string) => void
      clearTags: () => void
      resetSelection: () => void
    }
    ```

    Persistence on mount: Read `isSidebarCollapsed`, `expandedFolderIds` (as JSON array, convert to Set), `scope`, and `scopeId` from localStorage keys prefixed with `kb-`. Write back on changes via useEffect.

    Export: `KnowledgeBaseProvider` (component) and `useKnowledgeBase` (hook with context null check).

    The provider should accept optional `initialScope` and `initialScopeId` props (for when DashboardPage passes an applicationId).

    **2. Create `search-bar.tsx`** in `components/knowledge/`:
    - A controlled input using the shadcn/ui pattern (import Input from `@/components/ui/input`)
    - Search icon (from lucide-react) on the left, X button to clear on the right (visible when query is non-empty)
    - Debounced: use a local state for the input value, then update KnowledgeBaseContext `setSearch` after 300ms of inactivity using `useEffect` with a timeout cleanup
    - Reads/writes `searchQuery` from `useKnowledgeBase()`
    - Placeholder: "Search documents..."
    - Size: compact (h-8) to fit sidebar width

    **3. Create `knowledge-sidebar.tsx`** in `components/knowledge/`:
    - Main sidebar container that composes all sidebar sections
    - Layout:
      ```
      <div className={cn('flex flex-col border-r border-border bg-sidebar h-full', isSidebarCollapsed ? 'w-10' : 'w-64')}>
        {/* Search bar section */}
        <div className="p-2 border-b border-border">
          <SearchBar />
        </div>

        {/* Scope filter section -- PLACEHOLDER for Plan 03 */}
        <div className="px-2 py-1.5 border-b border-border">
          {/* ScopeFilter will go here */}
          <div className="text-xs text-muted-foreground">All Documents</div>
        </div>

        {/* Folder tree section -- PLACEHOLDER for Plan 02 */}
        <ScrollArea className="flex-1">
          {/* FolderTree will go here */}
          <div className="p-2 text-sm text-muted-foreground">Folder tree loading...</div>
        </ScrollArea>

        {/* Tag filter section -- PLACEHOLDER for Plan 03 */}
        <div className="border-t border-border p-2">
          {/* TagFilterList will go here */}
          <div className="text-xs text-muted-foreground">Tags</div>
        </div>
      </div>
      ```
    - Import `ScrollArea` from `@/components/ui/scroll-area`
    - Read `isSidebarCollapsed` from `useKnowledgeBase()`
    - When sidebar is collapsed, show only icon buttons (collapse toggle icon)
    - Add a collapse/expand toggle button at the top (PanelLeftClose / PanelLeftOpen icons from lucide-react)

    **4. Rewrite `pages/notes/index.tsx`** (complete replacement):
    - Wrap everything in `<KnowledgeBaseProvider>` (with optional `initialScope`/`initialScopeId` from props)
    - Accept props: `applicationId?: string` (from DashboardPage state-based navigation)
    - Layout: horizontal flex container, full height
      ```
      <KnowledgeBaseProvider initialScope={applicationId ? 'application' : undefined} initialScopeId={applicationId}>
        <div className="flex h-full">
          <KnowledgeSidebar />
          <main className="flex-1 flex flex-col">
            {/* Main content area -- placeholder for future editor */}
            <div className="flex-1 flex items-center justify-center text-muted-foreground">
              Select a document to start editing
            </div>
          </main>
        </div>
      </KnowledgeBaseProvider>
      ```

    **5. Update `dashboard.tsx`** (minimal change):
    - Find the `case 'notes':` (or equivalent) in the view switching logic
    - Ensure it renders `<NotesPage applicationId={selectedApplicationId} />` where `selectedApplicationId` is the currently selected application ID from dashboard state
    - If the existing import path for NotesPage still works, keep it. If Phase 1 removed the old notes page, update the import.

    **Anti-patterns to avoid:**
    - Do NOT put any data fetching logic in KnowledgeBaseContext. It is UI-only state. Data comes from TanStack Query hooks.
    - Do NOT use Zustand.
    - Do NOT use react-router. Navigation is state-based via DashboardPage.
  </action>
  <verify>
    - `npm run typecheck` passes
    - `npm run lint` passes
    - The Notes page renders without errors when accessed from the dashboard (or confirm the component tree compiles)
    - Grep for `KnowledgeBaseProvider` in pages/notes/index.tsx confirms provider wrapping
    - Grep for `useKnowledgeBase` in knowledge-sidebar.tsx confirms context usage
    - localStorage keys `kb-sidebar-collapsed`, `kb-expanded-folders`, `kb-scope`, `kb-scope-id` are read on mount
  </verify>
  <done>
    - KnowledgeBaseContext exists with all state fields and actions listed above
    - KnowledgeBaseProvider persists sidebar collapsed, expanded folders, scope, and scopeId to localStorage
    - SET_SCOPE action clears selection state (no stale references on scope switch)
    - Notes page renders with KnowledgeBaseProvider wrapping, sidebar on left, content area on right
    - SearchBar renders in sidebar with debounced search updating context
    - KnowledgeSidebar has placeholder sections for scope filter, folder tree, and tags (ready for Plans 02/03)
    - Dashboard.tsx routes to Notes page with applicationId prop
    - TypeScript compiles, lint passes
  </done>
</task>

</tasks>

<verification>
1. `cd electron-app && npm run typecheck` -- zero TypeScript errors
2. `cd electron-app && npm run lint` -- zero warnings
3. All new files exist at their expected paths
4. query-client.ts queryKeys object includes documentFolders, documents, document, documentTags
5. cache-config.ts HYDRATION_PRIORITY includes documentFolders in deferred, documents/documentTags in onDemand
6. KnowledgeBaseContext exports KnowledgeBaseProvider and useKnowledgeBase
7. Notes page wraps content in KnowledgeBaseProvider
8. No Zustand imports anywhere in new files
</verification>

<success_criteria>
- Notes screen layout renders: sidebar (w-64) on left with search bar, placeholder sections, and content area on right
- KnowledgeBaseContext manages scope, sidebar collapsed, expanded folders, selected document, search query, active tags
- Three TanStack Query hook files provide all document/folder/tag data fetching hooks
- Query keys registered in query-client.ts, hydration priority configured in cache-config.ts
- All code follows existing codebase conventions (strict TypeScript, Radix UI components, no Zustand)
</success_criteria>

<output>
After completion, create `.planning/phases/02-notes-screen-shell-folder-navigation/02-01-SUMMARY.md`
</output>
