---
phase: 09-search-templates-export
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - fastapi-backend/app/models/document_template.py
  - fastapi-backend/app/models/__init__.py
  - fastapi-backend/app/schemas/document_template.py
  - fastapi-backend/app/routers/document_templates.py
  - fastapi-backend/app/routers/__init__.py
  - fastapi-backend/app/main.py
  - fastapi-backend/alembic/versions/20260201_add_document_templates.py
  - electron-app/src/renderer/lib/query-client.ts
  - electron-app/src/renderer/hooks/use-document-templates.ts
  - electron-app/src/renderer/components/knowledge/template-picker.tsx
autonomous: true

must_haves:
  truths:
    - "User can create a new document from one of 5 built-in templates (Meeting Notes, Design Doc, Decision Record, Project Brief, Sprint Retrospective)"
    - "User can save any existing document as a custom template"
    - "User can create a new document from a custom template"
    - "Built-in templates are available to all users; custom templates are scoped to the user who created them"
    - "Template picker dialog shows built-in and custom templates with name and description"
  artifacts:
    - path: "fastapi-backend/app/models/document_template.py"
      provides: "DocumentTemplate SQLAlchemy model"
      contains: "DocumentTemplate"
    - path: "fastapi-backend/app/routers/document_templates.py"
      provides: "Template CRUD endpoints"
      contains: "router"
    - path: "fastapi-backend/alembic/versions/20260201_add_document_templates.py"
      provides: "DocumentTemplates table + built-in seed data"
      contains: "DocumentTemplates"
    - path: "electron-app/src/renderer/components/knowledge/template-picker.tsx"
      provides: "Template picker dialog component"
      contains: "TemplatePickerDialog"
    - path: "electron-app/src/renderer/hooks/use-document-templates.ts"
      provides: "TanStack Query hooks for templates"
      contains: "useDocumentTemplates"
  key_links:
    - from: "electron-app/src/renderer/components/knowledge/template-picker.tsx"
      to: "use-document-templates.ts"
      via: "useDocumentTemplates + useCreateFromTemplate + useSaveAsTemplate hooks"
      pattern: "useDocumentTemplates"
    - from: "electron-app/src/renderer/hooks/use-document-templates.ts"
      to: "/api/document-templates"
      via: "electronAPI.get/post"
      pattern: "/api/document-templates"
    - from: "fastapi-backend/app/routers/document_templates.py"
      to: "DocumentTemplate model"
      via: "SQLAlchemy queries"
      pattern: "DocumentTemplate"
---

<objective>
Add document templates: backend model + CRUD endpoints + migration with built-in template seeding, frontend template picker dialog and save-as-template flow.

Purpose: Users can create documents from templates (TMPL-01, TMPL-02, TMPL-03) — both built-in and custom templates.
Output: DocumentTemplate table with 5 built-in templates, CRUD API, template picker dialog, save-as-template action.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-search-templates-export/09-RESEARCH.md
@fastapi-backend/app/models/__init__.py
@fastapi-backend/app/models/document.py
@fastapi-backend/app/routers/__init__.py
@fastapi-backend/app/main.py
@fastapi-backend/app/schemas/document.py
@electron-app/src/renderer/hooks/use-documents.ts
@electron-app/src/renderer/lib/query-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend template model, migration with seed data, schemas, and CRUD endpoints</name>
  <files>
    fastapi-backend/app/models/document_template.py
    fastapi-backend/app/models/__init__.py
    fastapi-backend/app/schemas/document_template.py
    fastapi-backend/app/routers/document_templates.py
    fastapi-backend/app/routers/__init__.py
    fastapi-backend/app/main.py
    fastapi-backend/alembic/versions/20260201_add_document_templates.py
  </files>
  <action>
    **1. DocumentTemplate model** (`document_template.py`):
    ```python
    class DocumentTemplate(Base):
        __tablename__ = "DocumentTemplates"
        __allow_unmapped__ = True

        id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
        name = Column(String(255), nullable=False)
        description = Column(String(500), nullable=True)
        content_json = Column(Text, nullable=False)  # TipTap JSON string
        is_builtin = Column(Boolean, nullable=False, default=False)
        user_id = Column(UUID(as_uuid=True), ForeignKey("Users.id", ondelete="CASCADE"), nullable=True)
        created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
        updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    ```
    - Built-in templates: `is_builtin=True, user_id=None`
    - Custom templates: `is_builtin=False, user_id=<creator UUID>`
    - No application_id scope — keep simple for v1 (custom templates are per-user)
    - Import pattern: follow existing model files (uuid, datetime, SQLAlchemy imports, Base from ..database)

    **2. Register model** (`__init__.py`):
    - Add `from .document_template import DocumentTemplate`
    - Add `"DocumentTemplate"` to `__all__`

    **3. Alembic migration** (`20260201_add_document_templates.py`):
    - Create `DocumentTemplates` table with columns matching the model
    - Seed 5 built-in templates via `op.execute(INSERT INTO ...)` with proper TipTap JSON content:
      1. **Meeting Notes**: H1 "Meeting Notes", H2 sections for Date, Attendees (bullet list), Agenda (ordered list), Discussion (paragraph), Action Items (task list)
      2. **Design Doc**: H1 "Design Document", H2 sections for Overview, Goals, Non-Goals, Proposed Solution, Alternatives Considered, Timeline
      3. **Decision Record**: H1 "Decision Record", H2 sections for Status (paragraph "[Proposed/Accepted/Rejected]"), Context, Decision, Consequences
      4. **Project Brief**: H1 "Project Brief", H2 sections for Objective, Background, Scope, Success Criteria, Timeline, Resources
      5. **Sprint Retrospective**: H1 "Sprint Retrospective", H2 sections for Sprint Goal, What Went Well (bullet list), What Didn't Go Well (bullet list), Action Items (task list)
    - Each template content_json must be valid TipTap JSON with `{"type": "doc", "content": [...]}`
    - Use Python json.dumps in the migration to build the JSON strings
    - Downgrade: drop DocumentTemplates table

    **4. Pydantic schemas** (`document_template.py`):
    ```python
    class DocumentTemplateCreate(BaseModel):
        name: str = Field(..., min_length=1, max_length=255)
        description: Optional[str] = Field(None, max_length=500)
        content_json: str  # TipTap JSON string

    class DocumentTemplateResponse(BaseModel):
        model_config = ConfigDict(from_attributes=True)
        id: UUID
        name: str
        description: Optional[str] = None
        content_json: str
        is_builtin: bool
        user_id: Optional[UUID] = None
        created_at: datetime
        updated_at: datetime

    class DocumentTemplateListResponse(BaseModel):
        items: list[DocumentTemplateResponse]
    ```

    **5. Template CRUD router** (`document_templates.py`):
    Create router with prefix `/document-templates`:
    - `GET /` — List templates: returns all built-in templates + current user's custom templates. Query: `WHERE is_builtin = True OR user_id = :current_user_id`, ordered by `is_builtin DESC, name ASC` (built-in first).
    - `POST /` — Create custom template: sets `is_builtin=False, user_id=current_user.id`. Validates content_json is valid JSON (try json.loads).
    - `POST /from-document/{document_id}` — Save existing document as template: fetches document by ID, creates a new template with the document's content_json and a user-provided name. Returns 404 if document not found. Request body: `{ name: str, description?: str }`.
    - `DELETE /{template_id}` — Delete custom template: only owner can delete. Returns 403 if trying to delete built-in template. Returns 404 if not found. Returns 403 if user_id doesn't match current user.
    - All endpoints require `current_user: User = Depends(get_current_user)` and `db: AsyncSession = Depends(get_db)`.

    **6. Register router**:
    - In `routers/__init__.py`: add `from .document_templates import router as document_templates_router` and to `__all__`
    - In `main.py`: add `app.include_router(document_templates_router, prefix="/api", tags=["document-templates"])`
  </action>
  <verify>
    - `cd fastapi-backend && python -c "from app.models.document_template import DocumentTemplate; print('OK')"` prints OK
    - `cd fastapi-backend && python -c "from app.schemas.document_template import DocumentTemplateCreate, DocumentTemplateResponse, DocumentTemplateListResponse; print('OK')"` prints OK
    - `cd fastapi-backend && python -c "from app.routers.document_templates import router; routes = [r.path for r in router.routes]; print(routes)"` shows expected routes
    - `cd fastapi-backend && python -c "from app.routers import document_templates_router; print('OK')"` prints OK
  </verify>
  <done>
    DocumentTemplate model exists with migration seeding 5 built-in templates. CRUD endpoints support listing (built-in + user's custom), creating custom templates, saving document as template, and deleting custom templates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend template hooks, picker dialog, and save-as-template integration</name>
  <files>
    electron-app/src/renderer/lib/query-client.ts
    electron-app/src/renderer/hooks/use-document-templates.ts
    electron-app/src/renderer/components/knowledge/template-picker.tsx
  </files>
  <action>
    **1. Query keys** (`query-client.ts`):
    Add to `queryKeys`:
    ```typescript
    documentTemplates: ['documentTemplates'] as const,
    ```

    **2. Template hooks** (`use-document-templates.ts`):
    Create new file with hooks:

    ```typescript
    // Types
    interface DocumentTemplate {
      id: string
      name: string
      description: string | null
      content_json: string
      is_builtin: boolean
      user_id: string | null
      created_at: string
      updated_at: string
    }

    interface DocumentTemplateListResponse {
      items: DocumentTemplate[]
    }

    // useDocumentTemplates — list all available templates
    // GET /api/document-templates
    // enabled when token exists

    // useCreateFromTemplate — mutation that creates a new document with template content
    // This hook does NOT call a template-specific endpoint. Instead, it:
    // 1. Fetches the template's content_json from the template list (or accepts it as parameter)
    // 2. Calls the existing document create endpoint (POST /api/documents) with the template's content_json
    // 3. Invalidates documents query
    // Signature: mutate({ templateId, title, scope, scopeId, folderId? })
    // Inside mutationFn: find template from query cache or fetch it, then create document with its content_json

    // useSaveAsTemplate — mutation to save a document as a custom template
    // POST /api/document-templates/from-document/{documentId} with { name, description? }
    // Invalidates documentTemplates query on success

    // useDeleteTemplate — mutation to delete a custom template
    // DELETE /api/document-templates/{templateId}
    // Invalidates documentTemplates query on success
    ```

    Follow existing hook patterns from use-documents.ts:
    - Import useAuthStore for token
    - Import queryKeys from query-client
    - Use window.electronAPI.get/post/delete
    - Check response.status >= 400 and throw

    **3. TemplatePickerDialog** (`template-picker.tsx`):
    Create a Radix Dialog-based component:
    - Props: `open: boolean, onOpenChange: (open: boolean) => void, onSelectTemplate: (template: { content_json: string, name: string }) => void`
    - Uses `useDocumentTemplates()` hook to fetch templates
    - Layout:
      - Dialog title: "New from Template"
      - Two sections separated by a subtle heading: "Built-in Templates" and "My Templates" (custom)
      - Each template rendered as a card/button with:
        - Template name (bold)
        - Description (muted text, truncated to 2 lines)
        - "Use" button or click the whole card
      - If no custom templates: show "No custom templates yet" message
    - On template selection: calls `onSelectTemplate({ content_json, name })` and closes dialog
    - Loading state: show skeleton cards while templates load
    - Use existing shadcn Dialog component (`@/components/ui/dialog`): DialogContent, DialogHeader, DialogTitle
    - Use ScrollArea for the template list if many templates
    - Use Tailwind grid (2 columns on wider dialogs) or single column
    - Each card: border, rounded, p-3, hover:bg-accent transition, cursor-pointer

    **Integration note for the caller (NOT part of this plan — will be wired in the Notes page or folder context menu later, or in an existing "new document" flow):**
    The TemplatePickerDialog is a reusable component. The caller is responsible for:
    1. Opening the dialog (e.g., from a "New from Template" button/menu item)
    2. Receiving the selected template via onSelectTemplate
    3. Creating the document via the existing document create mutation with the template's content_json

    However, to make the flow complete, also export a convenience component or wire into the existing knowledge-sidebar or folder-context-menu:
    - Add a "Save as Template" action — this can be a simple function exported from use-document-templates that the editor toolbar or context menu can call
    - The TemplatePickerDialog should be importable and usable from any parent component
  </action>
  <verify>
    - `cd electron-app && npx tsc --noEmit` passes without errors
    - Grep for "useDocumentTemplates" in use-document-templates.ts confirms hook exists
    - Grep for "TemplatePickerDialog" in template-picker.tsx confirms component exists
    - Grep for "documentTemplates" in query-client.ts confirms query key exists
  </verify>
  <done>
    Template hooks (list, save-as-template, delete) work with TanStack Query. TemplatePickerDialog shows built-in and custom templates in a dialog with selection callback. Save-as-template mutation available for editor integration.
  </done>
</task>

</tasks>

<verification>
1. Backend: DocumentTemplates table exists with 5 built-in templates seeded
2. Backend: GET /api/document-templates returns built-in + user's custom templates
3. Backend: POST /api/document-templates creates a custom template
4. Backend: POST /api/document-templates/from-document/{id} saves document as template
5. Backend: DELETE /api/document-templates/{id} deletes custom template (not built-in)
6. Frontend: TemplatePickerDialog renders built-in and custom templates
7. Frontend: Selecting a template provides content_json to caller
8. `cd electron-app && npx tsc --noEmit` passes
</verification>

<success_criteria>
- 5 built-in templates seeded in migration and visible via API
- Custom templates can be created, listed, and deleted
- Template picker dialog shows all templates with name and description
- Save-as-template flow creates a new template from existing document content
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-search-templates-export/09-02-SUMMARY.md`
</output>
