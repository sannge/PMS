---
phase: 09-search-templates-export
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - fastapi-backend/app/models/document_template.py
  - fastapi-backend/app/models/__init__.py
  - fastapi-backend/app/schemas/document_template.py
  - fastapi-backend/app/schemas/__init__.py
  - fastapi-backend/app/routers/document_templates.py
  - fastapi-backend/app/routers/__init__.py
  - fastapi-backend/app/main.py
  - fastapi-backend/alembic/versions/YYYYMMDD_add_document_templates.py
  - electron-app/src/renderer/hooks/use-document-templates.ts
  - electron-app/src/renderer/hooks/index.ts
  - electron-app/src/renderer/components/knowledge/template-picker-dialog.tsx
  - electron-app/src/renderer/components/knowledge/folder-context-menu.tsx
autonomous: true

must_haves:
  truths:
    - "User can create a new document from a built-in template (Meeting Notes, Design Doc, Decision Record, Project Brief, Sprint Retrospective)"
    - "User can save any existing document as a custom template"
    - "User can create a new document from a previously saved custom template"
    - "Template picker dialog shows both built-in and custom templates with name and description"
  artifacts:
    - path: "fastapi-backend/app/models/document_template.py"
      provides: "DocumentTemplate SQLAlchemy model"
      contains: "DocumentTemplate"
    - path: "fastapi-backend/app/routers/document_templates.py"
      provides: "Template CRUD endpoints"
      contains: "router"
    - path: "electron-app/src/renderer/components/knowledge/template-picker-dialog.tsx"
      provides: "Template selection dialog"
      exports: ["TemplatePickerDialog"]
    - path: "electron-app/src/renderer/hooks/use-document-templates.ts"
      provides: "Template query and mutation hooks"
      exports: ["useDocumentTemplates", "useCreateTemplate", "useDeleteTemplate"]
  key_links:
    - from: "electron-app/src/renderer/components/knowledge/template-picker-dialog.tsx"
      to: "/api/document-templates"
      via: "useDocumentTemplates hook"
      pattern: "document-templates"
    - from: "electron-app/src/renderer/components/knowledge/folder-context-menu.tsx"
      to: "template-picker-dialog.tsx"
      via: "New from template context menu item opens dialog"
      pattern: "TemplatePickerDialog"
---

<objective>
Add a document template system with five built-in templates and custom template support. Users can create documents from templates via the folder context menu, and save any document as a reusable template.

Purpose: Streamline document creation with consistent structures (TMPL-01, TMPL-02, TMPL-03).
Output: DocumentTemplate model, CRUD API, template picker dialog, save-as-template flow.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-search-templates-export/09-RESEARCH.md

@fastapi-backend/app/models/__init__.py
@fastapi-backend/app/models/document.py
@fastapi-backend/app/schemas/__init__.py
@fastapi-backend/app/schemas/document.py
@fastapi-backend/app/routers/__init__.py
@fastapi-backend/app/routers/documents.py
@fastapi-backend/app/main.py
@electron-app/src/renderer/hooks/use-documents.ts
@electron-app/src/renderer/components/knowledge/folder-context-menu.tsx
@electron-app/src/renderer/contexts/knowledge-base-context.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DocumentTemplate model, schemas, CRUD endpoints, and Alembic migration</name>
  <files>
    fastapi-backend/app/models/document_template.py
    fastapi-backend/app/models/__init__.py
    fastapi-backend/app/schemas/document_template.py
    fastapi-backend/app/schemas/__init__.py
    fastapi-backend/app/routers/document_templates.py
    fastapi-backend/app/routers/__init__.py
    fastapi-backend/app/main.py
    fastapi-backend/alembic/versions/YYYYMMDD_add_document_templates.py
  </files>
  <action>
**1. DocumentTemplate model (`models/document_template.py`):**

```python
class DocumentTemplate(Base):
    __tablename__ = "DocumentTemplates"
    __allow_unmapped__ = True

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    content_json = Column(Text, nullable=False)

    # Scope: application-scoped (team shared) or user-scoped (private)
    application_id = Column(UUID(as_uuid=True), ForeignKey("Applications.id", ondelete="CASCADE"), nullable=True, index=True)
    user_id = Column(UUID(as_uuid=True), ForeignKey("Users.id", ondelete="CASCADE"), nullable=True, index=True)

    # Audit
    created_by = Column(UUID(as_uuid=True), ForeignKey("Users.id", ondelete="SET NULL"), nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
```

No CHECK constraint for scope -- templates without application_id or user_id are global built-ins (but we store built-ins as static constants, not in the DB). Custom templates must have either application_id or user_id set.

Register in `models/__init__.py`: import and add to `__all__`.

**2. Alembic migration:**
Create migration for the DocumentTemplates table. Chain revision to the latest existing migration. Include all columns, indexes on application_id and user_id.

**3. Pydantic schemas (`schemas/document_template.py`):**

```python
class TemplateCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = Field(None, max_length=1000)
    content_json: str = Field(...)
    application_id: Optional[UUID] = None

class TemplateResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    id: UUID
    name: str
    description: Optional[str] = None
    content_json: str
    application_id: Optional[UUID] = None
    user_id: Optional[UUID] = None
    created_by: Optional[UUID] = None
    created_at: datetime
    updated_at: datetime
    is_builtin: bool = False  # Computed on response, not stored in DB

class BuiltInTemplate(BaseModel):
    id: str  # slug like "meeting-notes"
    name: str
    description: str
    content_json: str
    is_builtin: bool = True

class TemplateListResponse(BaseModel):
    builtin: list[BuiltInTemplate]
    custom: list[TemplateResponse]
```

Register new schemas in `schemas/__init__.py`.

**4. Built-in template constants:**
Define in the router file (or a separate constants file if preferred) as a Python dict. Include these 5 templates with simple TipTap JSON structures (headings, paragraphs, bullet lists, task lists):

- **Meeting Notes**: H1 "Meeting Notes", H2 sections for Date, Attendees (bullet list), Agenda, Discussion, Action Items (task list)
- **Design Doc**: H1 "Design Document", H2 sections for Overview, Goals, Non-Goals, Design, Alternatives Considered, Open Questions
- **Decision Record**: H1 "Decision Record", H2 sections for Context, Decision, Consequences, Status (paragraph with "[Proposed]")
- **Project Brief**: H1 "Project Brief", H2 sections for Background, Objective, Scope, Timeline, Success Criteria
- **Sprint Retrospective**: H1 "Sprint Retrospective", H2 sections for What Went Well (bullet list), What Could Improve (bullet list), Action Items (task list)

Keep templates simple -- only basic TipTap nodes (doc, heading, paragraph, bulletList, listItem, taskList, taskItem). No complex marks or special attributes.

**5. Router (`routers/document_templates.py`):**
Prefix: `/document-templates`, tags: `["document-templates"]`

Endpoints:
- `GET /document-templates?application_id=UUID` - Returns `TemplateListResponse` with built-in templates AND custom templates scoped to the user (personal) and the given application. Always include built-ins.
- `POST /document-templates` - Create custom template. Body is `TemplateCreate`. If `application_id` is provided, template is application-scoped (shared). Otherwise, set `user_id` to current user (private). Returns `TemplateResponse` with 201.
- `DELETE /document-templates/{template_id}` - Delete a custom template. Only the creator can delete. Returns 204.

No update endpoint needed for v1 -- templates are create-once.

**6. Register router:**
- Import in `routers/__init__.py` as `document_templates_router`
- Add to `__all__`
- Import in `main.py` and add `app.include_router(document_templates_router, prefix="/api")`
  </action>
  <verify>
1. `cd fastapi-backend && python -c "from app.models.document_template import DocumentTemplate; print('OK')"` prints OK
2. `cd fastapi-backend && python -c "from app.schemas.document_template import TemplateCreate, TemplateResponse, TemplateListResponse; print('OK')"` prints OK
3. `cd fastapi-backend && python -c "from app.routers.document_templates import router; print(len(router.routes))"` prints 3 (GET, POST, DELETE)
4. Alembic migration file exists with upgrade/downgrade
5. `cd fastapi-backend && python -c "from app.main import app; routes = [r.path for r in app.routes]; print('/api/document-templates' in str(routes))"` prints True
  </verify>
  <done>
DocumentTemplate model exists with Alembic migration. Five built-in templates defined as static constants. GET endpoint returns both built-in and custom templates. POST creates custom templates. DELETE removes custom templates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Template picker dialog, save-as-template flow, and context menu integration</name>
  <files>
    electron-app/src/renderer/hooks/use-document-templates.ts
    electron-app/src/renderer/hooks/index.ts
    electron-app/src/renderer/components/knowledge/template-picker-dialog.tsx
    electron-app/src/renderer/components/knowledge/folder-context-menu.tsx
    electron-app/src/renderer/lib/query-client.ts
  </files>
  <action>
**1. Add query key to `lib/query-client.ts`:**
```typescript
documentTemplates: (applicationId: string) =>
  ['documentTemplates', applicationId] as const,
```

**2. Create `hooks/use-document-templates.ts`:**
Follow existing patterns from `use-documents.ts`.

Types:
```typescript
export interface BuiltInTemplate {
  id: string
  name: string
  description: string
  content_json: string
  is_builtin: true
}

export interface CustomTemplate {
  id: string
  name: string
  description: string | null
  content_json: string
  application_id: string | null
  user_id: string | null
  created_by: string | null
  created_at: string
  updated_at: string
  is_builtin: false
}

export interface TemplateListResponse {
  builtin: BuiltInTemplate[]
  custom: CustomTemplate[]
}
```

Hooks:
- `useDocumentTemplates(applicationId: string | null)` - GET /api/document-templates?application_id=...
  - `enabled` when token exists
  - `staleTime: 5 * 60 * 1000` (5 min -- templates change rarely)
- `useCreateTemplate()` - POST /api/document-templates
  - Invalidates `documentTemplates` query on success
  - Returns mutation for `{ name: string, description?: string, content_json: string, application_id?: string }`
- `useDeleteTemplate(applicationId: string | null)` - DELETE /api/document-templates/{id}
  - Invalidates `documentTemplates` query on success

Export from `hooks/index.ts`.

**3. Create `components/knowledge/template-picker-dialog.tsx`:**
A Radix Dialog component for selecting a template when creating a new document.

Props:
```typescript
interface TemplatePickerDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  onSelectTemplate: (contentJson: string, suggestedTitle: string) => void
  applicationId: string | null
}
```

Component behavior:
- Uses `useDocumentTemplates(applicationId)` to fetch templates
- Renders two sections: "Built-in Templates" and "My Templates" (custom)
- Each template shows name (bold) and description (muted text)
- Built-in section always visible; custom section only if custom templates exist
- Clicking a template calls `onSelectTemplate(template.content_json, template.name)` and closes the dialog
- A "Blank Document" option at the top that calls `onSelectTemplate('', 'Untitled')` for users who don't want a template
- Style: use existing Dialog, DialogContent, DialogHeader, DialogTitle components from shadcn/ui. Template items in a scrollable list with `hover:bg-accent rounded-md p-3 cursor-pointer` styling.

**4. Wire "New from template" into folder context menu (`folder-context-menu.tsx`):**
Read the existing context menu to understand its structure. Add a "New from Template..." menu item alongside the existing "New Document" item.

When clicked:
- Open the TemplatePickerDialog
- On template selection, create a new document using the existing `useCreateDocument` hook with the template's `content_json` as initial content
- The document title should be the template name (e.g., "Meeting Notes") -- user can rename later

This requires:
- Adding state for `templateDialogOpen` in the context menu or parent component
- The TemplatePickerDialog rendered near the context menu (or lifted to the sidebar level)
- On template selection: call `createDocument({ title: suggestedTitle, scope, scope_id, folder_id, content_json: templateContentJson })` -- NOTE: the existing `DocumentCreate` schema on the backend already accepts `content_json`. The existing `useCreateDocument` hook sends it. Verify this chain works.

**5. Save as template flow:**
This is a simpler flow -- add a "Save as Template" option. The most natural place is in the document context menu or an editor toolbar action. Since we don't have a document-level context menu yet (Phase 6 adds document tabs/metadata), implement it as follows:

Add a "Save as Template" item to the folder context menu when a document is selected (right-clicking on a document node). The context menu already has document-level actions. When clicked:
- Show a small dialog/prompt asking for template name (default: current document title) and optional description
- Call `useCreateTemplate` mutation with the document's `content_json`, name, and current application_id
- Show a success toast or similar feedback

Use a simple Dialog with Input fields for name and description, a "Save" button, and a "Cancel" button.
  </action>
  <verify>
1. `cd electron-app && npx tsc --noEmit` passes
2. Verify `use-document-templates.ts` exports `useDocumentTemplates`, `useCreateTemplate`, `useDeleteTemplate`
3. Verify `template-picker-dialog.tsx` exports `TemplatePickerDialog`
4. Verify `folder-context-menu.tsx` has a "New from Template" menu item
  </verify>
  <done>
Template picker dialog renders built-in and custom templates. Selecting a template creates a new document with that template's content. "Save as Template" in document context menu saves current document content as a reusable custom template. Template hooks fetch and mutate via the /api/document-templates endpoints.
  </done>
</task>

</tasks>

<verification>
1. Backend: DocumentTemplate model and migration exist
2. Backend: GET /document-templates returns 5 built-in + custom templates
3. Backend: POST /document-templates creates custom template
4. Backend: DELETE /document-templates/{id} removes custom template
5. Frontend: Template picker dialog shows built-in and custom templates
6. Frontend: "New from Template" in context menu opens picker and creates document
7. Frontend: "Save as Template" saves document content as custom template
8. `cd electron-app && npx tsc --noEmit` passes
</verification>

<success_criteria>
- Five built-in templates (Meeting Notes, Design Doc, Decision Record, Project Brief, Sprint Retrospective) appear in template picker
- Creating a document from a template populates its content with the template structure
- Users can save any document as a custom template and reuse it later
- Template picker dialog is accessible from the folder context menu
</success_criteria>

<output>
After completion, create `.planning/phases/09-search-templates-export/09-02-SUMMARY.md`
</output>
