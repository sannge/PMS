---
phase: 09-search-templates-export
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fastapi-backend/app/models/document.py
  - fastapi-backend/alembic/versions/YYYYMMDD_add_search_vector.py
  - fastapi-backend/app/services/document_service.py
  - fastapi-backend/app/schemas/document.py
  - fastapi-backend/app/routers/documents.py
  - electron-app/src/renderer/hooks/use-document-search.ts
  - electron-app/src/renderer/hooks/index.ts
  - electron-app/src/renderer/components/knowledge/search-results.tsx
  - electron-app/src/renderer/components/knowledge/search-bar.tsx
  - electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
autonomous: true

must_haves:
  truths:
    - "Search bar returns relevant results across document titles and content when user types 2+ characters"
    - "Search results show document title, highlighted content snippet, scope info, and last edited date"
    - "Results are ranked by relevance using PostgreSQL full-text search"
    - "Search works within the currently selected scope (personal, application, project)"
  artifacts:
    - path: "fastapi-backend/app/models/document.py"
      provides: "search_vector TSVECTOR generated column"
      contains: "search_vector"
    - path: "fastapi-backend/app/routers/documents.py"
      provides: "GET /documents/search endpoint"
      contains: "search_documents"
    - path: "fastapi-backend/app/schemas/document.py"
      provides: "SearchResultItem and SearchResponse schemas"
      contains: "SearchResultItem"
    - path: "electron-app/src/renderer/hooks/use-document-search.ts"
      provides: "useDocumentSearch TanStack Query hook"
      exports: ["useDocumentSearch"]
    - path: "electron-app/src/renderer/components/knowledge/search-results.tsx"
      provides: "SearchResults panel component"
      exports: ["SearchResults"]
  key_links:
    - from: "electron-app/src/renderer/hooks/use-document-search.ts"
      to: "/api/documents/search"
      via: "electronAPI.get with query params"
      pattern: "documents/search"
    - from: "fastapi-backend/app/routers/documents.py"
      to: "Document.search_vector"
      via: "websearch_to_tsquery + @@ operator"
      pattern: "websearch_to_tsquery"
---

<objective>
Add PostgreSQL full-text search to the knowledge base: a generated tsvector column with GIN index on the Documents table, a search API endpoint with relevance ranking and snippet generation, and a frontend search results panel that replaces the folder tree when the user is actively searching.

Purpose: Users can find documents by searching titles and content (SRCH-01, SRCH-02, SRCH-03).
Output: Working search from sidebar search bar through to ranked results display.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-search-templates-export/09-RESEARCH.md

@fastapi-backend/app/models/document.py
@fastapi-backend/app/routers/documents.py
@fastapi-backend/app/schemas/document.py
@fastapi-backend/app/services/document_service.py
@electron-app/src/renderer/hooks/use-documents.ts
@electron-app/src/renderer/components/knowledge/search-bar.tsx
@electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
@electron-app/src/renderer/lib/query-client.ts
@electron-app/src/renderer/contexts/knowledge-base-context.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add search_vector column, GIN index, search endpoint, and search schemas</name>
  <files>
    fastapi-backend/app/models/document.py
    fastapi-backend/alembic/versions/YYYYMMDD_add_search_vector.py
    fastapi-backend/app/services/document_service.py
    fastapi-backend/app/schemas/document.py
    fastapi-backend/app/routers/documents.py
  </files>
  <action>
**1. Document model (`models/document.py`):**
Add a `search_vector` column using `TSVECTOR` type with `Computed`:

```python
from sqlalchemy import Computed
from sqlalchemy.dialects.postgresql import TSVECTOR

search_vector = Column(
    TSVECTOR,
    Computed(
        "to_tsvector('english', coalesce(title, '') || ' ' || coalesce(content_plain, ''))",
        persisted=True,
    ),
    nullable=True,
)
```

Add a GIN index to `__table_args__`:
```python
Index('ix_documents_search_vector', 'search_vector', postgresql_using='gin'),
```

**2. Alembic migration:**
Create a new migration file. Use `op.execute()` for the generated column since Alembic's `add_column` doesn't handle `Computed` columns cleanly with PostgreSQL:

```python
def upgrade():
    op.execute("""
        ALTER TABLE "Documents"
        ADD COLUMN search_vector tsvector
        GENERATED ALWAYS AS (
            to_tsvector('english', coalesce(title, '') || ' ' || coalesce(content_plain, ''))
        ) STORED
    """)
    op.create_index(
        'ix_documents_search_vector',
        'Documents',
        ['search_vector'],
        postgresql_using='gin',
    )

def downgrade():
    op.drop_index('ix_documents_search_vector', table_name='Documents')
    op.drop_column('Documents', 'search_vector')
```

Name the migration file with today's date prefix following existing convention (e.g., `20260201_add_search_vector.py`). Set the `revision` and `down_revision` properly -- read the latest migration's revision ID to chain correctly.

**3. Search schemas (`schemas/document.py`):**
Add these schemas at the bottom of the file:

```python
class SearchResultItem(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    id: UUID
    title: str
    application_id: Optional[UUID] = None
    project_id: Optional[UUID] = None
    user_id: Optional[UUID] = None
    folder_id: Optional[UUID] = None
    updated_at: datetime
    rank: float
    snippet: str

class SearchResponse(BaseModel):
    items: list[SearchResultItem]
    query: str
    total: int
```

Export `SearchResultItem` and `SearchResponse` from `schemas/__init__.py`.

**4. Search service function (`services/document_service.py`):**
Add a `search_documents` async function:

```python
from sqlalchemy import func, text

async def search_documents(
    db: AsyncSession,
    query: str,
    scope: str,
    scope_id: UUID,
    limit: int = 20,
) -> tuple[list[dict], int]:
    tsquery = func.websearch_to_tsquery('english', query)

    stmt = (
        select(
            Document.id,
            Document.title,
            Document.application_id,
            Document.project_id,
            Document.user_id,
            Document.folder_id,
            Document.updated_at,
            func.ts_rank(Document.search_vector, tsquery).label('rank'),
            func.ts_headline(
                'english',
                func.coalesce(Document.content_plain, ''),
                tsquery,
                'MaxWords=35, MinWords=15, MaxFragments=2, StartSel=<mark>, StopSel=</mark>',
            ).label('snippet'),
        )
        .where(Document.search_vector.op('@@')(tsquery))
        .where(Document.deleted_at.is_(None))
        .where(get_scope_filter(Document, scope, scope_id))
        .order_by(text('rank DESC'))
        .limit(limit)
    )

    result = await db.execute(stmt)
    rows = [dict(row._mapping) for row in result]
    return rows, len(rows)
```

IMPORTANT: Always use `'english'` as first argument in both `to_tsvector` (in the column definition) and `websearch_to_tsquery` (in the query). They MUST match.

**5. Search endpoint (`routers/documents.py`):**
Add a `GET /documents/search` endpoint BEFORE the `/{document_id}` route (same pattern as the existing `/trash` endpoint placement). It must come before path-parameter routes to avoid path matching conflicts.

```python
@router.get("/search", response_model=SearchResponse)
async def search_docs(
    q: str = Query(..., min_length=2, max_length=200),
    scope: Literal["application", "project", "personal"] = Query(...),
    scope_id: UUID = Query(...),
    limit: int = Query(20, ge=1, le=50),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
) -> SearchResponse:
    rows, total = await search_documents_service(db, q, scope, scope_id, limit)
    return SearchResponse(
        items=[SearchResultItem(**row) for row in rows],
        query=q,
        total=total,
    )
```

Import `SearchResultItem`, `SearchResponse` in the router. Import `search_documents` from services (rename to avoid naming collision with the endpoint function).
  </action>
  <verify>
1. `cd fastapi-backend && python -c "from app.models.document import Document; print('search_vector' in [c.name for c in Document.__table__.columns])"` prints True
2. `cd fastapi-backend && python -c "from app.schemas.document import SearchResultItem, SearchResponse; print('OK')"` prints OK
3. Check that the Alembic migration file exists and has both upgrade and downgrade functions
4. `cd fastapi-backend && python -c "from app.services.document_service import search_documents; print('OK')"` prints OK (note: renamed import)
  </verify>
  <done>
Document model has search_vector TSVECTOR generated column with GIN index. Alembic migration creates column and index. Search endpoint accepts query, scope, scope_id and returns ranked results with highlighted snippets. SearchResultItem and SearchResponse schemas validate the response.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add useDocumentSearch hook, SearchResults component, and wire into sidebar</name>
  <files>
    electron-app/src/renderer/hooks/use-document-search.ts
    electron-app/src/renderer/hooks/index.ts
    electron-app/src/renderer/components/knowledge/search-results.tsx
    electron-app/src/renderer/components/knowledge/search-bar.tsx
    electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
    electron-app/src/renderer/lib/query-client.ts
  </files>
  <action>
**1. Add query key to `lib/query-client.ts`:**
Add a `documentSearch` key factory to `queryKeys`:
```typescript
documentSearch: (query: string, scope: string, scopeId: string) =>
  ['documentSearch', query, scope, scopeId] as const,
```

**2. Create `hooks/use-document-search.ts`:**
Follow the exact patterns from `use-documents.ts` (useAuthStore, getAuthHeaders, parseApiError, resolveScope helpers -- import or duplicate as appropriate).

```typescript
export interface SearchResultItem {
  id: string
  title: string
  application_id: string | null
  project_id: string | null
  user_id: string | null
  folder_id: string | null
  updated_at: string
  rank: number
  snippet: string
}

export interface SearchResponse {
  items: SearchResultItem[]
  query: string
  total: number
}

export function useDocumentSearch(
  query: string,
  scope: string,
  scopeId: string | null,
): UseQueryResult<SearchResponse, Error>
```

Key behaviors:
- `enabled` only when `token` exists, `query.length >= 2`, and scope is resolved
- `staleTime: 10_000` (10 seconds -- search results don't need to be super fresh)
- `placeholderData: (prev) => prev` to keep previous results while typing (keepPreviousData equivalent)
- Import `resolveScope` and `getAuthHeaders` and `parseApiError` from `use-documents.ts` (export them if not already exported), OR duplicate the helpers in this file to keep it self-contained

The API call: `window.electronAPI.get<SearchResponse>('/api/documents/search?q=...&scope=...&scope_id=...&limit=20', headers)`

**3. Export from `hooks/index.ts`:**
Add `export * from './use-document-search'`

**4. Create `components/knowledge/search-results.tsx`:**
A panel that displays search results when the user has an active search query:

```tsx
interface SearchResultsProps {
  query: string
  scope: string
  scopeId: string | null
  onSelectDocument: (documentId: string) => void
}
```

Component behavior:
- Uses `useDocumentSearch(query, scope, scopeId)` hook
- Shows loading skeleton while fetching (simple animated divs, nothing fancy)
- Shows "No results found" when results are empty
- Each result item shows:
  - Document title (bold)
  - Snippet with HTML highlighting rendered via `dangerouslySetInnerHTML` (the `<mark>` tags from ts_headline are server-controlled, safe to render)
  - Relative timestamp for `updated_at` (e.g., "2 hours ago") using simple date math
- Clicking a result calls `onSelectDocument(result.id)`
- Style with Tailwind: compact list items with `hover:bg-accent` for interactivity, `text-xs` for snippet, `text-sm font-medium` for title

**5. Wire SearchResults into sidebar (`knowledge-sidebar.tsx`):**
When `searchQuery` from `useKnowledgeBase()` has length >= 2, show the `SearchResults` component instead of the folder tree and tag filter list. When searchQuery is cleared, return to the normal folder tree view.

The sidebar already has `SearchBar` at the top. Below it, conditionally render:
- If `searchQuery.length >= 2`: `<SearchResults query={searchQuery} scope={...} scopeId={...} onSelectDocument={selectDocument} />`
- Otherwise: existing folder tree + tag filter list

Get scope/scopeId from `useKnowledgeBase()` context. Get `selectDocument` from the same context.

**6. No changes to SearchBar itself** -- it already debounces and updates searchQuery in context. The search results component reads that query and fetches from the API.
  </action>
  <verify>
1. `cd electron-app && npx tsc --noEmit` passes (typecheck)
2. Verify `use-document-search.ts` exports `useDocumentSearch`, `SearchResultItem`, `SearchResponse`
3. Verify `search-results.tsx` exports `SearchResults`
4. Verify `knowledge-sidebar.tsx` imports and conditionally renders SearchResults
  </verify>
  <done>
useDocumentSearch hook fetches from /api/documents/search with debounced query. SearchResults component displays ranked results with highlighted snippets. Sidebar shows search results when query is 2+ characters, returns to folder tree when search is cleared.
  </done>
</task>

</tasks>

<verification>
1. Backend: search_vector column exists on Document model with GIN index
2. Backend: Alembic migration creates generated column and index
3. Backend: GET /documents/search endpoint returns SearchResponse with ranked, snippeted results
4. Frontend: useDocumentSearch hook calls search API with proper scope resolution
5. Frontend: SearchResults component renders results with title, snippet, and timestamp
6. Frontend: Sidebar conditionally shows search results when query >= 2 chars
7. `cd electron-app && npx tsc --noEmit` passes
</verification>

<success_criteria>
- Search endpoint returns relevance-ranked results with highlighted snippets for queries of 2+ characters
- Frontend sidebar shows search results panel when user types in search bar
- Results display document title, highlighted content snippet, and last edited date
- Clicking a search result selects the document
- Search respects the current scope filter (personal, application, project)
</success_criteria>

<output>
After completion, create `.planning/phases/09-search-templates-export/09-01-SUMMARY.md`
</output>
