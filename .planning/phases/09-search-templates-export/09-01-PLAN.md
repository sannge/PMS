---
phase: 09-search-templates-export
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fastapi-backend/alembic/versions/20260201_add_search_vector.py
  - fastapi-backend/app/models/document.py
  - fastapi-backend/app/schemas/document.py
  - fastapi-backend/app/services/document_service.py
  - fastapi-backend/app/routers/documents.py
  - electron-app/src/renderer/lib/query-client.ts
  - electron-app/src/renderer/hooks/use-documents.ts
  - electron-app/src/renderer/components/knowledge/search-bar.tsx
  - electron-app/src/renderer/components/knowledge/search-results.tsx
  - electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
autonomous: true

must_haves:
  truths:
    - "Search bar sends query to backend and returns relevant results ranked by relevance"
    - "Search results show document title, HTML snippet with highlighted terms, scope info, and last edited date"
    - "Title matches rank higher than body matches"
    - "Empty or whitespace-only search query returns no results (graceful handling)"
    - "Search results replace the folder tree in the sidebar while a search query is active"
  artifacts:
    - path: "fastapi-backend/alembic/versions/20260201_add_search_vector.py"
      provides: "tsvector column, trigger function, GIN index, backfill"
      contains: "search_vector"
    - path: "fastapi-backend/app/routers/documents.py"
      provides: "GET /api/documents/search endpoint"
      contains: "search"
    - path: "fastapi-backend/app/schemas/document.py"
      provides: "DocumentSearchResult and DocumentSearchResponse schemas"
      contains: "DocumentSearchResult"
    - path: "electron-app/src/renderer/components/knowledge/search-results.tsx"
      provides: "Search results list component"
      contains: "SearchResults"
  key_links:
    - from: "electron-app/src/renderer/components/knowledge/search-bar.tsx"
      to: "use-documents.ts useSearchDocuments hook"
      via: "searchQuery triggers TanStack Query fetch"
      pattern: "useSearchDocuments"
    - from: "electron-app/src/renderer/hooks/use-documents.ts"
      to: "/api/documents/search"
      via: "electronAPI.get with query params"
      pattern: "/api/documents/search"
    - from: "fastapi-backend/app/routers/documents.py"
      to: "document_service.search_documents"
      via: "function call from search endpoint"
      pattern: "search_documents"
---

<objective>
Add PostgreSQL full-text search for documents: tsvector column with weighted trigger (title=A, content=B), GIN index, search endpoint with ranking and snippets, and search results UI that replaces the folder tree when searching.

Purpose: Users can find documents by searching titles and content with relevance-ranked results (SRCH-01, SRCH-02, SRCH-03).
Output: Working search from sidebar search bar through backend FTS to rendered results list.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-search-templates-export/09-RESEARCH.md
@fastapi-backend/app/models/document.py
@fastapi-backend/app/schemas/document.py
@fastapi-backend/app/services/document_service.py
@fastapi-backend/app/routers/documents.py
@electron-app/src/renderer/hooks/use-documents.ts
@electron-app/src/renderer/components/knowledge/search-bar.tsx
@electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
@electron-app/src/renderer/lib/query-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend search infrastructure (migration + service + endpoint)</name>
  <files>
    fastapi-backend/alembic/versions/20260201_add_search_vector.py
    fastapi-backend/app/models/document.py
    fastapi-backend/app/schemas/document.py
    fastapi-backend/app/services/document_service.py
    fastapi-backend/app/routers/documents.py
  </files>
  <action>
    **1. Alembic migration** (`20260201_add_search_vector.py`):
    Create a migration using `op.execute()` for raw SQL (SQLAlchemy has no native tsvector DDL support):
    - Add `search_vector` tsvector column to `Documents` table (nullable, no default needed since trigger handles it)
    - Create trigger function `documents_search_vector_update()` that builds the vector:
      ```sql
      NEW.search_vector :=
        setweight(to_tsvector('english', coalesce(NEW.title, '')), 'A') ||
        setweight(to_tsvector('english', coalesce(NEW.content_plain, '')), 'B');
      ```
    - Create trigger `documents_search_vector_trigger` BEFORE INSERT OR UPDATE OF title, content_plain
    - Create GIN index `ix_documents_search_vector` on `search_vector`
    - Backfill existing documents: `UPDATE "Documents" SET search_vector = setweight(...) || setweight(...)`
    - Downgrade: drop index, trigger, trigger function, column

    **2. Document model** (`document.py`):
    - Import `from sqlalchemy.dialects.postgresql import TSVECTOR` (add to existing postgresql import line)
    - Add `search_vector` column: `Column(TSVECTOR, nullable=True)` — no index in model (index is created via migration with GIN type which SQLAlchemy Column index=True doesn't support)
    - Do NOT add it to the model's `__table_args__` index list

    **3. Search schemas** (`document.py` schemas):
    Add two new schemas after existing ones:
    ```python
    class DocumentSearchResult(BaseModel):
        id: UUID
        title: str
        application_id: Optional[UUID] = None
        project_id: Optional[UUID] = None
        user_id: Optional[UUID] = None
        updated_at: datetime
        rank: float
        snippet: str  # HTML with <mark> tags

    class DocumentSearchResponse(BaseModel):
        items: list[DocumentSearchResult]
    ```

    **4. Search service function** (`document_service.py`):
    Add `search_documents()` function:
    - Parameters: `query: str, scope: Optional[str], scope_id: Optional[UUID], user_id: UUID, limit: int, db: AsyncSession`
    - Use `func.websearch_to_tsquery('english', query)` for query parsing
    - Use CTE pattern for performance (research recommends this):
      1. Inner CTE: select Document.id + ts_rank, filter by `search_vector.op('@@')(tsquery)` and `deleted_at.is_(None)`, order by rank DESC, LIMIT
      2. Outer query: join Document back to CTE, apply `ts_headline('english', coalesce(content_plain, ''), tsquery, 'StartSel=<mark>, StopSel=</mark>, MaxWords=40, MinWords=15')` only on the limited set
    - Scope filtering: if scope is provided, apply `get_scope_filter()` (already exists in document_service.py). For "all" scope or no scope, filter by user's accessible documents (personal docs where user_id matches).
    - For v1 simplicity: when no scope is specified, search personal docs (user_id == current_user.id) plus all application/project docs (permission filtering is Phase 8). This matches existing list endpoint behavior.
    - Return list of dicts with id, title, application_id, project_id, user_id, updated_at, rank, snippet
    - Import: `from sqlalchemy import func, select, literal_column`

    **5. Search endpoint** (`documents.py` router):
    Add `GET /search` endpoint BEFORE the `/{document_id}` route (to avoid path matching conflict — same pattern as the existing `/trash` endpoint):
    ```python
    @router.get("/search", response_model=DocumentSearchResponse)
    async def search_documents(
        q: str = Query(..., min_length=1, max_length=500),
        scope: Optional[Literal["application", "project", "personal"]] = Query(None),
        scope_id: Optional[UUID] = Query(None),
        limit: int = Query(20, ge=1, le=50),
        current_user: User = Depends(get_current_user),
        db: AsyncSession = Depends(get_db),
    )
    ```
    - Import DocumentSearchResponse from schemas
    - Import search_documents from document_service (rename to avoid collision with endpoint name, e.g. `from ..services.document_service import search_documents as search_documents_service`)
    - Call service function, return response
    - Handle empty query gracefully (FastAPI min_length=1 handles this)
  </action>
  <verify>
    - `cd fastapi-backend && python -c "from app.models.document import Document; print(hasattr(Document, 'search_vector'))"` prints True
    - `cd fastapi-backend && python -c "from app.schemas.document import DocumentSearchResult, DocumentSearchResponse; print('OK')"` prints OK
    - `cd fastapi-backend && python -c "from app.services.document_service import search_documents; print('OK')"` prints OK
    - `cd fastapi-backend && python -c "from app.routers.documents import router; routes = [r.path for r in router.routes]; print('/search' in routes)"` prints True
  </verify>
  <done>
    search_vector tsvector column exists on Document model, migration creates trigger + GIN index + backfill, search endpoint accepts query string and returns ranked results with HTML snippets.
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend search hook, results component, and sidebar integration</name>
  <files>
    electron-app/src/renderer/lib/query-client.ts
    electron-app/src/renderer/hooks/use-documents.ts
    electron-app/src/renderer/components/knowledge/search-results.tsx
    electron-app/src/renderer/components/knowledge/search-bar.tsx
    electron-app/src/renderer/components/knowledge/knowledge-sidebar.tsx
  </files>
  <action>
    **1. Query keys** (`query-client.ts`):
    Add to the `queryKeys` object:
    ```typescript
    documentSearch: (query: string, scope?: string, scopeId?: string) =>
      ['documentSearch', query, scope ?? '', scopeId ?? ''] as const,
    ```

    **2. Search hook** (`use-documents.ts`):
    Add `useSearchDocuments` hook at the end of the file:
    ```typescript
    export interface DocumentSearchResult {
      id: string
      title: string
      application_id: string | null
      project_id: string | null
      user_id: string | null
      updated_at: string
      rank: number
      snippet: string  // HTML with <mark> tags
    }

    export interface DocumentSearchResponse {
      items: DocumentSearchResult[]
    }

    export function useSearchDocuments(
      query: string,
      scope?: string,
      scopeId?: string,
    ): UseQueryResult<DocumentSearchResponse> {
      const { token } = useAuthStore()
      return useQuery({
        queryKey: queryKeys.documentSearch(query, scope, scopeId),
        queryFn: async () => {
          const params = new URLSearchParams({ q: query })
          if (scope) params.append('scope', scope)
          if (scopeId) params.append('scope_id', scopeId)
          const response = await window.electronAPI.get<DocumentSearchResponse>(
            `/api/documents/search?${params.toString()}`,
            { Authorization: `Bearer ${token}` },
          )
          if (response.status >= 400) throw new Error(`Search failed: ${response.status}`)
          return response.data
        },
        enabled: !!token && query.trim().length > 0,
        staleTime: 10_000,  // 10s — search results can be slightly stale
      })
    }
    ```

    **3. SearchResults component** (`search-results.tsx`):
    Create a new component that renders search results:
    - Props: `results: DocumentSearchResult[]`, `onSelectDocument: (id: string) => void`, `isLoading: boolean`
    - Each result item shows:
      - Document title (bold)
      - Snippet with dangerouslySetInnerHTML (contains `<mark>` tags from ts_headline)
      - Scope indicator (derive from application_id/project_id/user_id — show "Personal" / "Application" / "Project")
      - Last edited date (format updated_at with relative time or short date)
    - Use Tailwind classes consistent with existing sidebar styling (text-xs, muted-foreground, etc.)
    - Show "No results found" when results array is empty and not loading
    - Show a simple loading skeleton/spinner when isLoading is true
    - Each item is clickable and calls onSelectDocument(result.id)
    - Import lucide icons: FileText for document icon
    - Style the `<mark>` tags via CSS: `.search-snippet mark { background-color: hsl(var(--primary) / 0.2); border-radius: 2px; }` — add to editor-styles.css or inline via Tailwind

    **4. Update SearchBar** (`search-bar.tsx`):
    The existing SearchBar only updates KnowledgeBaseContext's searchQuery. No changes needed here — the sidebar will read searchQuery from context and conditionally render SearchResults.

    **5. Update KnowledgeSidebar** (`knowledge-sidebar.tsx`):
    - Import `useSearchDocuments` from use-documents
    - Import `SearchResults` from search-results
    - Import `useKnowledgeBase` to read `searchQuery`, `selectedScope`, and scope IDs
    - When `searchQuery` is non-empty (trimmed), call `useSearchDocuments(searchQuery, scope, scopeId)` and render `<SearchResults>` instead of the folder tree section
    - When `searchQuery` is empty, show the normal folder tree (existing behavior)
    - Pass an `onSelectDocument` callback that dispatches to KnowledgeBaseContext to open/select the document (use existing `selectDocument` action if available, or dispatch SET_SELECTED_DOCUMENT)
    - The scope/tag filter sections can remain visible during search, or hide them — keep them visible for now (user might want to filter scope then search within it)
  </action>
  <verify>
    - `cd electron-app && npx tsc --noEmit` passes without errors
    - Grep for "useSearchDocuments" in use-documents.ts confirms hook exists
    - Grep for "SearchResults" in search-results.tsx confirms component exists
    - Grep for "documentSearch" in query-client.ts confirms query key exists
  </verify>
  <done>
    Search bar triggers server-side FTS query via useSearchDocuments hook, results render in sidebar with title, snippet (highlighted), scope, and date. Folder tree is hidden during active search.
  </done>
</task>

</tasks>

<verification>
1. Backend: Document model has search_vector column, migration creates trigger + GIN index
2. Backend: GET /api/documents/search?q=term returns DocumentSearchResponse with ranked results
3. Frontend: Typing in search bar triggers API call after debounce, results display in sidebar
4. Frontend: Search results show title, highlighted snippet, scope info, last edited date
5. Frontend: Clearing search restores normal folder tree view
6. `cd electron-app && npx tsc --noEmit` passes
</verification>

<success_criteria>
- Search endpoint returns relevance-ranked results with weighted title > body scoring
- Search results include HTML snippets with <mark> highlighted terms
- Sidebar shows search results when query is active, folder tree when query is empty
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-search-templates-export/09-01-SUMMARY.md`
</output>
