---
phase: 09-search-templates-export
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - electron-app/src/main/ipc/handlers.ts
  - electron-app/src/preload/index.ts
  - electron-app/src/preload/index.d.ts
  - electron-app/src/renderer/components/knowledge/export-button.tsx
autonomous: true

must_haves:
  truths:
    - "User can click an export button and save a document as a .md Markdown file to their filesystem"
    - "Export uses the already-populated content_markdown field from the document (no re-generation)"
    - "Native OS save dialog appears with .md file filter and sensible default filename"
    - "File is written to the chosen path via Electron IPC"
  artifacts:
    - path: "electron-app/src/main/ipc/handlers.ts"
      provides: "fs:writeFile IPC handler"
      contains: "fs:writeFile"
    - path: "electron-app/src/preload/index.ts"
      provides: "writeFile API exposed to renderer"
      contains: "writeFile"
    - path: "electron-app/src/renderer/components/knowledge/export-button.tsx"
      provides: "ExportButton component"
      contains: "ExportButton"
  key_links:
    - from: "electron-app/src/renderer/components/knowledge/export-button.tsx"
      to: "preload/index.ts writeFile"
      via: "window.electronAPI.writeFile"
      pattern: "writeFile"
    - from: "electron-app/src/preload/index.ts"
      to: "main/ipc/handlers.ts fs:writeFile"
      via: "ipcRenderer.invoke('fs:writeFile')"
      pattern: "fs:writeFile"
---

<objective>
Add Markdown export: new IPC handler for writing files to disk, preload API exposure, and an ExportButton component that uses showSaveDialog + writeFile to export document content_markdown.

Purpose: Users can export any document as a Markdown .md file download (EXPR-01).
Output: ExportButton component that triggers native save dialog and writes markdown to disk via Electron IPC.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-search-templates-export/09-RESEARCH.md
@electron-app/src/main/ipc/handlers.ts
@electron-app/src/preload/index.ts
@electron-app/src/preload/index.d.ts
@electron-app/src/renderer/hooks/use-documents.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fs:writeFile IPC handler and preload API</name>
  <files>
    electron-app/src/main/ipc/handlers.ts
    electron-app/src/preload/index.ts
    electron-app/src/preload/index.d.ts
  </files>
  <action>
    **1. IPC handler** (`handlers.ts`):
    - Add `import { promises as fsPromises } from 'fs'` at the top (or `import fs from 'fs/promises'`)
    - Add new handler inside `registerIpcHandlers()`, in a new section `// File System Handlers`:
      ```typescript
      ipcMain.handle(
        'fs:writeFile',
        async (_event, { filePath, content }: { filePath: string; content: string }) => {
          if (!filePath || typeof filePath !== 'string') {
            throw new Error('Invalid file path')
          }
          if (typeof content !== 'string') {
            throw new Error('Content must be a string')
          }
          await fsPromises.writeFile(filePath, content, 'utf-8')
          return { success: true }
        }
      )
      ```
    - Add `'fs:writeFile'` to the handlers array in `removeIpcHandlers()` so it gets cleaned up properly

    **2. Preload API** (`index.ts`):
    - Add `writeFile` to the `ElectronAPI` interface:
      ```typescript
      writeFile: (filePath: string, content: string) => Promise<{ success: boolean }>
      ```
    - Add implementation in the `contextBridge.exposeInMainWorld` object, in the file operations section:
      ```typescript
      writeFile: (filePath: string, content: string) =>
        ipcRenderer.invoke('fs:writeFile', { filePath, content }) as Promise<{ success: boolean }>,
      ```

    **3. Type declaration** (`index.d.ts`):
    - If `index.d.ts` has a duplicate ElectronAPI declaration or Window augmentation, add the `writeFile` method there too for consistency. Check the file content first — if it extends Window with electronAPI, add the writeFile signature.
  </action>
  <verify>
    - Grep for "fs:writeFile" in handlers.ts confirms handler exists
    - Grep for "writeFile" in preload/index.ts confirms API is exposed
    - `cd electron-app && npx tsc --noEmit` passes
  </verify>
  <done>
    fs:writeFile IPC handler registered in main process. Preload script exposes writeFile(filePath, content) to renderer. Type declarations updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: ExportButton component for Markdown export</name>
  <files>
    electron-app/src/renderer/components/knowledge/export-button.tsx
  </files>
  <action>
    Create `ExportButton` component:

    ```typescript
    /**
     * Export Button for Markdown Document Export
     *
     * Exports the current document's content_markdown as a .md file
     * using Electron's native save dialog and fs:writeFile IPC.
     */

    import { useState } from 'react'
    import { Download } from 'lucide-react'
    import { Button } from '@/components/ui/button'
    import {
      Tooltip,
      TooltipContent,
      TooltipTrigger,
    } from '@/components/ui/tooltip'

    interface ExportButtonProps {
      title: string
      contentMarkdown: string | null | undefined
      variant?: 'icon' | 'full'  // icon = just icon button, full = icon + text
    }

    export function ExportButton({ title, contentMarkdown, variant = 'icon' }: ExportButtonProps) {
      const [exporting, setExporting] = useState(false)

      const handleExport = async () => {
        if (!contentMarkdown) return
        setExporting(true)

        try {
          // Sanitize filename: replace invalid chars with underscore
          const safeName = title.replace(/[<>:"/\\|?*]/g, '_').trim() || 'document'

          const result = await window.electronAPI.showSaveDialog({
            title: 'Export as Markdown',
            defaultPath: `${safeName}.md`,
            filters: [{ name: 'Markdown', extensions: ['md'] }],
          })

          if (!result.canceled && result.filePath) {
            await window.electronAPI.writeFile(result.filePath, contentMarkdown)
          }
        } catch (error) {
          console.error('Export failed:', error)
          // Could show a toast here if sonner is available
        } finally {
          setExporting(false)
        }
      }

      const isDisabled = !contentMarkdown || exporting

      if (variant === 'full') {
        return (
          <Button
            variant="outline"
            size="sm"
            onClick={handleExport}
            disabled={isDisabled}
            className="gap-1.5"
          >
            <Download className="h-3.5 w-3.5" />
            {exporting ? 'Exporting...' : 'Export .md'}
          </Button>
        )
      }

      return (
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              variant="ghost"
              size="icon"
              className="h-7 w-7"
              onClick={handleExport}
              disabled={isDisabled}
            >
              <Download className="h-3.5 w-3.5" />
              <span className="sr-only">Export as Markdown</span>
            </Button>
          </TooltipTrigger>
          <TooltipContent side="bottom">Export as Markdown</TooltipContent>
        </Tooltip>
      )
    }
    ```

    Key design decisions:
    - Component receives `title` and `contentMarkdown` as props (doesn't fetch data itself — caller provides from document state)
    - Two variants: compact icon button (for toolbar) and full button with text (for menus)
    - Disabled when no content_markdown is available (new/empty documents)
    - Loading state during export (button disabled, text changes)
    - Error handling: catches and logs errors, doesn't crash
    - Uses existing shadcn Button and Tooltip components
    - Download icon from lucide-react (consistent with codebase)

    **Integration note (NOT part of this task):** The ExportButton should be placed in the editor toolbar or metadata bar by a later phase/plan that handles editor UI integration. For now, it's a standalone importable component. A quick integration point would be the editor toolbar (editor-toolbar.tsx) or document metadata section — but this plan only creates the component.

    If Tooltip is not yet a shadcn component, use a simple button without tooltip wrapping. Check if `@/components/ui/tooltip` exists first. If not, just use the Button without Tooltip wrapper.
  </action>
  <verify>
    - `cd electron-app && npx tsc --noEmit` passes
    - Grep for "ExportButton" in export-button.tsx confirms component exists
    - Grep for "showSaveDialog" in export-button.tsx confirms dialog integration
    - Grep for "writeFile" in export-button.tsx confirms IPC call
  </verify>
  <done>
    ExportButton component exports document as .md file via native save dialog. Supports icon and full variants, handles loading/disabled states, sanitizes filename.
  </done>
</task>

</tasks>

<verification>
1. IPC: fs:writeFile handler registered in main process
2. Preload: writeFile exposed in ElectronAPI interface and implementation
3. ExportButton: renders with Download icon, triggers save dialog on click
4. ExportButton: disabled when content_markdown is null/undefined
5. Full flow: button click -> showSaveDialog -> writeFile -> file on disk
6. `cd electron-app && npx tsc --noEmit` passes
</verification>

<success_criteria>
- fs:writeFile IPC handler writes UTF-8 content to specified file path
- ExportButton uses showSaveDialog for native file picker with .md filter
- Markdown content from document's content_markdown field is written to disk
- No re-generation of markdown (uses existing content_markdown)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-search-templates-export/09-03-SUMMARY.md`
</output>
