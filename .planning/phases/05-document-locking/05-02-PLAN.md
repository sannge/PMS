---
phase: 05-document-locking
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - electron-app/src/renderer/hooks/use-document-lock.ts
  - electron-app/src/renderer/hooks/index.ts
  - electron-app/src/renderer/components/editor/LockBanner.tsx
  - electron-app/src/renderer/components/editor/RichTextEditor.tsx
  - electron-app/src/renderer/hooks/use-websocket.ts
autonomous: false

must_haves:
  truths:
    - "When a user starts editing, the document is locked and other users see 'Being edited by [name]' in read-only mode"
    - "Lock auto-releases after 30 seconds of inactivity (saving the document first)"
    - "User can manually click 'Stop editing' to release the lock"
    - "If a client disconnects, the heartbeat stops and the server TTL expires the lock"
    - "Application owners see a 'Take over editing' button on locked documents"
    - "Lock status updates in real-time via WebSocket (no page refresh needed)"
  artifacts:
    - path: "electron-app/src/renderer/hooks/use-document-lock.ts"
      provides: "useDocumentLock hook with acquire, release, heartbeat, force-take, inactivity timer"
      contains: "useDocumentLock|acquireLock|releaseLock|heartbeat"
    - path: "electron-app/src/renderer/components/editor/LockBanner.tsx"
      provides: "Banner showing lock state with Stop editing and Take over editing buttons"
      contains: "Being edited by|Stop editing|Take over editing"
  key_links:
    - from: "electron-app/src/renderer/hooks/use-document-lock.ts"
      to: "/api/documents/{id}/lock"
      via: "fetch calls for acquire, release, heartbeat, force-take, status"
      pattern: "documents.*lock"
    - from: "electron-app/src/renderer/hooks/use-document-lock.ts"
      to: "electron-app/src/renderer/hooks/use-websocket.ts"
      via: "WebSocket listener for document_locked/unlocked/force_taken events"
      pattern: "document_locked|document_unlocked|document_force_taken"
    - from: "electron-app/src/renderer/components/editor/LockBanner.tsx"
      to: "electron-app/src/renderer/hooks/use-document-lock.ts"
      via: "Hook consumption for lock state and actions"
      pattern: "useDocumentLock"
---

<objective>
Build the complete frontend for document locking: a React hook managing lock lifecycle (acquire, release, heartbeat, inactivity timeout), a LockBanner component showing lock state, and integration into the existing editor.

Purpose: This delivers the user-facing experience for LOCK-01 through LOCK-07. Users see who is editing, can start/stop editing, and application owners can force-take locks.
Output: Working lock UI integrated into the editor with real-time WebSocket updates.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-document-locking/05-RESEARCH.md
@.planning/phases/05-document-locking/05-01-SUMMARY.md

# Existing frontend patterns to follow
@electron-app/src/renderer/hooks/use-presence.ts
@electron-app/src/renderer/hooks/use-websocket.ts
@electron-app/src/renderer/hooks/use-queries.ts
@electron-app/src/renderer/hooks/index.ts
@electron-app/src/renderer/components/editor/RichTextEditor.tsx
@electron-app/src/renderer/lib/websocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useDocumentLock hook with heartbeat and inactivity timer</name>
  <files>
    electron-app/src/renderer/hooks/use-document-lock.ts
    electron-app/src/renderer/hooks/use-websocket.ts
    electron-app/src/renderer/hooks/index.ts
  </files>
  <action>
    **Create `electron-app/src/renderer/hooks/use-document-lock.ts`:**

    Follow the structural pattern from `use-presence.ts` (types at top, constants, hook function).

    **Types:**
    ```typescript
    interface LockHolder {
      user_id: string
      user_name: string
      acquired_at?: number
    }

    interface UseDocumentLockReturn {
      lockHolder: LockHolder | null
      isLockedByMe: boolean
      isLockedByOther: boolean
      acquireLock: () => Promise<boolean>
      releaseLock: () => Promise<void>
      forceTakeLock: () => Promise<boolean>
      canForceTake: boolean
      resetInactivityTimer: () => void
    }
    ```

    **Constants:**
    - `HEARTBEAT_INTERVAL_MS = 10_000` (10 seconds)
    - `INACTIVITY_TIMEOUT_MS = 30_000` (30 seconds)
    - `LOCK_STATUS_POLL_MS = 20_000` (fallback poll for stale lock detection)

    **Hook: `useDocumentLock(documentId: string, currentUserId: string, isAppOwner: boolean): UseDocumentLockReturn`**

    Implementation:
    1. **Lock status query:** Use `useQuery` to fetch `GET /api/documents/{documentId}/lock` on mount. Set `refetchInterval: LOCK_STATUS_POLL_MS` as fallback polling for stale lock detection (Pitfall 2 from research). Set `staleTime: 5000`.

    2. **Acquire mutation:** `useMutation` calling `POST /api/documents/{documentId}/lock`. On success, invalidate lock status query. On 409 error, refetch lock status to show who holds it.

    3. **Release mutation:** `useMutation` calling `DELETE /api/documents/{documentId}/lock`. On success, invalidate lock status query.

    4. **Force-take mutation:** `useMutation` calling `POST /api/documents/{documentId}/lock/force-take`. On success, invalidate lock status query.

    5. **Heartbeat loop:** `useEffect` with `setInterval(HEARTBEAT_INTERVAL_MS)`. Only runs when `isLockedByMe` is true. Calls `POST /api/documents/{documentId}/lock/heartbeat`. If heartbeat returns 409, it means lock was lost -- set local state accordingly and stop heartbeat. Clean up interval on unmount.

    6. **Inactivity timer:** Track `lastActivityRef = useRef(Date.now())`. Expose `resetInactivityTimer` function that sets `lastActivityRef.current = Date.now()`. A `setInterval` every 5 seconds checks: if `isLockedByMe && (Date.now() - lastActivityRef.current > INACTIVITY_TIMEOUT_MS)`, then trigger save (call a save callback passed as option?) then call `releaseLock()`. **Important:** The editor component is responsible for calling `resetInactivityTimer()` on keypress/mouse events.

    7. **WebSocket listener:** Listen for `document_locked`, `document_unlocked`, `document_force_taken` events (use the existing WebSocket subscription pattern from `use-websocket.ts`). When received, invalidate the lock status TanStack Query to trigger a refetch. For `document_force_taken` where `triggered_by !== currentUserId`, trigger an immediate save if we were the holder, then show a notification.

    8. **Cleanup on unmount:** If `isLockedByMe`, call release endpoint. Use `navigator.sendBeacon` or sync XHR in `beforeunload` as a best-effort release (the server TTL handles the crash case). Use a `lockReleasedRef` to prevent double-release (Pitfall 3 from research).

    9. **Tab visibility:** Listen to `document.visibilitychange`. When tab becomes visible and `isLockedByMe`, immediately send a heartbeat. This handles browser throttling of background tab timers (Pitfall 4 from research). Since this is an Electron app, throttling is less aggressive, but the guard is good practice.

    **Derived state:**
    - `isLockedByMe = lockHolder?.user_id === currentUserId`
    - `isLockedByOther = lockHolder !== null && lockHolder.user_id !== currentUserId`
    - `canForceTake = isLockedByOther && isAppOwner`

    **Add WebSocket event handling in `use-websocket.ts`:**
    - In the existing message handler switch/if-else, add cases for `document_locked`, `document_unlocked`, `document_force_taken`, `document_lock_expired` message types. These should invalidate the TanStack Query cache for the lock status query key: `['document-lock', documentId]`.

    **Export** from `hooks/index.ts`: `export { useDocumentLock } from './use-document-lock'`
  </action>
  <verify>
    `cd electron-app && npm run typecheck` passes with zero errors.
    `npm run lint` passes with zero warnings.
    Grep confirms: `grep -r "useDocumentLock" src/renderer/hooks/use-document-lock.ts` returns the hook definition.
    Grep confirms: `grep -r "document_locked" src/renderer/hooks/` returns WebSocket handling code.
  </verify>
  <done>
    useDocumentLock hook is fully implemented with: lock status query, acquire/release/force-take mutations, heartbeat loop, inactivity timer, WebSocket listener, cleanup on unmount, and tab visibility handling. Hook is exported from index.ts. WebSocket events for lock changes are handled.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create LockBanner and integrate into editor</name>
  <files>
    electron-app/src/renderer/components/editor/LockBanner.tsx
    electron-app/src/renderer/components/editor/RichTextEditor.tsx
  </files>
  <action>
    **Create `electron-app/src/renderer/components/editor/LockBanner.tsx`:**

    Follow existing component conventions: types at top, section comments, Radix UI + Tailwind styling.

    **Props interface:**
    ```typescript
    interface LockBannerProps {
      lockHolder: LockHolder | null
      isLockedByMe: boolean
      isLockedByOther: boolean
      canForceTake: boolean
      onStartEditing: () => void    // Calls acquireLock
      onStopEditing: () => void     // Calls releaseLock
      onForceTake: () => void       // Calls forceTakeLock
    }
    ```

    **Three visual states:**

    1. **Unlocked (no lock holder):** Show an "Edit" button (pencil icon from lucide-react). Clicking calls `onStartEditing`.

    2. **Locked by me:** Show a subtle banner: "You are editing this document" with a "Stop editing" button on the right. Use `bg-primary/10 border-b` styling (consistent with existing UI patterns).

    3. **Locked by other:** Show an amber warning banner: "Being edited by {lockHolder.user_name}" with optional "Take over editing" button (visible only if `canForceTake` is true). Use `bg-amber-500/10 border-b text-amber-700` styling. The editor content area should be visually indicated as read-only (the editor itself handles the `editable` prop, not this component).

    **Icons:** Use `Lock`, `Unlock`, `Pencil`, `AlertTriangle` from `lucide-react` as appropriate.

    **Accessibility:** All buttons have proper `aria-label` attributes. Banner has `role="status"`.

    **Integrate into `RichTextEditor.tsx`:**

    Read the existing `RichTextEditor.tsx` to understand its current structure. Then:

    1. Import `LockBanner` and `useDocumentLock`
    2. The editor component needs `documentId`, `currentUserId`, and `isAppOwner` props (add to props interface if not present)
    3. Call `useDocumentLock(documentId, currentUserId, isAppOwner)` at the top of the component
    4. Render `<LockBanner>` above the editor content area
    5. Pass `editable={isLockedByMe}` to the TipTap editor (so it's read-only when locked by someone else or when user hasn't clicked "Edit")
    6. Wire `resetInactivityTimer` to editor activity events: call it on `onUpdate` (TipTap editor callback) and attach a `onMouseMove` handler to the editor container div
    7. When lock is force-taken from the user (detected via `isLockedByMe` changing from true to false while editing), show a toast notification: "Editing was taken over by [new holder name]" (use the existing notification pattern)

    **Important considerations:**
    - The editor should start in read-only/view mode. User must click "Edit" to acquire the lock and enable editing.
    - If lock acquisition fails (409), show a toast: "Document is being edited by [name]"
    - On `releaseLock`, the component should trigger a save before releasing (save callback from auto-save system from Phase 4). For now, if save function is not available, just release the lock.
    - The `beforeunload` cleanup in the hook handles the "close tab while editing" case
  </action>
  <verify>
    `cd electron-app && npm run typecheck` passes with zero errors.
    `npm run lint` passes with zero warnings.
    `grep -r "LockBanner" src/renderer/components/editor/` returns import and usage.
    `grep -r "useDocumentLock" src/renderer/components/editor/RichTextEditor.tsx` confirms hook is used.
    `grep -r "Being edited by" src/renderer/components/editor/LockBanner.tsx` confirms the locked-by-other banner text.
  </verify>
  <done>
    LockBanner component renders three states: unlocked (edit button), locked-by-me (stop editing), locked-by-other (read-only banner with optional force-take). Editor is integrated with useDocumentLock hook. Editor is read-only when not holding lock. Inactivity timer resets on editor activity. All type checks and lint pass.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete document locking system (backend + frontend):
    - Redis-based lock service with atomic operations
    - REST API endpoints for lock lifecycle
    - WebSocket real-time lock status broadcasts
    - Frontend lock hook with heartbeat, inactivity timer, and cleanup
    - LockBanner component integrated into the editor
  </what-built>
  <how-to-verify>
    1. Start the backend: `cd fastapi-backend && uvicorn app.main:app --reload --port 8001`
    2. Start the frontend: `cd electron-app && npm run dev`
    3. Open a document -- it should show in read-only mode with an "Edit" button
    4. Click "Edit" -- the banner should change to "You are editing this document" with "Stop editing"
    5. Open the same document in a second browser/window (different user if possible) -- it should show "Being edited by [name]" in amber banner
    6. Stop editing (click "Stop editing") -- both windows should update: lock released, edit button available again
    7. Test inactivity: Start editing, then don't type for 30+ seconds -- lock should auto-release
    8. Verify the Electron app layout looks correct (banner positioned above editor, no visual glitches)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `cd electron-app && npm run typecheck` passes with zero errors
2. `cd electron-app && npm run lint` passes with zero warnings
3. `cd fastapi-backend && ruff check .` passes (backend still clean after 05-01)
4. LockBanner renders correctly in all three states
5. useDocumentLock hook manages full lock lifecycle
6. WebSocket events trigger real-time UI updates across connected clients
7. Inactivity timer releases lock after 30 seconds of no editor activity
8. Editor switches between editable and read-only based on lock state
</verification>

<success_criteria>
- User can click "Edit" to acquire lock, sees "You are editing" banner, and editor becomes editable
- Other users see "Being edited by [name]" in read-only mode with real-time updates
- Lock auto-releases after 30 seconds of inactivity
- "Stop editing" button manually releases the lock
- Application owners see "Take over editing" button on locked documents
- Heartbeat keeps lock alive during active editing
- Lock releases on component unmount / page navigation
- All TypeScript strict mode checks pass, zero ESLint warnings
</success_criteria>

<output>
After completion, create `.planning/phases/05-document-locking/05-02-SUMMARY.md`
</output>
