---
phase: 05-document-locking
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - electron-app/src/renderer/hooks/use-document-lock.ts
  - electron-app/src/renderer/hooks/index.ts
  - electron-app/src/renderer/lib/websocket.ts
  - electron-app/src/renderer/components/knowledge/LockBanner.tsx
  - electron-app/src/renderer/components/knowledge/document-editor.tsx
autonomous: true

must_haves:
  truths:
    - "useDocumentLock hook acquires lock, sends heartbeat every 10s while locked, and releases on unmount"
    - "LockBanner shows 'You are editing this document' with 'Stop editing' button when locked by current user"
    - "LockBanner shows 'Being edited by [name]' with optional 'Take over editing' for owners when locked by another user"
    - "Editor becomes read-only when document is locked by another user"
    - "Lock auto-releases after 30 seconds of editor inactivity (saves first via onBeforeRelease callback)"
    - "WebSocket events (DOCUMENT_LOCKED, DOCUMENT_UNLOCKED, DOCUMENT_FORCE_TAKEN) update lock state in real-time"
    - "Force-take triggers onBeforeRelease on the previous holder's client before switching to read-only"
  artifacts:
    - path: "electron-app/src/renderer/hooks/use-document-lock.ts"
      provides: "Lock state management, heartbeat, inactivity timer, WebSocket subscription"
      contains: "useDocumentLock|acquireLock|releaseLock|forceTakeLock|lockHolder"
    - path: "electron-app/src/renderer/components/knowledge/LockBanner.tsx"
      provides: "Lock status banner UI component"
      contains: "LockBanner|Stop editing|Being edited by|Take over editing"
  key_links:
    - from: "electron-app/src/renderer/hooks/use-document-lock.ts"
      to: "/api/documents/{id}/lock"
      via: "window.electronAPI.post/delete/get"
      pattern: "electronAPI\\.(post|delete|get).*lock"
    - from: "electron-app/src/renderer/hooks/use-document-lock.ts"
      to: "electron-app/src/renderer/lib/websocket.ts"
      via: "MessageType.DOCUMENT_LOCKED subscription"
      pattern: "MessageType\\.DOCUMENT_LOCKED"
    - from: "electron-app/src/renderer/components/knowledge/document-editor.tsx"
      to: "electron-app/src/renderer/hooks/use-document-lock.ts"
      via: "useDocumentLock hook integration"
      pattern: "useDocumentLock"
---

<objective>
Build the frontend document locking integration: useDocumentLock hook with heartbeat/inactivity timer/WebSocket listener, LockBanner component, and editor integration that toggles read-only mode based on lock state.

Purpose: Users see real-time lock status, can acquire/release/force-take locks, and the editor automatically becomes read-only when another user holds the lock.
Output: Working lock hook, lock banner UI, and editor integration with auto-release on inactivity.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-document-locking/05-RESEARCH.md
@.planning/phases/05-document-locking/05-01-SUMMARY.md

# Existing patterns to follow:
@electron-app/src/renderer/hooks/use-presence.ts
@electron-app/src/renderer/hooks/use-websocket.ts
@electron-app/src/renderer/hooks/use-websocket-cache.ts
@electron-app/src/renderer/hooks/use-queries.ts
@electron-app/src/renderer/hooks/use-auto-save.ts
@electron-app/src/renderer/hooks/index.ts
@electron-app/src/renderer/lib/websocket.ts
@electron-app/src/renderer/components/knowledge/document-editor.tsx
@electron-app/src/renderer/contexts/auth-context.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: WebSocket message types + useDocumentLock hook</name>
  <files>
    electron-app/src/renderer/lib/websocket.ts
    electron-app/src/renderer/hooks/use-document-lock.ts
    electron-app/src/renderer/hooks/index.ts
  </files>
  <action>
    **Update `electron-app/src/renderer/lib/websocket.ts`:**

    Add three new entries to the `MessageType` enum (in a "Document lock events" section, after existing entries before PING/PONG):
    ```typescript
    // Document lock events
    DOCUMENT_LOCKED = 'document_locked',
    DOCUMENT_UNLOCKED = 'document_unlocked',
    DOCUMENT_FORCE_TAKEN = 'document_force_taken',
    ```

    **Create `electron-app/src/renderer/hooks/use-document-lock.ts`:**

    Follow the pattern from `use-presence.ts` for heartbeat and `use-queries.ts` for API calls.

    Types:
    ```typescript
    export interface LockHolder {
      user_id: string
      user_name: string
      acquired_at: number | null
    }

    export interface UseDocumentLockOptions {
      documentId: string | null
      userId: string
      userName: string
      userRole: string | null  // 'owner' | 'editor' | 'viewer' | null
      onBeforeRelease?: () => Promise<void>  // Save callback (Phase 4's saveNow)
    }

    export interface UseDocumentLockReturn {
      lockHolder: LockHolder | null
      isLockedByMe: boolean
      isLockedByOther: boolean
      acquireLock: () => Promise<boolean>
      releaseLock: () => Promise<void>
      forceTakeLock: () => Promise<boolean>
      canForceTake: boolean
      isLoading: boolean
    }
    ```

    Implementation details:

    1. **Lock status query**: Use `useQuery` with key `['document-lock', documentId]`, fetching `GET /api/documents/{documentId}/lock` via `window.electronAPI.get()` with auth headers (follow `use-queries.ts` `getAuthHeaders()` pattern). Set `refetchInterval: 30000` (30s fallback poll). Enabled only when `documentId` is not null.

    2. **Acquire mutation**: `useMutation` calling `POST /api/documents/{documentId}/lock` via `window.electronAPI.post()`. On success, invalidate the lock query. On 409 error, invalidate lock query (another user has it).

    3. **Release mutation**: `useMutation` calling `DELETE /api/documents/{documentId}/lock` via `window.electronAPI.delete()`. Call `onBeforeRelease?.()` first (save before release). On success, invalidate lock query. Use a `lockReleasedRef = useRef(false)` to prevent double-release.

    4. **Force-take mutation**: `useMutation` calling `POST /api/documents/{documentId}/lock/force-take` via `window.electronAPI.post()`. On success, invalidate lock query.

    5. **Heartbeat**: `useEffect` with `setInterval(10000)` that calls `POST /api/documents/{documentId}/lock/heartbeat` via `window.electronAPI.post()`. Only runs when `isLockedByMe === true`. Clear interval on cleanup. If heartbeat returns 409, set lock state to lost (invalidate query).

    6. **Inactivity timer**: Track `lastActivityRef = useRef(Date.now())`. Register `keydown` and `mousemove` listeners on the document editor container (accept an optional `editorElementRef?: RefObject<HTMLElement>` in options -- or just use `document` level listeners filtered by target). Use `setInterval(5000)` to check: if `Date.now() - lastActivityRef.current > 30000`, call `onBeforeRelease?.()` then `releaseLock()`. Only active when `isLockedByMe`. Reset `lastActivityRef` on each tracked event.

    IMPORTANT: Use `useRef` (not `useState`) for lastActivity, lockReleasedRef, and heartbeat timer to avoid re-renders. Follow the pattern from `use-auto-save.ts` which uses refs for similar concerns.

    7. **WebSocket subscription**: Use the WebSocket hook (check `use-websocket.ts` for the subscribe API). Listen for `DOCUMENT_LOCKED`, `DOCUMENT_UNLOCKED`, `DOCUMENT_FORCE_TAKEN` messages where `data.document_id` matches. On receive:
       - `DOCUMENT_LOCKED`: Update lock query cache with new holder
       - `DOCUMENT_UNLOCKED`: Update lock query cache to unlocked
       - `DOCUMENT_FORCE_TAKEN`: If `data.lock_holder.user_id !== userId` (I lost the lock): call `onBeforeRelease?.()` immediately, then update cache. If it IS me: I now hold the lock, start heartbeat.

    8. **Cleanup on unmount**: In `useEffect` cleanup, if `isLockedByMe`, call release (fire-and-forget via `window.electronAPI.delete()` directly, not the mutation, since mutation cleanup may not run). Check `lockReleasedRef` to prevent double-release.

    9. **Derived state**:
       - `isLockedByMe = lockHolder?.user_id === userId`
       - `isLockedByOther = lockHolder != null && lockHolder.user_id !== userId`
       - `canForceTake = isLockedByOther && userRole === 'owner'`

    **Update `electron-app/src/renderer/hooks/index.ts`:**

    Add export for `useDocumentLock` and its types:
    ```typescript
    export {
      useDocumentLock,
      type LockHolder,
      type UseDocumentLockOptions,
      type UseDocumentLockReturn,
    } from './use-document-lock'
    ```
  </action>
  <verify>
    Run `cd electron-app && npx tsc --noEmit src/renderer/hooks/use-document-lock.ts 2>&1 | head -20` to verify TypeScript compilation (may show errors for missing global types -- that's OK as long as no errors in the hook logic itself).

    Run `cd electron-app && npm run typecheck 2>&1 | tail -20` for full project typecheck.
  </verify>
  <done>
    WebSocket MessageType enum includes DOCUMENT_LOCKED/UNLOCKED/FORCE_TAKEN. useDocumentLock hook exists with lock status query, acquire/release/force-take mutations, heartbeat interval, inactivity timer, WebSocket subscription, and unmount cleanup. Hook is exported from hooks index.
  </done>
</task>

<task type="auto">
  <name>Task 2: LockBanner component + editor integration</name>
  <files>
    electron-app/src/renderer/components/knowledge/LockBanner.tsx
    electron-app/src/renderer/components/knowledge/document-editor.tsx
  </files>
  <action>
    **Create `electron-app/src/renderer/components/knowledge/LockBanner.tsx`:**

    Follow existing component patterns (Radix UI + Tailwind). A simple presentational component:

    ```typescript
    interface LockBannerProps {
      lockHolder: LockHolder | null
      isLockedByMe: boolean
      canForceTake: boolean
      onStopEditing: () => void
      onForceTake: () => void
    }
    ```

    Rendering logic:
    - If `lockHolder` is null, return null (no banner)
    - If `isLockedByMe`: Show a subtle blue/primary banner "You are editing this document" with a "Stop editing" button on the right. Use `bg-primary/10 border-b` styling.
    - If locked by other: Show an amber warning banner "Being edited by {lockHolder.user_name}" with an optional "Take over editing" button (only if `canForceTake`). Use `bg-amber-500/10 border-b text-amber-700` styling.
    - Use `Lock` and `Unlock` icons from `lucide-react` for visual clarity.
    - Buttons should use `text-sm hover:underline` styling (lightweight, not prominent).

    **Update `electron-app/src/renderer/components/knowledge/document-editor.tsx`:**

    Integrate the lock hook into the DocumentEditor. This requires changes to the component's props and behavior:

    1. **Add optional lock props to `DocumentEditorProps`** (in `editor-types.ts` if that's where it's defined, or inline):
       - `documentId?: string | null` -- needed for lock operations
       - `userId?: string` -- current user ID
       - `userName?: string` -- current user display name
       - `userRole?: string | null` -- user's role in the document's application
       - `onSaveNow?: () => Promise<void>` -- save callback for onBeforeRelease

    2. **Use the lock hook** inside DocumentEditor (only when documentId is provided):
       ```typescript
       const lock = useDocumentLock({
         documentId: documentId ?? null,
         userId: userId ?? '',
         userName: userName ?? '',
         userRole: userRole ?? null,
         onBeforeRelease: onSaveNow,
       })
       ```

    3. **Toggle editor editable state** based on lock:
       - The editor's `editable` prop should be: `editable && (!lock.isLockedByOther)` (editable from props AND not locked by someone else)
       - When lock state changes (isLockedByOther transitions), call `editor?.setEditable(!lock.isLockedByOther && editable)` in a useEffect

    4. **Render LockBanner** above the editor content (between toolbar and EditorContent):
       ```tsx
       {documentId && (
         <LockBanner
           lockHolder={lock.lockHolder}
           isLockedByMe={lock.isLockedByMe}
           canForceTake={lock.canForceTake}
           onStopEditing={() => lock.releaseLock()}
           onForceTake={() => lock.forceTakeLock()}
         />
       )}
       ```

    5. **Track editor activity for inactivity timer**: The useDocumentLock hook tracks activity via `lastActivityRef`. To feed it, add `onKeyDown` and `onMouseMove` event handlers to the editor container div that reset activity. Alternatively, if the hook uses document-level listeners, no extra wiring is needed -- but scoping to the editor element is preferred (per research anti-patterns).

    IMPORTANT: The lock integration should be gracefully optional. If `documentId` is not provided, the lock hook should be inactive (return idle state) and LockBanner should not render. This ensures the editor can still be used in contexts without locking (e.g., templates, previews).
  </action>
  <verify>
    Run `cd electron-app && npm run typecheck 2>&1 | tail -20` to verify full project typecheck passes.

    Verify LockBanner component exists: `ls electron-app/src/renderer/components/knowledge/LockBanner.tsx`

    Verify editor imports lock hook: search for `useDocumentLock` in `document-editor.tsx`.
  </verify>
  <done>
    LockBanner component renders appropriate UI for locked-by-me, locked-by-other, and unlocked states. DocumentEditor integrates useDocumentLock hook, toggles read-only based on lock state, renders LockBanner, and tracks editor activity for inactivity timer. Lock integration is gracefully optional when documentId is not provided.
  </done>
</task>

</tasks>

<verification>
1. TypeScript check: `cd electron-app && npm run typecheck` passes with zero errors
2. LockBanner renders three states: locked-by-me (stop editing button), locked-by-other (take over button for owners), unlocked (hidden)
3. useDocumentLock exports: acquireLock, releaseLock, forceTakeLock, lockHolder, isLockedByMe, isLockedByOther, canForceTake
4. WebSocket MessageType includes DOCUMENT_LOCKED, DOCUMENT_UNLOCKED, DOCUMENT_FORCE_TAKEN
5. DocumentEditor toggles editable state when lock.isLockedByOther changes
6. Heartbeat interval is 10000ms, inactivity threshold is 30000ms
</verification>

<success_criteria>
- useDocumentLock hook manages full lock lifecycle: query, acquire, release, heartbeat, force-take, inactivity auto-release
- WebSocket subscription updates lock state in real-time (no reload needed)
- LockBanner shows correct UI for all lock states with appropriate action buttons
- Editor becomes read-only when locked by another user
- Inactivity timer calls save before releasing lock
- Force-take triggers save on previous holder's client via WebSocket event
- TypeScript strict mode compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-document-locking/05-02-SUMMARY.md`
</output>
