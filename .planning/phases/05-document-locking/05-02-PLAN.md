---
phase: 05-document-locking
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - electron-app/src/renderer/hooks/use-document-lock.ts
  - electron-app/src/renderer/hooks/index.ts
  - electron-app/src/renderer/components/editor/LockBanner.tsx
  - electron-app/src/renderer/lib/websocket.ts
autonomous: true

must_haves:
  truths:
    - "When user acquires a lock, a heartbeat keeps it alive every 10 seconds"
    - "When user is inactive for 30 seconds, the lock auto-releases after saving"
    - "When another user holds the lock, the UI shows 'Being edited by [name]' in read-only mode"
    - "User can click 'Stop editing' to manually release the lock"
    - "Application owner sees 'Take over editing' button on locked documents"
    - "On force-take WebSocket event, previous editor saves and switches to read-only"
    - "Lock releases on component unmount and beforeunload (no double-release)"
    - "WebSocket events instantly update lock status without waiting for poll"
  artifacts:
    - path: "electron-app/src/renderer/hooks/use-document-lock.ts"
      provides: "useDocumentLock hook with lock state, heartbeat, inactivity timer, WebSocket listener"
      contains: "useDocumentLock"
    - path: "electron-app/src/renderer/components/editor/LockBanner.tsx"
      provides: "Lock status banner with stop editing and force-take controls"
      contains: "LockBanner"
    - path: "electron-app/src/renderer/lib/websocket.ts"
      provides: "DOCUMENT_LOCKED, DOCUMENT_UNLOCKED, DOCUMENT_FORCE_TAKEN message types"
      contains: "DOCUMENT_LOCKED"
  key_links:
    - from: "electron-app/src/renderer/hooks/use-document-lock.ts"
      to: "/api/documents/{id}/lock"
      via: "window.electronAPI.post/delete/get for HTTP calls"
      pattern: "window\\.electronAPI\\."
    - from: "electron-app/src/renderer/hooks/use-document-lock.ts"
      to: "electron-app/src/renderer/lib/websocket.ts"
      via: "WebSocket subscription for lock change events"
      pattern: "MessageType\\.DOCUMENT_"
    - from: "electron-app/src/renderer/components/editor/LockBanner.tsx"
      to: "electron-app/src/renderer/hooks/use-document-lock.ts"
      via: "Hook return values as props"
      pattern: "useDocumentLock"
---

<objective>
Build the frontend document locking UI: useDocumentLock hook (lock state management, heartbeat, inactivity timer, WebSocket listener, cleanup), LockBanner component (editing indicator, stop editing, force-take), and WebSocket message type registration.

Purpose: Give users real-time lock awareness when editing documents -- see who's editing, acquire/release locks, and handle force-take gracefully.
Output: Fully functional lock UI components and hook ready for integration with the document editor.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-document-locking/05-RESEARCH.md
@.planning/phases/05-document-locking/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: WebSocket message types and useDocumentLock hook</name>
  <files>
    electron-app/src/renderer/lib/websocket.ts
    electron-app/src/renderer/hooks/use-document-lock.ts
    electron-app/src/renderer/hooks/index.ts
  </files>
  <action>
**1. WebSocket message types** -- Add to `MessageType` enum in `websocket.ts`:
```typescript
DOCUMENT_LOCKED = 'document_locked',
DOCUMENT_UNLOCKED = 'document_unlocked',
DOCUMENT_FORCE_TAKEN = 'document_force_taken',
```

**2. Create `use-document-lock.ts`** with the `useDocumentLock` hook:

**Interface exports:**
```typescript
export interface LockHolder {
  user_id: string
  user_name: string
  acquired_at: number | null
}

export interface UseDocumentLockReturn {
  lockHolder: LockHolder | null
  isLockedByMe: boolean
  isLockedByOther: boolean
  acquireLock: () => Promise<boolean>
  releaseLock: () => Promise<void>
  forceTakeLock: () => Promise<boolean>
  canForceTake: boolean
  isLoading: boolean
}
```

**Hook signature:** `useDocumentLock(documentId: string, userId: string, userName: string, userRole: string | null, onBeforeRelease?: () => Promise<void>): UseDocumentLockReturn`

Accept userId, userName, userRole as parameters -- do NOT import from Zustand stores (being removed). The `onBeforeRelease` callback is called before lock release to save editor content (Phase 4 integration point).

**Implementation details:**

1. **Lock status query** -- `useQuery` with key `['document-lock', documentId]`:
   - Fetch via `window.electronAPI.get(`/api/documents/${documentId}/lock`)` (NOT raw `fetch`)
   - `refetchInterval: 30000` (30s fallback poll for stale lock detection after crashes)
   - Parse response as `{ locked: boolean, lock_holder: LockHolder | null }`

2. **Acquire mutation** -- `useMutation`:
   - `window.electronAPI.post(`/api/documents/${documentId}/lock`)`
   - On success: invalidate lock query, return true
   - On 409 error: invalidate lock query, return false

3. **Release mutation** -- `useMutation`:
   - Call `onBeforeRelease?.()` first (save content)
   - `window.electronAPI.delete(`/api/documents/${documentId}/lock`)`
   - On success: invalidate lock query

4. **Force-take mutation** -- `useMutation`:
   - `window.electronAPI.post(`/api/documents/${documentId}/lock/force-take`)`
   - On success: invalidate lock query, return true

5. **Heartbeat** -- `useEffect` with `setInterval(10000)`:
   - Only runs when `isLockedByMe` is true
   - Calls `window.electronAPI.post(`/api/documents/${documentId}/lock/heartbeat`)`
   - If heartbeat returns 409, invalidate lock query (lock lost)
   - Clean up interval on effect cleanup

6. **Inactivity timer** -- `useEffect`:
   - Only runs when `isLockedByMe` is true
   - Track `lastActivityRef = useRef(Date.now())`
   - Listen for `keydown` and `mousemove` events on the editor area (NOT global window)
   - Since we don't have a direct ref to the editor here, use `document.querySelector('[data-lock-activity]')` or accept an optional `editorRef` parameter. Simpler: listen on `document` for keydown only (typing is the primary editing activity)
   - `setInterval(5000)` checks: if `Date.now() - lastActivityRef.current > 30000`, call `releaseLock()` (which triggers `onBeforeRelease` first)
   - Clean up listeners and interval on effect cleanup

7. **WebSocket subscription** -- `useEffect`:
   - Subscribe to WebSocket events `DOCUMENT_LOCKED`, `DOCUMENT_UNLOCKED`, `DOCUMENT_FORCE_TAKEN` where `data.document_id === documentId`
   - On any lock event: invalidate `['document-lock', documentId]` query for instant UI update
   - On `DOCUMENT_FORCE_TAKEN` where I was the previous holder (`data.lock_holder.user_id !== userId` and I was previously `isLockedByMe`):
     - Call `onBeforeRelease?.()` to save content immediately
     - The query invalidation will update `isLockedByMe` to false, causing the editor to become read-only
   - Follow `use-websocket-cache.ts` pattern for WebSocket subscription

8. **Cleanup on unmount** -- `useEffect` with empty deps:
   - Use `lockReleasedRef = useRef(false)` to prevent double-release
   - On cleanup: if `isLockedByMe` and not `lockReleasedRef.current`, call release
   - Add `beforeunload` handler that calls release (for Electron window close)
   - Set `lockReleasedRef.current = true` after release

9. **Derived state:**
   - `isLockedByMe = lockHolder?.user_id === userId`
   - `isLockedByOther = lockHolder != null && lockHolder.user_id !== userId`
   - `canForceTake = userRole === 'owner' && isLockedByOther`

**3. Update `hooks/index.ts`** to export `useDocumentLock` and `LockHolder` type.

Reference existing patterns:
- `use-presence.ts` for heartbeat setInterval + cleanup pattern
- `use-queries.ts` for `window.electronAPI` fetch pattern and TanStack Query hooks
- `use-websocket-cache.ts` for WebSocket event subscription and cache invalidation
  </action>
  <verify>
Run `cd electron-app && npx tsc --noEmit src/renderer/hooks/use-document-lock.ts 2>&1 | head -20` to check TypeScript compilation.
Run `cd electron-app && npx eslint src/renderer/hooks/use-document-lock.ts src/renderer/lib/websocket.ts` for linting.
  </verify>
  <done>
`useDocumentLock` hook is implemented with: lock status query (30s poll), acquire/release/force-take mutations via `window.electronAPI`, 10s heartbeat interval, 30s inactivity auto-release with save-before-release callback, WebSocket instant updates for lock events, unmount + beforeunload cleanup with double-release prevention. All HTTP calls go through Electron IPC bridge. No Zustand imports.
  </done>
</task>

<task type="auto">
  <name>Task 2: LockBanner component</name>
  <files>
    electron-app/src/renderer/components/editor/LockBanner.tsx
  </files>
  <action>
Create `LockBanner.tsx` component in `components/editor/`:

**Props interface:**
```typescript
interface LockBannerProps {
  lockHolder: LockHolder | null
  isLockedByMe: boolean
  isLockedByOther: boolean
  canForceTake: boolean
  onStopEditing: () => void
  onForceTake: () => void
}
```

**Rendering logic (three states):**

1. **No lock holder** (`lockHolder === null`): Return `null` (no banner shown)

2. **Locked by me** (`isLockedByMe`):
   - Green-tinted banner: `bg-primary/10 border-b`
   - Left text: "You are editing this document"
   - Right button: "Stop editing" -- calls `onStopEditing`
   - Style: `text-sm`, button with `hover:underline`

3. **Locked by someone else** (`isLockedByOther`):
   - Amber-tinted banner: `bg-amber-500/10 border-b border-amber-200`
   - Left text with lock icon: "Being edited by {lockHolder.user_name}"
   - Right button (only if `canForceTake`): "Take over editing" -- calls `onForceTake`
   - Style: `text-sm text-amber-700`

**Additional details:**
- Use Radix UI `Lock1` icon or simple SVG lock icon if available, otherwise text-only is fine
- Use `flex items-center justify-between px-4 py-2` layout
- Component is pure presentational -- all logic lives in `useDocumentLock` hook
- Import `LockHolder` type from `use-document-lock.ts`

Reference existing patterns:
- Existing banner/notification components for Tailwind styling patterns
- shadcn/ui button styles if using radix button
  </action>
  <verify>
Run `cd electron-app && npx tsc --noEmit src/renderer/components/editor/LockBanner.tsx 2>&1 | head -20` to check TypeScript compilation.
Run `cd electron-app && npx eslint src/renderer/components/editor/LockBanner.tsx` for linting.
  </verify>
  <done>
LockBanner component renders three states: hidden (no lock), green "You are editing" with stop button, amber "Being edited by [name]" with optional force-take button. Component is pure presentational, receiving all state and callbacks as props from `useDocumentLock` hook.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd electron-app && npx tsc --noEmit` passes without errors in new files
2. ESLint passes: `npx eslint src/renderer/hooks/use-document-lock.ts src/renderer/components/editor/LockBanner.tsx src/renderer/lib/websocket.ts`
3. WebSocket MessageType enum has 3 new document lock entries
4. Hook uses `window.electronAPI` for all HTTP calls (no raw `fetch`)
5. Hook accepts userId/userName/userRole as params (no Zustand imports)
6. Heartbeat interval is 10s, inactivity timeout is 30s
7. `onBeforeRelease` callback is called before all release paths (manual, inactivity, force-taken, unmount)
8. `lockReleasedRef` prevents double-release on unmount
</verification>

<success_criteria>
- useDocumentLock hook provides complete lock lifecycle management
- LockBanner shows correct state for locked-by-me, locked-by-other, and unlocked
- WebSocket events update lock UI instantly (no poll delay)
- Inactivity auto-release saves before releasing (30s timeout)
- Force-take triggers save on previous editor via WebSocket event
- No Zustand dependencies; all user info passed as parameters
- All code passes TypeScript strict mode and ESLint
</success_criteria>

<output>
After completion, create `.planning/phases/05-document-locking/05-02-SUMMARY.md`
</output>
