---
phase: 05-document-locking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fastapi-backend/app/services/document_lock_service.py
  - fastapi-backend/app/schemas/document_lock.py
  - fastapi-backend/app/schemas/__init__.py
  - fastapi-backend/app/routers/document_locks.py
  - fastapi-backend/app/main.py
  - fastapi-backend/app/websocket/manager.py
  - fastapi-backend/app/websocket/handlers.py
autonomous: true

must_haves:
  truths:
    - "Lock can be acquired atomically via POST /api/documents/{id}/lock (returns 200 on success, 409 if already locked)"
    - "Lock can be released via DELETE /api/documents/{id}/lock (only by holder)"
    - "Lock TTL extends via POST /api/documents/{id}/lock/heartbeat (only by holder)"
    - "Lock status is queryable via GET /api/documents/{id}/lock"
    - "Application owner can force-take lock via POST /api/documents/{id}/lock/force-take"
    - "Lock acquire/release/force-take events are broadcast via WebSocket to document room"
  artifacts:
    - path: "fastapi-backend/app/services/document_lock_service.py"
      provides: "DocumentLockService with acquire, release, heartbeat, get_lock_holder, force_take_lock"
      contains: "SET.*NX.*EX|RELEASE_SCRIPT|HEARTBEAT_SCRIPT|FORCE_TAKE_SCRIPT"
    - path: "fastapi-backend/app/schemas/document_lock.py"
      provides: "LockHolder and DocumentLockResponse Pydantic schemas"
      exports: ["LockHolder", "DocumentLockResponse"]
    - path: "fastapi-backend/app/routers/document_locks.py"
      provides: "REST endpoints for lock acquire, release, heartbeat, status, force-take"
      contains: "router = APIRouter"
  key_links:
    - from: "fastapi-backend/app/routers/document_locks.py"
      to: "fastapi-backend/app/services/document_lock_service.py"
      via: "Depends injection"
      pattern: "Depends\\(get_lock_service\\)"
    - from: "fastapi-backend/app/services/document_lock_service.py"
      to: "fastapi-backend/app/services/redis_service.py"
      via: "redis_service singleton"
      pattern: "redis_service\\._redis"
    - from: "fastapi-backend/app/routers/document_locks.py"
      to: "fastapi-backend/app/websocket/manager.py"
      via: "broadcast_to_room for lock events"
      pattern: "broadcast_to_room"
---

<objective>
Build the complete backend for document locking: Redis-based lock service with atomic acquire/release/heartbeat/force-take, REST API endpoints, Pydantic schemas, and WebSocket broadcast integration.

Purpose: This is the server-side foundation for all document locking (LOCK-01 through LOCK-07). The frontend plan (05-02) depends on these endpoints existing.
Output: Working lock service, REST endpoints, and WebSocket broadcasts. All lock operations are atomic via Redis Lua scripts.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-document-locking/05-RESEARCH.md

# Existing patterns to follow
@fastapi-backend/app/services/redis_service.py
@fastapi-backend/app/websocket/manager.py
@fastapi-backend/app/websocket/handlers.py
@fastapi-backend/app/websocket/presence.py
@fastapi-backend/app/routers/notes.py
@fastapi-backend/app/schemas/note.py
@fastapi-backend/app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DocumentLockService and Pydantic schemas</name>
  <files>
    fastapi-backend/app/services/document_lock_service.py
    fastapi-backend/app/schemas/document_lock.py
    fastapi-backend/app/schemas/__init__.py
  </files>
  <action>
    **Create `fastapi-backend/app/schemas/document_lock.py`:**
    - `LockHolder(BaseModel)`: `user_id: str`, `user_name: str`, `acquired_at: Optional[float] = None`
    - `DocumentLockResponse(BaseModel)`: `locked: bool`, `lock_holder: Optional[LockHolder] = None`
    - Add both to `schemas/__init__.py` `__all__` list

    **Create `fastapi-backend/app/services/document_lock_service.py`:**
    - Follow the same module pattern as `redis_service.py` and `presence.py` (module docstring, logging, constants, class)
    - Constants: `LOCK_KEY_PREFIX = "doc_lock:"`, `LOCK_TTL_SECONDS = 45`, `HEARTBEAT_INTERVAL = 10`
    - Class `DocumentLockService` with these methods (all async, all type-hinted):

    1. `_lock_key(self, document_id: str) -> str` -- returns `f"{LOCK_KEY_PREFIX}{document_id}"`

    2. `acquire_lock(self, document_id: str, user_id: str, user_name: str) -> dict | None`
       - Use `redis_service._redis.set(key, lock_value, nx=True, ex=LOCK_TTL_SECONDS)`
       - `lock_value` is JSON: `{"user_id": user_id, "user_name": user_name, "acquired_at": time.time()}`
       - Return parsed dict on success, None if already locked

    3. `release_lock(self, document_id: str, user_id: str) -> bool`
       - Use Lua script `RELEASE_SCRIPT`: GET key, decode JSON, compare user_id, DEL if match, return 1/0
       - Use `redis_service._redis.eval(RELEASE_SCRIPT, 1, key, user_id)`

    4. `heartbeat(self, document_id: str, user_id: str) -> bool`
       - Use Lua script `HEARTBEAT_SCRIPT`: GET key, decode JSON, compare user_id, EXPIRE if match, return 1/0
       - Pass `LOCK_TTL_SECONDS` as ARGV[2]

    5. `get_lock_holder(self, document_id: str) -> dict | None`
       - Simple GET + JSON parse. Return None if key doesn't exist.

    6. `force_take_lock(self, document_id: str, new_user_id: str, new_user_name: str) -> dict | None`
       - Use Lua script `FORCE_TAKE_SCRIPT`: GET old value, SET new value with EX, return old value
       - Return old holder dict (or None if was unlocked)

    - Create module-level singleton: `document_lock_service = DocumentLockService()`
    - Create FastAPI dependency: `async def get_lock_service() -> DocumentLockService: return document_lock_service`

    **Lua scripts** are defined as module-level string constants (RELEASE_SCRIPT, HEARTBEAT_SCRIPT, FORCE_TAKE_SCRIPT). See 05-RESEARCH.md Patterns 3, 4, 5 for exact Lua code.

    **Important:** Access Redis via `redis_service._redis` (the underlying `aioredis.Redis` instance from the existing singleton). Do NOT create a new Redis connection.
  </action>
  <verify>
    `cd fastapi-backend && python -c "from app.services.document_lock_service import document_lock_service, get_lock_service; from app.schemas.document_lock import LockHolder, DocumentLockResponse; print('imports OK')"` succeeds.
    `ruff check app/services/document_lock_service.py app/schemas/document_lock.py` passes with no errors.
  </verify>
  <done>
    DocumentLockService class exists with all 6 methods, 3 Lua scripts defined, singleton and dependency function exported. LockHolder and DocumentLockResponse schemas exist and are registered in __init__.py.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create lock REST endpoints and register router</name>
  <files>
    fastapi-backend/app/routers/document_locks.py
    fastapi-backend/app/main.py
  </files>
  <action>
    **Create `fastapi-backend/app/routers/document_locks.py`:**
    - Follow existing router pattern (see `notes.py`): module docstring, imports, `router = APIRouter(tags=["Document Locks"])`
    - All endpoints require `current_user: User = Depends(get_current_user)`
    - All endpoints inject `lock_service: DocumentLockService = Depends(get_lock_service)`

    Endpoints:

    1. `POST /api/documents/{document_id}/lock` -- acquire lock
       - Call `lock_service.acquire_lock(str(document_id), str(current_user.id), current_user.display_name)`
       - On success: broadcast `document_locked` event to room `document:{document_id}`, return `DocumentLockResponse(locked=True, lock_holder=result)`
       - On failure (None returned): call `get_lock_holder` to get current holder, raise `HTTPException(409, detail={"message": "Document is locked", "lock_holder": holder})`

    2. `DELETE /api/documents/{document_id}/lock` -- release lock
       - Call `lock_service.release_lock(str(document_id), str(current_user.id))`
       - If released: broadcast `document_unlocked` event, return `DocumentLockResponse(locked=False, lock_holder=None)`
       - If not released (not the holder): raise `HTTPException(409, detail="Lock not held by you")`

    3. `POST /api/documents/{document_id}/lock/heartbeat` -- extend TTL
       - Call `lock_service.heartbeat(str(document_id), str(current_user.id))`
       - If extended: return `{"extended": True}`
       - If not extended: raise `HTTPException(409, detail="Lock not held by you")`

    4. `GET /api/documents/{document_id}/lock` -- get lock status
       - Call `lock_service.get_lock_holder(str(document_id))`
       - Return `DocumentLockResponse(locked=holder is not None, lock_holder=holder)`

    5. `POST /api/documents/{document_id}/lock/force-take` -- owner override
       - **Permission check:** Query the document's application_id from the database, then check if current_user is the application owner. If not, raise `HTTPException(403, detail="Only application owners can force-take locks")`. Use the same permission checking pattern as other routers (query ApplicationMember or check Application.owner_id).
       - If previous holder exists, broadcast `document_force_taken` event with `triggered_by` set to current user
       - Also broadcast `document_locked` event with new holder
       - Return `DocumentLockResponse(locked=True, lock_holder=new_holder)`

    **Broadcasting:** Use `manager.broadcast_to_room(f"document:{document_id}", message)` where message follows the existing pattern: `{"type": MessageType.DOCUMENT_LOCKED, "data": {...}}`. Import `connection_manager` from `websocket.manager`.

    **Register in `main.py`:**
    - Add import: `from .routers.document_locks import router as document_locks_router`
    - Add: `app.include_router(document_locks_router)` after the existing router registrations
  </action>
  <verify>
    `cd fastapi-backend && python -c "from app.routers.document_locks import router; print(f'{len(router.routes)} routes registered')"` prints "5 routes registered" (or similar).
    `ruff check app/routers/document_locks.py` passes.
    `python -c "from app.main import app; print([r.path for r in app.routes if 'lock' in r.path])"` shows the 5 lock endpoints.
  </verify>
  <done>
    Five REST endpoints exist and are registered in the FastAPI app. Acquire returns 200/409, release returns 200/409, heartbeat returns 200/409, status returns 200, force-take returns 200/403. All endpoints broadcast lock events via WebSocket.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add WebSocket message types and lock broadcast handler</name>
  <files>
    fastapi-backend/app/websocket/manager.py
    fastapi-backend/app/websocket/handlers.py
  </files>
  <action>
    **Update `fastapi-backend/app/websocket/manager.py`:**
    - Add new entries to the `MessageType` enum (after the NOTE_* entries):
      ```python
      # Document lock events
      DOCUMENT_LOCKED = "document_locked"
      DOCUMENT_UNLOCKED = "document_unlocked"
      DOCUMENT_LOCK_EXPIRED = "document_lock_expired"
      DOCUMENT_FORCE_TAKEN = "document_force_taken"
      DOCUMENT_FORCE_SAVE_REQUESTED = "document_force_save_requested"
      ```

    **Update `fastapi-backend/app/websocket/handlers.py`:**
    - Add a helper function `handle_lock_broadcast` that the router calls when broadcasting lock events. This function:
      1. Accepts `document_id: str`, `event_type: str` (one of "locked", "unlocked", "expired", "force_taken"), `lock_holder: dict | None`, and optional `triggered_by: str | None`
      2. Constructs the message dict: `{"type": f"document_{event_type}", "data": {"document_id": document_id, "lock_holder": lock_holder, "triggered_by": triggered_by, "timestamp": datetime.utcnow().isoformat()}}`
      3. Calls `await connection_manager.broadcast_to_room(f"document:{document_id}", message)`

    - Also add handler for `document_force_save_requested` in the incoming message router (`route_incoming_message`): When the server needs to tell a specific client to save (force-take flow), it sends a targeted message to the lock holder's connection. Follow the existing pattern for routing messages by type.

    **Important:** The router (document_locks.py) imports and calls `handle_lock_broadcast` directly. This keeps the WebSocket broadcast logic centralized in the handlers module, following the existing pattern where routers call handler functions for broadcasts (e.g., `handle_task_update`, `handle_note_update`).
  </action>
  <verify>
    `cd fastapi-backend && python -c "from app.websocket.manager import MessageType; print(MessageType.DOCUMENT_LOCKED, MessageType.DOCUMENT_UNLOCKED, MessageType.DOCUMENT_FORCE_TAKEN)"` prints the enum values.
    `python -c "from app.websocket.handlers import handle_lock_broadcast; print('handler imported')"` succeeds.
    `ruff check app/websocket/manager.py app/websocket/handlers.py` passes.
  </verify>
  <done>
    Five new MessageType enum values exist. handle_lock_broadcast function exists in handlers.py and is importable. Force-save-requested message type is routable for the force-take flow. All code passes ruff linting.
  </done>
</task>

</tasks>

<verification>
1. All new Python files pass `ruff check .` with zero errors
2. All imports resolve: `python -c "from app.services.document_lock_service import document_lock_service; from app.schemas.document_lock import LockHolder, DocumentLockResponse; from app.routers.document_locks import router; from app.websocket.handlers import handle_lock_broadcast; print('all imports OK')"`
3. Router is registered in main.py and lock endpoints appear in app routes
4. MessageType enum contains all 5 new lock-related values
5. `pytest tests/ -v -k lock` runs (even if no tests yet, it should not error on import)
</verification>

<success_criteria>
- DocumentLockService is fully implemented with atomic Redis operations (SET NX EX, Lua scripts for release/heartbeat/force-take)
- Five REST endpoints are functional and return correct HTTP status codes
- WebSocket message types exist for all lock events
- Lock broadcast handler is centralized in handlers.py
- All code follows existing naming conventions, type hints, and module patterns
</success_criteria>

<output>
After completion, create `.planning/phases/05-document-locking/05-01-SUMMARY.md`
</output>
