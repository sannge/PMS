---
phase: 05-document-locking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fastapi-backend/app/services/document_lock_service.py
  - fastapi-backend/app/schemas/document_lock.py
  - fastapi-backend/app/routers/document_locks.py
  - fastapi-backend/app/websocket/manager.py
  - fastapi-backend/app/websocket/handlers.py
  - fastapi-backend/app/websocket/room_auth.py
  - fastapi-backend/app/schemas/__init__.py
  - fastapi-backend/app/routers/__init__.py
  - fastapi-backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "Lock acquire returns success with holder info when document is unlocked"
    - "Lock acquire returns 409 Conflict with current holder info when document is already locked by another user"
    - "Lock release only succeeds when called by the current lock holder"
    - "Heartbeat extends the lock TTL only for the current lock holder"
    - "Force-take overwrites the lock and returns previous holder info, only for application owners"
    - "Lock status GET returns current holder or unlocked state"
    - "WebSocket broadcasts DOCUMENT_LOCKED, DOCUMENT_UNLOCKED, DOCUMENT_FORCE_TAKEN to the document room on lock changes"
    - "Document room auth allows users with access to the document's application"
  artifacts:
    - path: "fastapi-backend/app/services/document_lock_service.py"
      provides: "DocumentLockService with acquire, release, heartbeat, force_take, get_lock_holder"
      contains: "SET.*nx=True.*ex="
    - path: "fastapi-backend/app/schemas/document_lock.py"
      provides: "LockHolder and DocumentLockResponse Pydantic models"
      exports: ["LockHolder", "DocumentLockResponse"]
    - path: "fastapi-backend/app/routers/document_locks.py"
      provides: "REST endpoints for lock CRUD"
      contains: "router = APIRouter"
    - path: "fastapi-backend/app/websocket/manager.py"
      provides: "DOCUMENT_LOCKED, DOCUMENT_UNLOCKED, DOCUMENT_FORCE_TAKEN MessageType entries"
      contains: "DOCUMENT_LOCKED"
    - path: "fastapi-backend/app/websocket/handlers.py"
      provides: "handle_document_lock_change broadcast function"
      contains: "handle_document_lock_change"
    - path: "fastapi-backend/app/websocket/room_auth.py"
      provides: "document room type access check"
      contains: "document"
  key_links:
    - from: "fastapi-backend/app/routers/document_locks.py"
      to: "fastapi-backend/app/services/document_lock_service.py"
      via: "Depends(get_lock_service)"
      pattern: "Depends\\(get_lock_service\\)"
    - from: "fastapi-backend/app/routers/document_locks.py"
      to: "fastapi-backend/app/websocket/handlers.py"
      via: "handle_document_lock_change call after lock state change"
      pattern: "handle_document_lock_change"
    - from: "fastapi-backend/app/services/document_lock_service.py"
      to: "redis_service.client"
      via: "Direct Redis SET/EVAL calls"
      pattern: "redis_service\\.client\\."
---

<objective>
Build the complete backend document locking system: Redis lock service with atomic Lua scripts, Pydantic schemas, REST endpoints (acquire, release, heartbeat, status, force-take), WebSocket message types and broadcast handler, and document room auth.

Purpose: Enable the frontend (plan 05-02) to manage document edit locks with real-time lock status propagation to all viewers.
Output: Working lock service, REST API, and WebSocket infrastructure ready for frontend integration.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-document-locking/05-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Document lock service and Pydantic schemas</name>
  <files>
    fastapi-backend/app/services/document_lock_service.py
    fastapi-backend/app/schemas/document_lock.py
    fastapi-backend/app/schemas/__init__.py
  </files>
  <action>
Create `document_lock_service.py` with a `DocumentLockService` class:

**Constants:**
- `LOCK_KEY_PREFIX = "doc_lock:"`
- `LOCK_TTL_SECONDS = 45` (allows 3 missed heartbeats + 15s jitter buffer; client heartbeat is 10s)

**Helper:** `_lock_key(document_id: str) -> str` returns `f"{LOCK_KEY_PREFIX}{document_id}"`

**Methods (all async):**

1. `acquire_lock(document_id: str, user_id: str, user_name: str) -> dict | None`
   - Use `redis_service.client.set(key, value, nx=True, ex=LOCK_TTL_SECONDS)` -- NOT `redis_service.set()` which uses `setex` without NX support
   - Value is JSON: `{"user_id": user_id, "user_name": user_name, "acquired_at": time.time()}`
   - Returns parsed dict on success, None if already locked
   - `decode_responses=True` means `set(..., nx=True)` returns `True | None`, not bytes

2. `release_lock(document_id: str, user_id: str) -> bool`
   - Lua script: GET key, decode JSON, compare user_id, DEL if match, return 1/0
   - Use `redis_service.client.eval(script, 1, key, user_id)`
   - Returns True if released, False otherwise

3. `heartbeat(document_id: str, user_id: str) -> bool`
   - Lua script: GET key, decode JSON, compare user_id, EXPIRE with `tonumber(ARGV[2])` if match
   - CRITICAL: Use `tonumber(ARGV[2])` in Lua -- ARGV values are strings
   - Returns True if extended, False otherwise

4. `force_take_lock(document_id: str, new_user_id: str, new_user_name: str) -> dict | None`
   - Lua script: GET current (save old), SET new value with EX, return old value
   - Returns previous holder dict or None if was unlocked

5. `get_lock_holder(document_id: str) -> dict | None`
   - Simple GET + JSON parse
   - Returns holder dict or None

**Dependency injection:** Add `get_lock_service() -> DocumentLockService` function for FastAPI `Depends()`.

Create `document_lock.py` schema file with:
- `LockHolder(BaseModel)`: user_id (str), user_name (str), acquired_at (Optional[float])
- `DocumentLockResponse(BaseModel)`: locked (bool), lock_holder (Optional[LockHolder])
- Both with `model_config = ConfigDict(from_attributes=True)`

Update `schemas/__init__.py` to import/export new schemas.

Reference existing patterns:
- `redis_service.py` for `.client` property access
- `comment.py` schema for Pydantic pattern with ConfigDict and Field
  </action>
  <verify>
Run `cd fastapi-backend && python -c "from app.services.document_lock_service import DocumentLockService, get_lock_service; from app.schemas.document_lock import LockHolder, DocumentLockResponse; print('OK')"` to verify imports.
Run `cd fastapi-backend && ruff check app/services/document_lock_service.py app/schemas/document_lock.py` for linting.
  </verify>
  <done>
DocumentLockService class exists with 5 async methods using atomic Redis operations (SET NX EX + Lua scripts). Pydantic schemas LockHolder and DocumentLockResponse are importable. All Lua scripts use `tonumber()` for EXPIRE arguments and `cjson.decode()` for JSON parsing.
  </done>
</task>

<task type="auto">
  <name>Task 2: REST endpoints, WebSocket infrastructure, and router registration</name>
  <files>
    fastapi-backend/app/routers/document_locks.py
    fastapi-backend/app/routers/__init__.py
    fastapi-backend/app/websocket/manager.py
    fastapi-backend/app/websocket/handlers.py
    fastapi-backend/app/websocket/room_auth.py
    fastapi-backend/app/main.py
  </files>
  <action>
**1. WebSocket message types** -- Add to `MessageType` enum in `manager.py`:
```python
DOCUMENT_LOCKED = "document_locked"
DOCUMENT_UNLOCKED = "document_unlocked"
DOCUMENT_FORCE_TAKEN = "document_force_taken"
```

**2. WebSocket handler** -- Add to `handlers.py`:

Add `get_document_room(document_id) -> str` returning `f"document:{document_id}"`.

Add `handle_document_lock_change(document_id, lock_type, lock_holder, triggered_by=None, connection_manager=None) -> BroadcastResult`:
- `lock_type` is `"locked"` | `"unlocked"` | `"force_taken"`
- Map to correct MessageType enum value
- Build message with type, data (document_id, lock_holder, triggered_by, timestamp)
- Call `mgr.broadcast_to_room(room_id, message)` -- this publishes via Redis pub/sub (cross-worker safe)
- Return `BroadcastResult` following existing handler pattern (see `handle_task_update`)

**3. Room auth** -- Update `room_auth.py`:

Add `"document"` room type to `_check_room_access_async`:
```python
elif room_type == "document":
    return await _check_document_access(db, user_id, resource_id)
```

Add `_check_document_access(db, user_id, document_id)`:
- Import Document model from `app.models.document`
- Query document by ID
- If not found, return False
- Check application membership via existing `_check_application_access(db, user_id, document.application_id)`
- Handle personal documents (application_id is None): check `document.created_by == user_id`

**4. REST router** -- Create `document_locks.py` with `router = APIRouter(prefix="/api/documents", tags=["document-locks"])`:

Endpoints (all require `current_user: User = Depends(get_current_user)`):

- `POST /{document_id}/lock` -- Acquire lock. Call `lock_service.acquire_lock()`. On success, broadcast DOCUMENT_LOCKED and return `DocumentLockResponse(locked=True, ...)`. On failure, return 409 with current holder info.

- `DELETE /{document_id}/lock` -- Release lock. Call `lock_service.release_lock()`. On success, broadcast DOCUMENT_UNLOCKED. Return `DocumentLockResponse(locked=False, lock_holder=None)`.

- `POST /{document_id}/lock/heartbeat` -- Heartbeat. Call `lock_service.heartbeat()`. Return 409 if not held by caller. Return `{"extended": True}` on success.

- `GET /{document_id}/lock` -- Get status. Call `lock_service.get_lock_holder()`. Return `DocumentLockResponse`.

- `POST /{document_id}/lock/force-take` -- Force-take (owner only). Query Document model to get `application_id`. Use `PermissionService.get_user_application_role()` to verify "owner" role. Call `lock_service.force_take_lock()`. If previous holder existed, broadcast DOCUMENT_FORCE_TAKEN. Return new lock info.

**5. Registration:**
- Update `routers/__init__.py` to import the new router
- Update `main.py` to include `document_locks.router` (follow existing router registration pattern)

Reference existing patterns:
- `comments.py` router for auth dependencies and response models
- `handlers.py` `handle_task_update` for broadcast pattern and `BroadcastResult`
- `room_auth.py` `_check_project_access` for room access check pattern
  </action>
  <verify>
Run `cd fastapi-backend && python -c "from app.routers.document_locks import router; print('Routes:', [r.path for r in router.routes])"` to verify endpoints.
Run `cd fastapi-backend && python -c "from app.websocket.manager import MessageType; print(MessageType.DOCUMENT_LOCKED.value)"` to verify message types.
Run `cd fastapi-backend && ruff check app/routers/document_locks.py app/websocket/manager.py app/websocket/handlers.py app/websocket/room_auth.py` for linting.
  </verify>
  <done>
5 REST endpoints registered (acquire, release, heartbeat, status, force-take). 3 new MessageType entries exist. `handle_document_lock_change` broadcasts lock events to document rooms. `room_auth.py` handles `document:{uuid}` room access checks. Router is registered in main.py.
  </done>
</task>

</tasks>

<verification>
1. All imports resolve: `python -c "from app.services.document_lock_service import DocumentLockService; from app.routers.document_locks import router; from app.websocket.manager import MessageType; print(MessageType.DOCUMENT_LOCKED.value)"`
2. Ruff passes: `ruff check app/services/document_lock_service.py app/schemas/document_lock.py app/routers/document_locks.py app/websocket/manager.py app/websocket/handlers.py app/websocket/room_auth.py`
3. Router has 5 routes at correct paths
4. Lua scripts use `tonumber()` for EXPIRE, `cjson.decode()` for JSON parsing
5. Lock service uses `redis_service.client.set(... nx=True, ex=...)` not `redis_service.set()`
</verification>

<success_criteria>
- DocumentLockService has 5 methods with atomic Redis operations
- 5 REST endpoints handle all lock operations with proper auth
- Force-take restricted to application owners via PermissionService
- WebSocket broadcasts propagate lock changes to document rooms
- Document room auth checks application membership
- All code passes ruff linting
</success_criteria>

<output>
After completion, create `.planning/phases/05-document-locking/05-01-SUMMARY.md`
</output>
