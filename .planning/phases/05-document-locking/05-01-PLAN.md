---
phase: 05-document-locking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fastapi-backend/app/services/document_lock_service.py
  - fastapi-backend/app/schemas/document_lock.py
  - fastapi-backend/app/schemas/__init__.py
  - fastapi-backend/app/routers/document_locks.py
  - fastapi-backend/app/routers/__init__.py
  - fastapi-backend/app/websocket/manager.py
  - fastapi-backend/app/websocket/handlers.py
  - fastapi-backend/app/websocket/room_auth.py
  - fastapi-backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "POST /api/documents/{id}/lock acquires lock atomically (returns 200 on success, 409 if already locked by another user)"
    - "DELETE /api/documents/{id}/lock releases lock only if caller owns it"
    - "GET /api/documents/{id}/lock returns current lock status with holder info"
    - "POST /api/documents/{id}/lock/heartbeat extends lock TTL only if caller owns it"
    - "POST /api/documents/{id}/lock/force-take overwrites lock for application owners only (403 for non-owners)"
    - "Lock state changes broadcast WebSocket messages (DOCUMENT_LOCKED, DOCUMENT_UNLOCKED, DOCUMENT_FORCE_TAKEN) to document room"
    - "Document room type is recognized by room_auth.py for WebSocket room joining"
  artifacts:
    - path: "fastapi-backend/app/services/document_lock_service.py"
      provides: "DocumentLockService with Redis lock operations"
      contains: "acquire_lock|release_lock|heartbeat|force_take_lock|get_lock_holder"
    - path: "fastapi-backend/app/schemas/document_lock.py"
      provides: "Pydantic schemas for lock API"
      contains: "LockHolder|DocumentLockResponse"
    - path: "fastapi-backend/app/routers/document_locks.py"
      provides: "REST endpoints for lock operations"
      contains: "acquire_lock|release_lock|lock_heartbeat|get_lock_status|force_take_lock"
  key_links:
    - from: "fastapi-backend/app/routers/document_locks.py"
      to: "fastapi-backend/app/services/document_lock_service.py"
      via: "Depends(get_lock_service)"
      pattern: "Depends\\(get_lock_service\\)"
    - from: "fastapi-backend/app/routers/document_locks.py"
      to: "fastapi-backend/app/websocket/handlers.py"
      via: "handle_document_lock_change broadcast call"
      pattern: "handle_document_lock_change"
    - from: "fastapi-backend/app/main.py"
      to: "fastapi-backend/app/routers/document_locks.py"
      via: "app.include_router"
      pattern: "document_locks_router"
---

<objective>
Build the backend document locking system: Redis-backed lock service with Lua scripts for atomicity, Pydantic schemas, REST endpoints, WebSocket message types with broadcast handler, and document room auth.

Purpose: Enables the frontend (Plan 05-02) to acquire, release, heartbeat, and force-take document locks with real-time status broadcasting to all viewers.
Output: Working lock API endpoints, lock service, WebSocket broadcast handler, and document room auth.
</objective>

<execution_context>
@C:\Users\samng\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\samng\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-document-locking/05-RESEARCH.md

# Existing patterns to follow:
@fastapi-backend/app/services/redis_service.py
@fastapi-backend/app/websocket/manager.py
@fastapi-backend/app/websocket/handlers.py
@fastapi-backend/app/websocket/room_auth.py
@fastapi-backend/app/routers/comments.py
@fastapi-backend/app/schemas/comment.py
@fastapi-backend/app/schemas/__init__.py
@fastapi-backend/app/routers/__init__.py
@fastapi-backend/app/main.py
@fastapi-backend/app/models/document.py
@fastapi-backend/app/services/permission_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: DocumentLockService + Pydantic schemas</name>
  <files>
    fastapi-backend/app/services/document_lock_service.py
    fastapi-backend/app/schemas/document_lock.py
    fastapi-backend/app/schemas/__init__.py
  </files>
  <action>
    **Create `fastapi-backend/app/services/document_lock_service.py`:**

    A `DocumentLockService` class with these methods, all using `redis_service.client` directly (NOT `redis_service.set()`):

    - **Constants:** `LOCK_KEY_PREFIX = "doc_lock:"`, `LOCK_TTL_SECONDS = 45`, key helper `_lock_key(document_id: str) -> str`

    - **`acquire_lock(document_id, user_id, user_name) -> dict | None`**: Use `redis_service.client.set(key, value, nx=True, ex=LOCK_TTL_SECONDS)`. Value is JSON string `{"user_id": user_id, "user_name": user_name, "acquired_at": time.time()}`. Returns parsed dict on success, None if already locked.

    - **`release_lock(document_id, user_id) -> bool`**: Lua script that GETs key, parses JSON with `cjson.decode`, checks `data.user_id == ARGV[1]`, DELs if match. Returns 1 (released) or 0 (not owner/not found). Method returns `result == 1`.

    - **`heartbeat(document_id, user_id) -> bool`**: Lua script that GETs key, parses JSON, checks ownership, EXPIREs with `tonumber(ARGV[2])` if match. Returns 1 or 0.

    - **`force_take_lock(document_id, new_user_id, new_user_name) -> dict | None`**: Lua script that GETs current value (saves as old_holder), SETs new value with EX TTL. Returns old_holder string or nil. Method returns parsed old holder dict or None.

    - **`get_lock_holder(document_id) -> dict | None`**: Simple GET + json.loads. Returns parsed dict or None if no lock.

    - **`get_lock_service() -> DocumentLockService`**: Module-level factory function for FastAPI `Depends()`. Creates and returns a `DocumentLockService` instance.

    CRITICAL: Redis is configured with `decode_responses=True`. This means:
    - `SET NX` returns `True | None` (not bytes)
    - `GET` returns `str | None`
    - `EVAL` returns decoded strings
    - Lua ARGV values are strings -- use `tonumber()` before passing to `EXPIRE`

    **Create `fastapi-backend/app/schemas/document_lock.py`:**

    Follow the pattern from `schemas/comment.py`:

    ```python
    from pydantic import BaseModel, ConfigDict, Field
    from typing import Optional

    class LockHolder(BaseModel):
        model_config = ConfigDict(from_attributes=True)
        user_id: str = Field(..., description="UUID of the lock holder")
        user_name: str = Field(..., description="Display name of the lock holder")
        acquired_at: Optional[float] = Field(None, description="Unix timestamp when lock was acquired")

    class DocumentLockResponse(BaseModel):
        locked: bool = Field(..., description="Whether the document is currently locked")
        lock_holder: Optional[LockHolder] = Field(None, description="Lock holder info if locked")
    ```

    **Update `fastapi-backend/app/schemas/__init__.py`:**

    Add imports for `DocumentLockResponse` and `LockHolder` from `.document_lock`. Add them to the `__all__` list in a "Document lock schemas" section (follow existing pattern).
  </action>
  <verify>
    Run `cd fastapi-backend && python -c "from app.services.document_lock_service import DocumentLockService, get_lock_service; from app.schemas.document_lock import LockHolder, DocumentLockResponse; print('OK')"` to verify imports work.
  </verify>
  <done>
    DocumentLockService class exists with acquire_lock, release_lock, heartbeat, force_take_lock, get_lock_holder methods using Lua scripts. Pydantic schemas exist and are exported from schemas package.
  </done>
</task>

<task type="auto">
  <name>Task 2: REST endpoints + WebSocket types + room auth + wiring</name>
  <files>
    fastapi-backend/app/routers/document_locks.py
    fastapi-backend/app/routers/__init__.py
    fastapi-backend/app/websocket/manager.py
    fastapi-backend/app/websocket/handlers.py
    fastapi-backend/app/websocket/room_auth.py
    fastapi-backend/app/main.py
  </files>
  <action>
    **Create `fastapi-backend/app/routers/document_locks.py`:**

    Follow the existing router pattern from `comments.py`. Create `router = APIRouter(prefix="/api/documents", tags=["document-locks"])` with these endpoints:

    1. **`POST /{document_id}/lock`** -- Acquire lock. Auth via `get_current_user`. Call `lock_service.acquire_lock()`. If None (already locked), get current holder and raise `HTTPException(409, detail={"message": "Document is locked", "lock_holder": holder})`. On success, call `handle_document_lock_change(document_id, "locked", result)` and return `DocumentLockResponse(locked=True, lock_holder=LockHolder(**result))`.

    2. **`DELETE /{document_id}/lock`** -- Release lock. Call `lock_service.release_lock()`. If released, broadcast `handle_document_lock_change(document_id, "unlocked", None)`. Return `DocumentLockResponse(locked=False, lock_holder=None)`.

    3. **`GET /{document_id}/lock`** -- Get lock status. Call `lock_service.get_lock_holder()`. Return appropriate `DocumentLockResponse`.

    4. **`POST /{document_id}/lock/heartbeat`** -- Heartbeat. Call `lock_service.heartbeat()`. If not extended, raise `HTTPException(409, "Lock not held by you")`. Return `{"extended": True}`.

    5. **`POST /{document_id}/lock/force-take`** -- Force-take. Requires DB session via `Depends(get_db)`. Look up `Document` by ID (`from ..models.document import Document`). If not found, 404. Check `PermissionService(db).get_user_application_role(current_user.id, document.application_id)` -- must return `"owner"`, else 403. **Handle personal documents:** If `document.application_id is None` (personal doc), raise 403 "Cannot force-take personal documents". Call `lock_service.force_take_lock()`. Broadcast `handle_document_lock_change(document_id, "force_taken", new_holder, triggered_by=str(current_user.id))`. Return `DocumentLockResponse`.

    **Update `fastapi-backend/app/routers/__init__.py`:**

    Add `from .document_locks import router as document_locks_router` and add `"document_locks_router"` to `__all__`.

    **Update `fastapi-backend/app/websocket/manager.py`:**

    Add three new entries to the `MessageType` enum (after the existing PING/PONG or in a new "Document lock events" section):
    ```python
    # Document lock events
    DOCUMENT_LOCKED = "document_locked"
    DOCUMENT_UNLOCKED = "document_unlocked"
    DOCUMENT_FORCE_TAKEN = "document_force_taken"
    ```

    **Update `fastapi-backend/app/websocket/handlers.py`:**

    Add a `get_document_room(document_id)` helper that returns `f"document:{document_id}"` (follows `get_project_room` pattern).

    Add `handle_document_lock_change(document_id, lock_type, lock_holder, triggered_by=None, connection_manager=None) -> BroadcastResult` function:
    - Map lock_type string ("locked"/"unlocked"/"force_taken") to MessageType enum
    - Build message dict with type, data (document_id, lock_holder, triggered_by, timestamp)
    - Call `mgr.broadcast_to_room(room_id, message)`
    - Return BroadcastResult (follow existing pattern from `handle_task_update`)

    **Update `fastapi-backend/app/websocket/room_auth.py`:**

    In `_check_room_access_async()`, add an `elif room_type == "document":` branch that calls a new `_check_document_access(db, user_id, resource_id)` function.

    `_check_document_access` logic:
    - Import `Document` from `..models.document`
    - Query document by ID
    - If not found, return False
    - If `document.user_id is not None and document.user_id == user_id`, return True (personal doc owner)
    - If `document.application_id is not None`, call `_check_application_access(db, user_id, document.application_id)` (existing function)
    - If `document.project_id is not None`, call `_check_project_access(db, user_id, document.project_id)` (existing function, checks app membership transitively)
    - Otherwise return False

    **Update `fastapi-backend/app/main.py`:**

    Add `document_locks_router` to the import from `.routers`. Add `app.include_router(document_locks_router, prefix="/api", tags=["document-locks"])` after the existing document routers line.
  </action>
  <verify>
    Run `cd fastapi-backend && python -c "from app.main import app; routes = [r.path for r in app.routes]; assert any('lock' in r for r in routes), f'No lock routes: {routes}'; print('Lock routes registered OK')"` to verify router registration.

    Run `cd fastapi-backend && python -c "from app.websocket.manager import MessageType; assert hasattr(MessageType, 'DOCUMENT_LOCKED'); assert hasattr(MessageType, 'DOCUMENT_UNLOCKED'); assert hasattr(MessageType, 'DOCUMENT_FORCE_TAKEN'); print('MessageTypes OK')"` to verify WebSocket message types.

    Run `cd fastapi-backend && python -c "from app.websocket.handlers import handle_document_lock_change, get_document_room; print('Handlers OK')"` to verify handler imports.

    Run `cd fastapi-backend && python -m py_compile app/websocket/room_auth.py && echo 'room_auth compiles OK'` to verify room_auth changes.
  </verify>
  <done>
    Five REST endpoints exist for lock operations. WebSocket MessageType enum includes DOCUMENT_LOCKED/UNLOCKED/FORCE_TAKEN. Lock change handler broadcasts to document room. Room auth recognizes "document" room type. Router is registered in main.py. Force-take checks application owner role. Personal documents cannot be force-taken.
  </done>
</task>

</tasks>

<verification>
1. Import check: `python -c "from app.services.document_lock_service import DocumentLockService; from app.schemas.document_lock import DocumentLockResponse, LockHolder; from app.routers.document_locks import router; from app.websocket.handlers import handle_document_lock_change; print('All imports OK')"`
2. Route check: `python -c "from app.main import app; lock_routes = [r.path for r in app.routes if 'lock' in str(getattr(r, 'path', ''))]; print(f'Lock routes: {lock_routes}'); assert len(lock_routes) >= 4"`
3. MessageType check: `python -c "from app.websocket.manager import MessageType; print([m.value for m in MessageType if 'document' in m.value])"`
4. Typecheck: `cd fastapi-backend && ruff check app/services/document_lock_service.py app/schemas/document_lock.py app/routers/document_locks.py` (if ruff is configured)
</verification>

<success_criteria>
- DocumentLockService uses Lua scripts for all ownership-checked operations (release, heartbeat, force-take)
- All five REST endpoints compile and are registered with the FastAPI app
- WebSocket message types added and broadcast handler follows existing BroadcastResult pattern
- Room auth supports "document" room type with scope-aware access checking
- Force-take endpoint requires application owner role
</success_criteria>

<output>
After completion, create `.planning/phases/05-document-locking/05-01-SUMMARY.md`
</output>
